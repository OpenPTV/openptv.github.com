<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1 Official Loop Notation</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.extensions">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.official"><H1><A name="chapter.official">1 Official Loop Notation</A></H1><P>In order to provide convenient syntax for loops, two new keywords have been introduced in Mozart&nbsp;1.1.0: <CODE><SPAN class="keyword">for</SPAN></CODE> and <CODE><SPAN class="keyword">do</SPAN></CODE>. Thus, a new statement is introduced in the Oz language and its syntax is: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">for</SPAN>&nbsp;</CODE><I>Declarations</I><CODE>&nbsp;<SPAN class="keyword">do</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> where <I>Declarations</I> is a sequence of 0 or more iterator and feature declarations. An iterator has the form: <I>Pat</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>Generator</I> where <I>Generator</I> describes how to generate the successive values for pattern <I>Pat</I> whose variables are local to the loop. The generators are stepped in parallel and the loop terminates as soon as one of the generators runs out of values.</P><H2><A name="label1">1.1 Iterators</A></H2><P>These are the iterators officially supported starting in Mozart&nbsp;1.1.1. For simplicity below, we write <CODE>X</CODE> rather than <CODE>Pat</CODE>. </P><DL><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>L</I> </DT><DD><P>iterates over the elements of list <I>L</I>. At each iteration, <CODE>X</CODE> is bound to the next element in <I>L</I>. The generator runs out when all elements in <I>L</I> have been consumed. </P></DD><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;&nbsp;</CODE><I>E1</I><CODE>;</CODE><I>E2</I><CODE>;</CODE><I>E3</I></DT><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;(</CODE><I>E1</I><CODE>;</CODE><I>E2</I><CODE>;</CODE><I>E3</I><CODE>)</CODE></DT><DD><P>this iterator is intended to have a C-like flavor. <I>E1</I> is the initial value, <I>E2</I> is the boolean condition, and <I>E3</I> is the next value. The iterator runs out when <I>E2</I> evaluates to <CODE><SPAN class="keyword">false</SPAN></CODE>.</P></DD><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>E1</I><CODE><SPAN class="keyword">..</SPAN></CODE><I>E2</I><CODE>;</CODE><I>E3</I></DT><DD><P>iterate over the integers from <I>E1</I> up to <I>E2</I> inclusive, by increment of <I>E3</I>. <I>E1</I>, <I>E2</I> and <I>E3</I> are evaluated only once prior to starting the loop. Whether the loop is intended to count upward or downward is determined by the sign of <I>E3</I>.</P></DD><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>E1</I><CODE><SPAN class="keyword">..</SPAN></CODE><I>E2</I></DT><DD><P>same as above, but with increment of 1.</P></DD><DT><CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>E1</I><CODE>;</CODE><I>E2</I></DT><DD><P>shorthand for <CODE>X&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>E1</I><CODE>;<SPAN class="keyword">true</SPAN>;</CODE><I>E2</I></P></DD></DL><P></P><H2><A name="label2">1.2 Features</A></H2><P>Additional loop functionality is made available through the new notion of loop ``features''. For example, in C, it is possible to <CODE><SPAN class="keyword">break</SPAN></CODE> or <CODE><SPAN class="keyword">continue</SPAN></CODE> the current loop. We generalize this idea by making the ``break'' and ``continue'' capabilities first-class using nullary procedures: thus you can break or continue any loop from any arbitrary level of dynamic nesting. </P><DL><DT><CODE>break:B</CODE></DT><DD><P>binds <CODE>B</CODE> to a nullary procedure which, when invoked immediately breaks out of the corresponding loop. This is currently implemented using an exception, but may change in the future, which means that (1) if you indiscriminately catch all exceptions you may break this functionality, (2) if your code relies on catching ``break'' exceptions, it may not work in a future release.</P></DD><DT><CODE>continue:C</CODE></DT><DD><P>binds <CODE>C</CODE> to a nullary procedure which, when invoked immediately goes on to the next iteration of the loop. The same warning applies as above.</P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.extensions">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
