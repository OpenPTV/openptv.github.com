<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>7 Modules and Interfaces</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#chapter.functional">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.concurrency">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.modules"><H1><A name="chapter.modules">7 Modules and Interfaces</A></H1><P>Modules, also known as packages, are collection of procedures and other values<A href="node7.html#label47"><SUP>1</SUP></A> that are constructed together to provide certain related functionality. A module typically has a number of private procedures that are not visible outside the module and a number of interface procedures that provide the external services of the module. In Oz there is syntactic support for module specification. The concept used is called <EM> functor </EM>. A functor is an expression that specifies the components of a module. The Mozart system converts a functor to a module with the help of a module manager. </P><P>Let us first see what a module is, and then look to a corresponding functor that specifies the module. In general a module is a bunch of locally defined entities, e.g. procedures, objects, accessible through a record interface. Assume that we would like to construct a module called <CODE>List</CODE> that provides a number of interface procedures for appending, sorting and testing membership of lists. This would look as follows. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;List&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MergeSort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{MergeSort&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Member</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;List&nbsp;=&nbsp;<SPAN class="string">'export'</SPAN>(append:&nbsp;Append<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort:&nbsp;Sort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;member:&nbsp;Member<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;)<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>Access to <CODE>Append</CODE> procedure outside of the module <CODE>List&nbsp;</CODE>is done by using the field <CODE>append</CODE> from the <EM>record</EM> <CODE>List</CODE>: <CODE>List<SPAN class="keyword">.</SPAN>append</CODE>. Notice that in the above example the procedure <CODE>MergeSort</CODE> is private to the module. Most of the base library modules of Mozart follow the above structure. The above module can be created from a functor that looks as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">export</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;append:Append<BR>&nbsp;&nbsp;sort:Sort<BR>&nbsp;&nbsp;member:Member<BR>&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Append</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MergeSort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Sort</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{MergeSort&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Member</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Assuming that this functor is stored, somehow, on the file '/home/xxx/list.ozf', the module can be created as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;[List]=&nbsp;{Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">'/home/xxx/list.ozf'</SPAN>]}</CODE></BLOCKQUOTE><P></P><P> <CODE>Module<SPAN class="keyword">.</SPAN>link<SPAN class="keyword">/</SPAN>2</CODE> is a function defined in the module <CODE>Module</CODE> that takes a list of functors, links them together, returns a corresponding list of modules. </P><P>Functors may also have import declarations. If you want to import a system module you can just state the name of its functor. On the other-hand importing a user-defined module requires stating the URL of the file where the functor is stored. </P><P> Consider the following functor. </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<BR><SPAN class="keyword">functor</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Browser&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;FO&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'file:///home/seif/FileOperations.ozf'</SPAN>&nbsp;&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Browser<SPAN class="keyword">.</SPAN>browse&nbsp;{FO<SPAN class="keyword">.</SPAN>countLines&nbsp;<SPAN class="string">'/etc/passwd'</SPAN>}}&nbsp;&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;</CODE></BLOCKQUOTE><P> </P><P> The <CODE><SPAN class="keyword">import</SPAN></CODE> declaration imports the system module <CODE>Browser</CODE>, and uses the procedure <CODE>Browser<SPAN class="keyword">.</SPAN>browse</CODE>. It also imports the module <CODE>FO</CODE> specified by the functor stored in the file <CODE><SPAN class="string">'/home/seif/FileOperations.ozf'</SPAN></CODE>, and calls the procedure <CODE>FO<SPAN class="keyword">.</SPAN>countLines</CODE> which counts the number of lines in a file given as argument. This functor is defined for its effect, therefore it does not export any interface. When this functor is linked the statement between <CODE><SPAN class="keyword">define</SPAN>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE> is executed. </P><P class="warning"><STRONG>Warning:</STRONG>Given a file <CODE><SPAN class="string">'x.oz'</SPAN></CODE> defining a functor, you may create the corresponding functor <CODE><SPAN class="string">'x.ozf'</SPAN></CODE> from your shell by typing the command: </P><BLOCKQUOTE class="code"><CODE>&nbsp;ozc&nbsp;<SPAN class="keyword">-</SPAN>c&nbsp;x<SPAN class="keyword">.</SPAN>ozf&nbsp;</CODE></BLOCKQUOTE><P class="warning"> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#chapter.functional">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#chapter.concurrency">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label47">1. </A>Classes, objects, etc.</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
