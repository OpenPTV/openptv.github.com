<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1 Introduction</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.opi">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.introduction"><H1><A name="chapter.introduction">1 Introduction</A></H1><P>The Mozart system implements Oz 3, the latest in the Oz family of multi-paradigm languages based on the concurrent constraint model. Oz 3 is almost completely upward compatible with its predecessor Oz 2. The main additions to Oz 2 are functors (a kind of software component) and futures (for improved dataflow behavior). Oz 2 is itself a successor to the original Oz 1 language, whose implementation was first released publicly in 1995. Except as otherwise noted, all references to Oz in the Mozart documentation are to Oz 3. </P><P>Oz 3 and the Mozart system have been developed mainly by the research groups of Gert Smolka at the DFKI (the German Research Center for Artificial Intelligence), Seif Haridi at SICS (the Swedish Institute of Computer Science), and Peter Van Roy at UCL (the Université catholique de Louvain). </P><P>Underlying all versions of Oz is a concurrent constraint programming model, extended to support stateful computations, i.e., computations on mutable objects. The theoretical foundation of the concurrent constraint model is given in <A href="bib.html#saraswat94">[Sar94]</A>. The original Oz computation model, Oz 1, supports a fine-grained notion of concurrency where each statement can potentially be executed concurrently. This results in a fine-grained model similar to the actor model. A good exposition of the Oz 1 programming model is given in <A href="bib.html#smolka95">[Smo95]</A>. Our experience using Oz 1 showed that this kind of model, while theoretically appealing, makes it very hard for the programmer to control the resources of his/her application. It is also very hard to debug programs and the object model becomes unnecessarily awkward. </P><P>Oz 2 remedies these problems by using instead a thread-based concurrency model, with explicit creation of threads. A powerful new object system has been designed and traditional exception handling constructs have been added. In addition, the constraint solving and search capabilities have been greatly enhanced. </P><P>Oz 3 conservatively extends Oz 2 with two concepts, <EM>functors</EM> and <EM>futures</EM>, and also corrects several minor syntactic problems. A functor is a kind of software component. It specifies a module in terms of the other modules it needs. This supports incremental construction of programs from components that may be addressable over the Internet by URLs, see <A href="bib.html#duchier98">[Duc98]</A>. A future is a logic variable that can be read but not written. This allows safe dataflow synchronization over the Internet. </P><P>The Mozart system supports distributed and networked applications. It is possible to connect Oz computations located on different sites, resulting in a single network-transparent computation. Mozart supports automatic transfer of stateless data and code among sites, mobile computation (objects), message passing, shared logic variables and orthogonal mechanisms for fault detection and handling for the network and for sites. </P><H2><A name="label1">1.1 Summary of Oz features</A></H2><P>A very good starting point is to ask why Oz. Well, one rough short answer is that, compared to other existing languages, it is magic! It provides programmers and system developers with a wide range of programming abstractions to enable them to develop complex applications quickly and robustly. Oz merges several directions of programming language designs into a single coherent design. Most of us know the benefits of the various programming paradigms whether object-oriented, functional, or constraint logic programming. When we start writing programs in any existing language, we quickly find ourselves confined by the concepts of the underlying paradigm. Oz solves this problem by a coherent design that combines the programming abstractions of various paradigms in a clean and simple way. </P><P>So, before answering the above question, let us see what Oz is. This is again a difficult question to answer in a few sentences. So, here is the first shot. It is a high-level programming language that is designed for modern advanced, concurrent, intelligent, networked, soft real-time, parallel, interactive and pro-active applications. As you see, it is still hard to know what all this jargon means. More concretely: </P><UL><LI><P>Oz combines the salient features of object-oriented programming, by providing state, abstract data types, classes, objects, and inheritance. </P></LI><LI><P>Oz provides the salient features of functional programming by providing a compositional syntax, first-class procedures, and lexical scoping. In fact, every Oz entity is first class, including procedures, threads, classes, methods, and objects. </P></LI><LI><P>Oz provides the salient features of logic programming and constraint programming by providing logic variables, disjunctive constructs, and programmable search strategies. </P></LI><LI><P>Oz is a concurrent language where users can create dynamically any number of sequential threads that can interact with each other. However, in contrast to conventional concurrent languages, each Oz thread is a dataflow thread. Executing a statement in Oz proceeds only when all <EM>real</EM> dataflow dependencies on the variables involved are resolved. </P></LI><LI><P>The Mozart system supports network-transparent distribution of Oz computations. Multiple Oz sites can connect together and automatically behave like a single Oz computation, sharing variables, objects, classes, and procedures. Sites disconnect automatically when references between entities on different sites cease to exist. </P></LI><LI><P>In a distributed environment Oz provides language security. That is, all language entities are created and passed explicitly. An application cannot forge references nor access references that have not been explicitly given to it. The underlying representation of the language entities is inaccessible to the programmer. This is a consequence of having an abstract store and lexical scoping. Along with first-class procedures, these concepts are essential to implement a capability-based security policy, which is important in open distributed computing. </P></LI></UL><P> </P><H2><A name="label2">1.2 The Kernel Language</A></H2><P>This section gives a short but precise introduction to the Oz kernel language. The full Oz language can be regarded as syntactic sugar to a small kernel language. The kernel language represents the essential part of the language. </P><P></P><DIV class="figure" id="corelang"><HR><P><A name="corelang"></A></P></DIV><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>Statement</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>Statement1</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>Statement2</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE><I>f</I><CODE>(</CODE><I>l1</I><CODE>:</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>ln</I><CODE>:</CODE><I>Yn</I><CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>number</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>atom</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE>&lt;<I>boolean</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{NewName&nbsp;</CODE><I>X</I><CODE>}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><I>X</I><CODE>&nbsp;=&nbsp;</CODE><I>Y</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">local</SPAN>&nbsp;</CODE><I>X1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Xn</I><CODE>&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{</CODE><I>X</I><CODE>&nbsp;</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Yn</I><CODE>}&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{X&nbsp;</CODE><I>Y1</I><CODE>&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;</CODE><I>Yn</I><CODE>}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{NewCell&nbsp;Y&nbsp;X}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>Y=<SPAN class="keyword">@</SPAN>X</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>X<SPAN class="keyword">:=</SPAN>Y</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>{Exchange&nbsp;X&nbsp;Y&nbsp;Z}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>B</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">thread</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">try</SPAN>&nbsp;</CODE><I>S1</I><CODE>&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>S2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">raise</SPAN>&nbsp;</CODE><I>X</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><DIV class="figure"><P class="caption"><STRONG>Figure&nbsp;1.1:</STRONG> The Oz kernel language</P><HR></DIV><P> </P><P>The Oz execution model consists of dataflow threads observing a shared store. Threads contain statement sequences <I>Si</I> and communicate through shared references in the store. A thread is <EM>dataflow</EM> if it only executes its next statement when all the values the statement needs are available. If the statement needs a value that is not yet available, then the thread automatically blocks until it can access that value. As we shall see, data availability in the Oz model is implemented using logic variables. The shared store is not physical memory, rather it is an abstract store which only allows operations that are legal for the entities involved, i.e., there is no direct way to inspect the internal representations of entities. The store contains unbound and bound logic variables, cells (named mutable pointers, i.e., explicit state), and procedures (named lexically scoped closures that are first-class entities). Variables can reference the names of procedures and cells. Cells point to variables. The external reference procedures are variables. When a variable is bound, it disappears, that is, all threads that reference it will automatically reference the binding instead. Variables can be bound to any entity, including other variables. The variable and procedure stores are monotonic, i.e., information can only be added to them, not changed or removed. </P><P><A href="node1.html#corelang">Figure&nbsp;1.1</A> defines the abstract syntax of a statement S in the kernel language. We briefly define each possible statement. Statement sequences are reduced sequentially inside a thread. Values (records, numbers, etc.) are introduced explicitly and can be equated to variables. All variables are logic variables, declared in an explicit scope defined by the <CODE><SPAN class="keyword">local</SPAN></CODE> statement. Procedures are defined at run-time with the <CODE><SPAN class="keyword">proc</SPAN></CODE> statement and referred to by a variable. Procedure applications block until their first argument refers to a procedure. State is created explicitly by <EM>NewCell</EM>, which creates a cell, an updateable pointer into the variable store. Cells are read by <CODE><SPAN class="keyword">@</SPAN></CODE> and updated by <CODE><SPAN class="keyword">:=</SPAN></CODE> or alternatively by <EM>Exchange</EM>. Conditionals use the keyword <CODE><SPAN class="keyword">if</SPAN></CODE> and block until the condition variable <I>B</I> is <CODE><SPAN class="keyword">true</SPAN></CODE> or <CODE><SPAN class="keyword">false</SPAN></CODE> in the variable store. Threads are created explicitly with the <CODE><SPAN class="keyword">thread</SPAN></CODE> statement. Exception handling is dynamically scoped and uses the <CODE><SPAN class="keyword">try</SPAN></CODE> and <CODE><SPAN class="keyword">raise</SPAN></CODE> statements. </P><P>The full Oz language is defined by transforming all its statements into this kernel language. This will be explained in detail in this document. Oz supports idioms such as objects, classes, reentrant locks, and ports <A href="bib.html#smolka95">[Smo95]</A><A href="bib.html#pvr97">[VR97]</A>. The system implements them efficiently while respecting their definitions. As an introduction we will give a brief summary of each idiom's definition. For clarity, at this stage we have made small conceptual simplifications. Full definitions are given later in this document. </P><H2><A name="label3">1.3 Classes</A></H2><P>A class is essentially a record that contains the method table and attribute names. A class is defined through multiple inheritance, and any conflicts are resolved at definition time when building its method table. </P><H2><A name="label4">1.4 Objects</A></H2><P>An object is essentially a special record having a number of components. One component is the object's class. Another component is a one-argument procedure that references a cell, which is hidden by lexical scoping. The cell holds the object's state. Applying an object <CODE>Obj</CODE> to message <CODE>M</CODE> applies the object's procedure to <CODE>M</CODE>. The argument indexes into the method table. A method is a procedure that is given a reference to the state cell. In general it modifies the state of the object. </P><H2><A name="label5">1.5 Reentrant locks</A></H2><P>A reentrant lock is essentially a one-argument procedure <CODE>{Lck&nbsp;P}</CODE> used for explicit mutual exclusion, e.g., of method bodies in objects used concurrently. Reentrant locks use cells and logic variables to achieve their behavior. <CODE>P</CODE> is a zero-argument procedure defining the critical section. Reentrant means that the same thread is allowed to reenter the lock. Calls to the lock may therefore be nested. The lock is released automatically if the thread in the body terminates or raises an exception that escapes the lock body. </P><H2><A name="label6">1.6 Ports</A></H2><P>A port is an asynchronous channel that supports many-to-one communication. A port <CODE>P</CODE> encapsulates a stream <CODE>S</CODE>. A stream is a list with unbound tail. The operation <CODE>{Send&nbsp;P&nbsp;M}</CODE> adds <CODE>M</CODE> to the end of <CODE>S</CODE>. Successive sends from the same thread appear in the order they were sent. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.opi">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
