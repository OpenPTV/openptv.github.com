<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4 Equality and the Equality Test Operator</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.control">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.equality"><H1><A name="chapter.equality">4 Equality and the Equality Test Operator</A></H1><P>We have so far shown simple examples of the equality statement, e.g. </P><BLOCKQUOTE class="code"><CODE>W&nbsp;=&nbsp;tree(I&nbsp;Y&nbsp;LT&nbsp;LR)</CODE></BLOCKQUOTE><P> </P><P>These were simple enough to understand intuitively what is going on. However, what happens when two unbound variables are equated <CODE>X&nbsp;=&nbsp;Y</CODE>, or when two large data structures are equated. Here is a short explanation. We may think of the store as a dynamically expanding array of memory words called <EM>nodes</EM>. Each node is labeled by a logic variable. When a variable <CODE>X</CODE> is introduced a new node is created in the store, labeled by <CODE>X</CODE>, having the value <EM>unknown</EM>. At this point, the node does not possess any real value; it is empty as a container that may be filled later. </P><P>A variable labeling a node whose value is <EM>unknown</EM> is an <EM>unbound</EM> variable. The nodes are flexible enough to contain any arbitrary Oz value. The operation </P><BLOCKQUOTE class="code"><CODE>W&nbsp;=&nbsp;tree(1:I&nbsp;2:Y&nbsp;3:LT&nbsp;4:LR)</CODE></BLOCKQUOTE><P> </P><P>stores the record structure in the node associated with <CODE>W</CODE>. Notice that we are just getting a graph structure. The node contains a record with four fields. The fields contain arcs pointing to the nodes labeled by <CODE>I</CODE> ,<CODE>Y</CODE> ,<CODE>LT</CODE>, and <CODE>LR</CODE> respectively. Each arc, in turn, is labeled by the corresponding feature of the record. Given two variables <CODE>X</CODE> and <CODE>Y</CODE>, the operation <CODE>X&nbsp;=&nbsp;Y</CODE> will try to <EM>merge</EM> their respective nodes. Now we are in a position to give a reasonable account for the merge operation <CODE>X&nbsp;=&nbsp;Y</CODE>, known as the <A name="label23"></A> <A name="label24"></A> <A name="label25"></A> <EM>incremental tell</EM> or alternatively the <EM>unification</EM> operation. </P><UL><LI><P>If <I>X</I> and <I>Y</I> label the same node, the operation is completed successfully. </P></LI><LI><P>If <I>X</I> (resp. <I>Y</I>) is unbound then merge the node of <I>X</I> (resp. <I>Y</I>) with the node of <I>Y</I> (resp. <I>X</I>). Merging means replacing all references to the node <I>X</I> by a reference to <I>Y</I><A href="node4.html#label27"><SUP>1</SUP></A>. Conceptually the original node of <I>X</I> has been discarded. </P></LI><LI><P>If <I>X</I> and <I>Y</I> label different nodes containing the records <I>Rx</I> and <I>Ry</I> respectively: </P><UL><LI><P>If <I>Rx</I> and <I>Ry</I> have different labels, arities, or both: the operation is completed, and an exception is raised. </P></LI><LI><P>Otherwise, the arguments of <I>Rx</I> and <I>Ry</I> with the same feature are pair-wise merged in arbitrary order. </P></LI></UL><P> </P></LI></UL><P> </P><P>In general the two graphs, to be merged, could have cycles. However any correct implementation of the merge operation will remember the node pairs for which an attempt to merge has been made earlier, and considers the operation to be successfully performed. A more formal description of the incremental tell operation is found in <A href="bib.html#seif98">[Har98]</A>. </P><P>When a variable is no longer accessible, a process known as garbage collection reclaims its node. </P><P>Here are some examples of successful equality operations: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;f(1:X&nbsp;2:b)&nbsp;=&nbsp;f(a&nbsp;Y)<BR>&nbsp;&nbsp;&nbsp;f(Z&nbsp;a)&nbsp;=&nbsp;Z<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;[X&nbsp;Y&nbsp;Z]}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>will show <CODE>[a&nbsp;b&nbsp;R14=f(R14&nbsp;a)]</CODE> in the browser. <CODE>R14=f(R14&nbsp;a)</CODE> is the external representation of a cyclic graph. </P><P class="warning"><STRONG>Warning:</STRONG>To be able to see the finite representation of Z, you have to switch the Browser to <EM>Minimal Graph</EM> presentation mode. Choose the Option menu, Representation field, and click on Minimal Graph. </P><P class="warning"><STRONG>Warning:</STRONG>The Browser is described in <A href="../browser/index.html">``The Oz Browser''</A>. </P><P>The following example shows, what happens when variables with incompatible values are equated. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;X&nbsp;Y&nbsp;Z&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>X&nbsp;=&nbsp;f(c&nbsp;a)<BR>Y&nbsp;=&nbsp;f(Z&nbsp;b)<BR>X&nbsp;=&nbsp;Y</CODE></BLOCKQUOTE><P> </P><P>The incremental tell of <CODE>X&nbsp;=&nbsp;Y</CODE> will bind <CODE>Z</CODE> to the value <CODE>c</CODE>, but will also raise an exception that is caught by the system, when it tries to equate <CODE>a</CODE> and <CODE>b</CODE>. </P><H2><A name="label26">4.1 Equality test operator <CODE><SPAN class="keyword">==</SPAN></CODE></A></H2><P>The basic procedure <CODE>{Value<SPAN class="keyword">.</SPAN><SPAN class="string">'=='</SPAN>&nbsp;X&nbsp;Y&nbsp;R}</CODE> tries to test whether <CODE>X</CODE> and <CODE>Y</CODE> are equal or not, and returns the result in <CODE>R</CODE>. </P><UL><LI><P>It returns the Boolean value <CODE><SPAN class="keyword">true</SPAN></CODE> if the graphs starting from the nodes of <CODE>X</CODE> and <CODE>Y</CODE> have the same structure, with each pair-wise corresponding nodes having identical Oz values or are the same node. </P></LI><LI><P>It returns the Boolean value <CODE><SPAN class="keyword">false</SPAN></CODE> if the graphs have different structure, or some pair-wise corresponding nodes have different values. </P></LI><LI><P>It suspends when it arrives at pair-wise corresponding nodes that are different, but at least one of them is unbound. </P></LI></UL><P> </P><P>Now remember this, if a procedure suspends, the whole thread suspends! This does not seem very useful. However, as you will see later, it becomes a very useful operation when multiple threads start interacting with each other. </P><P>The equality test is normally used as a functional expression, rather than a statement. <CODE>{Value<SPAN class="keyword">.</SPAN><SPAN class="string">'=='</SPAN>&nbsp;X&nbsp;Y&nbsp;R}</CODE> can also be written <CODE>R&nbsp;=&nbsp;X<SPAN class="keyword">==</SPAN>Y</CODE> using the infix <CODE><SPAN class="keyword">==</SPAN></CODE> operator. This is further illustrated in the example below: </P><BLOCKQUOTE class="code"><CODE>%&nbsp;<SPAN class="comment">See,&nbsp;lists&nbsp;are&nbsp;just&nbsp;tuples,&nbsp;which&nbsp;are&nbsp;just&nbsp;records<BR></SPAN><SPAN class="keyword">local</SPAN>&nbsp;L1&nbsp;L2&nbsp;L3&nbsp;Head&nbsp;Tail&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L1&nbsp;=&nbsp;Head<SPAN class="keyword">|</SPAN>Tail<BR>&nbsp;&nbsp;&nbsp;Head&nbsp;=&nbsp;1<BR>&nbsp;&nbsp;&nbsp;Tail&nbsp;=&nbsp;2<SPAN class="keyword">|</SPAN>nil<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L2&nbsp;=&nbsp;[1&nbsp;2]<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;L1<SPAN class="keyword">==</SPAN>L2}<BR>&nbsp;<BR>&nbsp;&nbsp;&nbsp;L3&nbsp;=&nbsp;<SPAN class="string">'|'</SPAN>(1:1&nbsp;2:<SPAN class="string">'|'</SPAN>(2&nbsp;nil))<BR>&nbsp;&nbsp;&nbsp;{Browse&nbsp;L1<SPAN class="keyword">==</SPAN>L3}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.basics">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.control">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label27">1. </A>This could be done by many various ways. One way is to let the node <I>X</I> point to the node <I>Y</I>, and changing <I>X</I> to be a reference node. The chain of reference node are always traversed before performing any unification operation.</DIV><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
