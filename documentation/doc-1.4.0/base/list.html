<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>6.3 Lists</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="tuple.html#section.records.tuples">&lt;&lt; Prev</A></TD><TD><A href="node8.html">- Up -</A></TD></TR></TABLE><DIV id="section.records.lists"><H2><A name="section.records.lists">6.3 Lists</A></H2><P> The module <A name="label274"></A><SPAN class="index"><CODE>List</CODE></SPAN> contains procedures operating on lists. </P><DL><DT><A name="label275"></A><SPAN class="index"><CODE>IsList</CODE></SPAN> <A name="label277"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is a list. Diverges if <CODE><I>X</I></CODE> is an infinite list. </P></DD><DT><A name="label278"></A><SPAN class="index"><CODE>MakeList</CODE></SPAN> <A name="label280"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>make&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a list of length <CODE><I>I</I></CODE>. All elements are fresh variables. </P></DD><DT><A name="label281"></A><SPAN class="index"><CODE>Append</CODE></SPAN> <A name="label282"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>append&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE><I>Y</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Zs</I></CODE> to the result of appending <CODE><I>Y</I></CODE> to&nbsp;<CODE><I>Xs</I></CODE>. <CODE><I>Y</I></CODE>&nbsp;needs not be a list. However, <CODE><I>Zs</I></CODE> is only a proper list, if also <CODE><I>Y</I></CODE> is a proper list. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Append&nbsp;[1&nbsp;2]&nbsp;[3&nbsp;4]}</CODE></BLOCKQUOTE><P> returns the list <CODE>[1&nbsp;2&nbsp;3&nbsp;4]</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{Append&nbsp;1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>nil&nbsp;3<SPAN class="keyword">|</SPAN>4}</CODE></BLOCKQUOTE><P> returns <CODE>1<SPAN class="keyword">|</SPAN>2<SPAN class="keyword">|</SPAN>(3<SPAN class="keyword">|</SPAN>4)</CODE> which is not a proper list, since <CODE>3<SPAN class="keyword">|</SPAN>4</CODE> is not a proper list. </P></DD><DT><A name="label283"></A><SPAN class="index"><CODE>Member</CODE></SPAN> <A name="label284"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>member&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is equal (in the sense of <CODE><SPAN class="keyword">==</SPAN></CODE>) to some element of&nbsp;<CODE><I>Ys</I></CODE>. Note: all other procedures of the <CODE>List</CODE> module that operate on a list take it as their first argument. <CODE>Member</CODE> is the only exception (for historical reasons). </P></DD><DT><A name="label285"></A><SPAN class="index"><CODE>Length</CODE></SPAN> <A name="label286"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>length&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>I</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the length of&nbsp;<CODE><I>Xs</I></CODE>. </P></DD><DT><A name="label287"></A><SPAN class="index"><CODE>Nth</CODE></SPAN> <A name="label288"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>nth&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the <CODE><I>I</I></CODE>th element of&nbsp;<CODE><I>Xs</I></CODE> (counting from&nbsp;<CODE>1</CODE>). </P></DD><DT><CODE>subtract</CODE> <A name="label290"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>subtract&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE><I>Y</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Zs</I></CODE> to&nbsp;<CODE><I>Xs</I></CODE> without the leftmost occurrence of&nbsp;<CODE><I>Y</I></CODE> if there is one. </P></DD><DT><CODE>sub</CODE> <A name="label292"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>sub&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>Xs</I></CODE> is a sublist of <CODE><I>Ys</I></CODE>, i.&nbsp;e., whether it contains all elements of&nbsp;<CODE><I>Xs</I></CODE> in the same order as&nbsp;<CODE><I>Xs</I></CODE> but not necessarily in succession. </P><P> For example, <CODE>[a&nbsp;b]</CODE> is a sublist of both <CODE>[1&nbsp;a&nbsp;b&nbsp;2]</CODE> and <CODE>[1&nbsp;a&nbsp;2&nbsp;b&nbsp;3]</CODE>, but not of <CODE>[b&nbsp;a]</CODE>. </P></DD><DT><A name="label293"></A><SPAN class="index"><CODE>Reverse</CODE></SPAN> <A name="label294"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>reverse&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the elements of&nbsp;<CODE><I>Xs</I></CODE> in reverse order. </P></DD><DT><A name="label295"></A><SPAN class="index"><CODE>Sort</CODE></SPAN> <A name="label296"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>sort&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Ys</I></CODE> to the result of sorting <CODE><I>Xs</I></CODE> using the ordering&nbsp;<CODE><I>P</I></CODE>. <CODE>Sort</CODE> is implemented using the mergesort algorithm. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Sort&nbsp;[c&nbsp;d&nbsp;b&nbsp;d&nbsp;a]&nbsp;Value<SPAN class="keyword">.</SPAN><SPAN class="string">'&lt;'</SPAN>}</CODE></BLOCKQUOTE><P> returns the list <CODE>[a&nbsp;b&nbsp;c&nbsp;d&nbsp;d]</CODE>. </P></DD><DT><A name="label297"></A><SPAN class="index"><CODE>Merge</CODE></SPAN> <A name="label298"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>merge&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Zs</I></CODE> to the result of merging <CODE><I>Xs</I></CODE> and&nbsp;<CODE><I>Ys</I></CODE> using the ordering&nbsp;<CODE><I>P</I></CODE>. The lists <CODE><I>Xs</I></CODE> and&nbsp;<CODE><I>Ys</I></CODE> must be sorted. </P></DD><DT><A name="label299"></A><SPAN class="index"><CODE>Flatten</CODE></SPAN> <A name="label300"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>flatten&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Ys</I></CODE> to the result of flattening&nbsp;<CODE><I>Xs</I></CODE>, i.&nbsp;e., of concatenating all sublists of&nbsp;<CODE><I>Xs</I></CODE> recursively. </P></DD><DT><CODE>withTail</CODE> <A name="label302"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>withTail&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE><I>Y</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a list with at least <CODE><I>I</I></CODE>&nbsp;elements whose rest is&nbsp;<CODE><I>Y</I></CODE> (which needs not be a list). The first <CODE><I>I</I></CODE> elements are fresh variables. </P><P> For example, <CODE>{List<SPAN class="keyword">.</SPAN>withTail&nbsp;2&nbsp;[a&nbsp;b]}</CODE> returns <CODE>[_&nbsp;_&nbsp;a&nbsp;b]</CODE>. </P></DD><DT><CODE>number</CODE> <A name="label304"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>number&nbsp;</CODE><CODE>+<I>FromI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>ToI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>StepI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a list with elements from <CODE><I>FromI</I></CODE> to <CODE><I>ToI</I></CODE> with step <CODE><I>StepI</I></CODE>. </P><P> For example, <CODE>{List<SPAN class="keyword">.</SPAN>number&nbsp;1&nbsp;5&nbsp;2}</CODE> returns <CODE>[1&nbsp;3&nbsp;5]</CODE>, <CODE>{List<SPAN class="keyword">.</SPAN>number&nbsp;5&nbsp;1&nbsp;2}</CODE> yields the list <CODE>nil</CODE>, and <CODE>{List<SPAN class="keyword">.</SPAN>number&nbsp;5&nbsp;0&nbsp;<SPAN class="keyword">-</SPAN>2}</CODE> yields the list <CODE>[5&nbsp;3&nbsp;1]</CODE>. </P></DD><DT><CODE>take</CODE> <A name="label306"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>take&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the list that contains the first <CODE><I>I</I></CODE>&nbsp;elements of&nbsp;<CODE><I>Xs</I></CODE>, or <CODE><I>Xs</I></CODE> if it is shorter. </P></DD><DT><CODE>drop</CODE> <A name="label308"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>drop&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the list&nbsp;<CODE><I>Xs</I></CODE> with the first <CODE><I>I</I></CODE>&nbsp;elements removed, or to <CODE>nil</CODE> if it is shorter. </P></DD><DT><CODE>takeDrop</CODE> <A name="label310"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>takeDrop&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Ys</I></CODE> to <CODE>{List<SPAN class="keyword">.</SPAN>take&nbsp;</CODE><CODE><I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE><I>I</I></CODE><CODE>}</CODE> and <CODE><I>Zs</I></CODE> to <CODE>{List<SPAN class="keyword">.</SPAN>drop&nbsp;</CODE><CODE><I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE><I>I</I></CODE><CODE>}</CODE>. </P></DD><DT><CODE>last</CODE> <A name="label312"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>last&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the last element of&nbsp;<CODE><I>Xs</I></CODE>. Raises an error exception if <CODE><I>Xs</I></CODE> is <CODE>nil</CODE>. </P></DD><DT><CODE>toTuple</CODE> <A name="label314"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>toTuple&nbsp;</CODE><CODE>+<I>L</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>T</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>T</I></CODE> to a tuple with label&nbsp;<CODE><I>L</I></CODE> that contains the elements of&nbsp;<CODE><I>Xs</I></CODE> as subtrees in the given order. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>toTuple&nbsp;<SPAN class="string">'#'</SPAN>&nbsp;[a&nbsp;b&nbsp;c]}</CODE></BLOCKQUOTE><P> returns <CODE>a<SPAN class="keyword">#</SPAN>b<SPAN class="keyword">#</SPAN>c</CODE>. </P></DD><DT><CODE>toRecord</CODE> <A name="label316"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>toRecord&nbsp;</CODE><CODE>+<I>L</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ts</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>R</I></CODE> to a record with label&nbsp;<CODE><I>L</I></CODE> whose subtrees are given by the property list&nbsp;<CODE><I>Ts</I></CODE>: For every element <CODE>L</CODE><I>i</I><CODE><SPAN class="keyword">#</SPAN>X</CODE><I>i</I> of <CODE><I>Xs</I></CODE>, <CODE><I>R</I></CODE>&nbsp;has a field&nbsp;<CODE>X</CODE><I>i</I> at feature&nbsp;<CODE>L</CODE><I>i</I>. The features in the property list must be pairwise distinct, else an error exception is raised. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>toRecord&nbsp;f&nbsp;[a<SPAN class="keyword">#</SPAN>1&nbsp;b<SPAN class="keyword">#</SPAN>2&nbsp;c<SPAN class="keyword">#</SPAN>3]}</CODE></BLOCKQUOTE><P> returns <CODE>f(a:&nbsp;1&nbsp;b:&nbsp;2&nbsp;c:&nbsp;3)</CODE>. </P></DD><DT><CODE>zip</CODE> <A name="label318"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>zip&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the list of all elements <CODE>Z</CODE><I>i</I> computed by applying <CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;X</CODE><I>i</I><CODE>&nbsp;Y</CODE><I>i</I><CODE>}</CODE>, where <CODE>X</CODE><I>i</I> is the <I>i</I>th element of&nbsp;<CODE><I>Xs</I></CODE> and <CODE>Y</CODE><I>i</I> the <I>i</I>th element of&nbsp;<CODE><I>Ys</I></CODE>. The two input lists must be of equal length, else an error exception is raised. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>zip&nbsp;[1&nbsp;6&nbsp;3]&nbsp;[4&nbsp;5&nbsp;6]&nbsp;Max}</CODE></BLOCKQUOTE><P> returns the list <CODE>[4&nbsp;6&nbsp;6]</CODE>. </P></DD><DT><CODE>isPrefix</CODE> <A name="label320"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>isPrefix&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>Xs</I></CODE> is a prefix of <CODE><I>Ys</I></CODE>. Given that <CODE><I>Xs</I></CODE> has length&nbsp;<I>i</I>, it is a prefix of&nbsp;<CODE><I>Ys</I></CODE> if <CODE><I>Ys</I></CODE> has at least length&nbsp;<I>i</I> and the first <I>i</I> elements of&nbsp;<CODE><I>Ys</I></CODE> are equal to the corresponding elements of&nbsp;<CODE><I>Xs</I></CODE>. </P></DD></DL><P> </P><P> All of the following procedures exist in two versions. The so-called <EM>index</EM> version passes to the procedures an additional index as first actual argument. The index is an integer giving the position of the list element currently processed (counting from&nbsp;<CODE>1</CODE>). </P><DL><DT><A name="label321"></A><SPAN class="index"><CODE>Map</CODE></SPAN> <A name="label322"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>map&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the list obtained by applying&nbsp;<CODE><I>P</I></CODE> to each element of&nbsp;<CODE><I>Xs</I></CODE>. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Map&nbsp;[12&nbsp;13&nbsp;1]&nbsp;IntToFloat}</CODE></BLOCKQUOTE><P> returns <CODE>[12<SPAN class="keyword">.</SPAN>0&nbsp;13<SPAN class="keyword">.</SPAN>0&nbsp;1<SPAN class="keyword">.</SPAN>0]</CODE>. </P></DD><DT><CODE>mapInd</CODE> <A name="label324"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>mapInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>Map</CODE>, but the ternary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the index as first actual argument. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>mapInd&nbsp;[d&nbsp;a&nbsp;e]&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I&nbsp;A}&nbsp;I<SPAN class="keyword">#</SPAN>A&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> yields the list <CODE>[1<SPAN class="keyword">#</SPAN>d&nbsp;2<SPAN class="keyword">#</SPAN>a&nbsp;3<SPAN class="keyword">#</SPAN>e]</CODE> as output. </P></DD><DT><A name="label325"></A><SPAN class="index"><CODE>FoldL</CODE></SPAN> <A name="label326"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldL&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><A name="label327"></A><SPAN class="index"><CODE>FoldR</CODE></SPAN> <A name="label328"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldR&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Used for folding the elements of&nbsp;<CODE><I>Xs</I></CODE> by applying a ternary procedure&nbsp;<CODE><I>P</I></CODE>. </P><P> Application of the left folding procedure <CODE>{FoldL&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE> reduces to </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>X1</I></CODE><CODE>}&nbsp;</CODE><CODE><I>X2</I></CODE><CODE>}&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> The first actual argument of&nbsp;<CODE><I>P</I></CODE> is the accumulator in which the result of the previous application or the start value&nbsp;<CODE><I>Z</I></CODE> is passed. The second actual argument is an element of&nbsp;<CODE><I>Xs</I></CODE>. </P><P> Besides the left folding procedure there exists a right folding variant. The application <CODE>{FoldR&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE> reduces to </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X2</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>}&nbsp;</CODE>...<CODE>}&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> The first actual argument of&nbsp;<CODE><I>P</I></CODE> is an element of&nbsp;<CODE><I>Xs</I></CODE>. The second actual argument of&nbsp;<CODE><I>P</I></CODE> is the accumulator in which the result of the previous application or the start value&nbsp;<CODE><I>Z</I></CODE> is passed. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{FoldL&nbsp;[b&nbsp;c&nbsp;d]&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y}&nbsp;f(X&nbsp;Y)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;a}</CODE></BLOCKQUOTE><P> returns <CODE>f(f(f(a&nbsp;b)&nbsp;c)&nbsp;d)</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{FoldR&nbsp;[b&nbsp;c&nbsp;d]&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y}&nbsp;f(X&nbsp;Y)&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;a}</CODE></BLOCKQUOTE><P> returns <CODE>f(b&nbsp;f(c&nbsp;f(d&nbsp;a)))</CODE>. </P></DD><DT><CODE>foldLInd</CODE> <A name="label330"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldLInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>foldRInd</CODE> <A name="label332"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldRInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>FoldL</CODE> and <CODE>FoldR</CODE>, but the <CODE>4</CODE>-ary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><A name="label333"></A><SPAN class="index"><CODE>FoldLTail</CODE></SPAN> <A name="label334"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldLTail&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><A name="label335"></A><SPAN class="index"><CODE>FoldRTail</CODE></SPAN> <A name="label336"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldRTail&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Used for folding all non-<CODE>nil</CODE> tails of&nbsp;<CODE><I>Xs</I></CODE> by applying a ternary procedure&nbsp;<CODE><I>P</I></CODE>, i.&nbsp;e., application of the left folding procedure </P><BLOCKQUOTE class="code"><CODE>{FoldLTail&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> reduces to </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]}&nbsp;[</CODE><CODE><I>X2</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]}&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> The right folding procedure is analogous. </P></DD><DT><CODE>foldLTailInd</CODE> <A name="label338"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldLTailInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>foldRTailInd</CODE> <A name="label340"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>foldRTailInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>FoldLTail</CODE> and <CODE>FoldRTail</CODE>, but the <CODE>4</CODE>-ary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><A name="label341"></A><SPAN class="index"><CODE>ForAll</CODE></SPAN> <A name="label342"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>forAll&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>PO</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>applies the unary procedure or object&nbsp;<CODE><I>PO</I></CODE> to each element of&nbsp;<CODE><I>Xs</I></CODE>, i.&nbsp;e., the application </P><BLOCKQUOTE class="code"><CODE>{ForAll&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>P</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> reduces to the sequence of statements </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X1</I></CODE><CODE>}&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{ForAll&nbsp;[O1&nbsp;O2&nbsp;O3]&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;O}&nbsp;{O&nbsp;<SPAN class="keyword">do</SPAN>()}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> sends the message <CODE><SPAN class="keyword">do</SPAN>()</CODE> to the objects <CODE>O1</CODE>, <CODE>O2</CODE>, and&nbsp;<CODE>O3</CODE>. </P></DD><DT><CODE>forAllInd</CODE> <A name="label344"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>forAllInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>ForAll</CODE>, but the binary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P><P> For example, assuming <CODE>O1</CODE>, <CODE>O2</CODE>, and&nbsp;<CODE>O3</CODE> are objects, the following statement sends the message <CODE><SPAN class="keyword">do</SPAN>(1)</CODE> to the object&nbsp;<CODE>O1</CODE>, the message <CODE><SPAN class="keyword">do</SPAN>(2)</CODE> to&nbsp;<CODE>O2</CODE>, and the message <CODE><SPAN class="keyword">do</SPAN>(3)</CODE> to&nbsp;<CODE>O3</CODE>: </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>forAllInd&nbsp;[O1&nbsp;O2&nbsp;O3]<BR>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I&nbsp;O}&nbsp;{O&nbsp;<SPAN class="keyword">do</SPAN>(I)}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> </P></DD><DT><A name="label345"></A><SPAN class="index"><CODE>ForAllTail</CODE></SPAN> <A name="label346"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>forAllTail&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>PO</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>applies the unary procedure or object&nbsp;<CODE><I>PO</I></CODE> to each non-<CODE>nil</CODE> tail of&nbsp;<CODE><I>Xs</I></CODE>, i.&nbsp;e., the application </P><BLOCKQUOTE class="code"><CODE>{ForAllTail&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]&nbsp;</CODE><CODE><I>P</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> reduces to the sequence of statements </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;[</CODE><CODE><I>X1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]}&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;[</CODE><CODE><I>X2</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Xn</I></CODE><CODE>]}&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;[</CODE><CODE><I>Xn</I></CODE><CODE>]}</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>forAllTailInd</CODE> <A name="label348"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>forAllTailInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>ForAllTail</CODE>, but the binary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><A name="label349"></A><SPAN class="index"><CODE>All</CODE></SPAN> <A name="label350"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>all&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><A name="label351"></A><SPAN class="index"><CODE>Some</CODE></SPAN> <A name="label352"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>some&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether the unary boolean function&nbsp;<CODE><I>P</I></CODE> yields <CODE><SPAN class="keyword">true</SPAN></CODE> when applied to all elements resp. some element of&nbsp;<CODE><I>Xs</I></CODE>. Stops at the first element for which <CODE><I>P</I></CODE> yields <CODE><SPAN class="keyword">false</SPAN></CODE> resp. <CODE><SPAN class="keyword">true</SPAN></CODE>. </P></DD><DT><CODE>allInd</CODE> <A name="label354"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>allInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>someInd</CODE> <A name="label356"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>someInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>All</CODE> and <CODE>Some</CODE>, but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><A name="label357"></A><SPAN class="index"><CODE>Filter</CODE></SPAN> <A name="label358"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>filter&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>partition</CODE> <A name="label360"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>partition&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>Filter</CODE> returns a list of the elements of&nbsp;<CODE><I>Xs</I></CODE> for which the application of the unary boolean function&nbsp;<CODE><I>P</I></CODE> yields <CODE><SPAN class="keyword">true</SPAN></CODE>, where the ordering is preserved. <CODE>List<SPAN class="keyword">.</SPAN>partition</CODE> works similarly, but additionally returns in <CODE><I>Zs</I></CODE> a list of all remaining elements of&nbsp;<CODE><I>Xs</I></CODE>, where the ordering is preserved as well. </P><P> For example, the application </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>partition&nbsp;[1&nbsp;4&nbsp;2&nbsp;3&nbsp;6&nbsp;5]&nbsp;IsOdd&nbsp;Ys&nbsp;Zs}</CODE></BLOCKQUOTE><P> returns <CODE>[1&nbsp;3&nbsp;5]</CODE> in <CODE>Ys</CODE> and <CODE>[4&nbsp;2&nbsp;6]</CODE> in <CODE>Zs</CODE>. </P></DD><DT><CODE>filterInd</CODE> <A name="label362"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>filterInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>partitionInd</CODE> <A name="label364"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>partitionInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>Filter</CODE> and <CODE>List<SPAN class="keyword">.</SPAN>partition</CODE>, but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><CODE>takeWhile</CODE> <A name="label366"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>takeWhile&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>dropWhile</CODE> <A name="label368"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>dropWhile&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>takeDropWhile</CODE> <A name="label370"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>takeDropWhile&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>While <CODE>Filter</CODE> selects all elements of a list which satisfy a certain condition, the procedure <CODE>List<SPAN class="keyword">.</SPAN>takeWhile</CODE> selects only the starting sequence of elements which fulfill this condition. The procedure <CODE>List<SPAN class="keyword">.</SPAN>dropWhile</CODE> is dual: It returns the remainder of the list. For convenience, <CODE>List<SPAN class="keyword">.</SPAN>takeDropWhile</CODE> combines the functionality from both <CODE>List<SPAN class="keyword">.</SPAN>takeWhile</CODE> and <CODE>List<SPAN class="keyword">.</SPAN>dropWhile</CODE>. </P><P> For example, the application </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>takeWhile&nbsp;[1&nbsp;4&nbsp;2&nbsp;3&nbsp;6&nbsp;5]&nbsp;IsOdd&nbsp;Ys}</CODE></BLOCKQUOTE><P> returns <CODE>[1]</CODE> in&nbsp;<CODE>Ys</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>dropWhile&nbsp;[1&nbsp;4&nbsp;2&nbsp;3&nbsp;6&nbsp;5]&nbsp;IsOdd&nbsp;Zs}</CODE></BLOCKQUOTE><P> returns <CODE>[4&nbsp;2&nbsp;3&nbsp;6&nbsp;5]</CODE> in&nbsp;<CODE>Ys</CODE>. </P><BLOCKQUOTE class="code"><CODE>{List<SPAN class="keyword">.</SPAN>takeDropWhile&nbsp;[1&nbsp;4&nbsp;2&nbsp;3&nbsp;6&nbsp;5]&nbsp;IsOdd&nbsp;Ys&nbsp;Zs}</CODE></BLOCKQUOTE><P> combines both. </P></DD><DT><CODE>takeWhileInd</CODE> <A name="label372"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>takeWhileInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>dropWhileInd</CODE> <A name="label374"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>dropWhileInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>takeDropWhileInd</CODE> <A name="label376"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{List<SPAN class="keyword">.</SPAN>takeDropWhileInd&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Zs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>List<SPAN class="keyword">.</SPAN>takeWhile</CODE>, <CODE>List<SPAN class="keyword">.</SPAN>dropWhile</CODE> and <CODE>List<SPAN class="keyword">.</SPAN>takeDropWhile</CODE> but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="tuple.html#section.records.tuples">&lt;&lt; Prev</A></TD><TD><A href="node8.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
