<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Distribution Model</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.examples">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.distmodel"><H1><A name="chapter.distmodel">2 Distribution Model</A></H1><P>The basic difference between a distributed and a centralized program is that the former is partitioned among several sites. <A name="label14"></A> <A name="label15"></A> We define a <EM>site</EM> as the basic unit of geographic distribution. In the current implementation, a site is always one <A name="label16"></A> operating system process on one machine. <A name="label17"></A> <A name="label18"></A> A multitasking system can host several sites. An Oz language entity has the same <A name="label19"></A> <A name="label20"></A> <A name="label21"></A> language semantics whether it is used on only one site or on several sites. We say that Mozart is <A name="label22"></A> <EM>network-transparent</EM>. If used on several sites, the language entity is implemented using a distributed protocol. This gives the language entity a particular distributed semantics in terms of network messages. </P><P>The <EM>distributed semantics</EM> <A name="label23"></A> <A name="label24"></A> defines the network communications done by the system when operations are performed on an entity. The distributed semantics of the entities depends on their type. The distribution model gives well-defined distributed semantics to all Oz language entities. </P><P>The distributed semantics has been carefully designed to give the programmer full control over network communication patterns where it matters. The distributed semantics does the right thing by default in almost all cases. For example, procedure code is transferred to sites immediately, so that sites never need ask for procedure code. For objects, the developer can specify the desired distributed semantics, e.g., mobile (cached) objects, stationary objects, and stationary single-threaded objects. <A href="node2.html#language.entities">Section&nbsp;2.1</A> defines the distributed semantics for each type of language entity, <A href="node2.html#sites">Section&nbsp;2.2</A> explains more about what happens at sites, and <A href="node2.html#bringing">Section&nbsp;2.3</A> outlines how to build distributed applications. </P><DIV id="language.entities"><H2><A name="language.entities">2.1 Language entities</A></H2><H3><A name="label25">2.1.1 Objects</A></H3><P>The most critical entities in terms of network efficiency are the objects. Objects have a state that has to be updated in a globally-consistent way. The efficiency of this operation depends on the object's distributed semantics. Many distributed semantics are possible, providing a range of trade-offs for the developer. Here are some of the more useful ones: </P><UL><LI><P><EM>Cached object</EM>: <A name="label26"></A> <A name="label27"></A> <A name="label28"></A> <A name="label29"></A> Objects and cells are cached by default--we also call this &quot;mobile objects&quot;. Objects are always executed locally, in the thread that invokes the method. This means that a site attempting to execute a method will first fetch the object, which requires up to three network messages. After this, no further messages are needed as long as the object stays on the site. The object will not move as long as execution stays within a method. If many sites use the object, then it will travel among the sites, giving everyone a fair share of the object use. </P><P>The site where the object is created is called its <A name="label30"></A> <A name="label31"></A> <EM>owner site</EM>. A reference to an object on its owner site is called an <EM>owner</EM> or <EM>owner node</EM>. All other sites referencing the object are <A name="label32"></A> <A name="label33"></A> <EM>proxy sites</EM>. A remote reference to an object is called a <EM>proxy</EM> or a <EM>proxy node</EM>. A site requesting the object first sends a message to the owner site. The owner site then sends a forwarding request to the site currently hosting the object. This hosting site then sends the object's state pointer to the requesting site. </P><P>The class of a cached object is copied to each site that calls the object. <A name="label34"></A> This is done lazily, i.e., the class is only copied when the object is called for the first time. Once the class is on the site, no further copies are done. </P></LI><LI><P><EM>Stationary object (server)</EM>: <A name="label35"></A> <A name="label36"></A> A stationary object remains on the site at which it was created. Each method invocation uses one message to start the method and one message to synchronize with the caller when the method is finished. <A name="label37"></A> <A name="label38"></A> Exceptions are raised in the caller's thread. Each method executes in a new thread created for it on the object's site. This is reasonable since threads in Mozart are extremely lightweight (millions can be created on one machine). </P></LI><LI><P><EM>Sequential asynchronous stationary object</EM>: <A name="label39"></A> In this object, each method invocation uses one message only and does not wait until the method is finished. All method invocations execute in the same thread, so the object is executed in a completely sequential way. Non-caught exceptions in a method are ignored by the caller.</P></LI></UL><P></P><P>Deciding between these three behaviors is done when the object is created from its class. A cached object is created with <CODE>New</CODE>, a stationary object is created with <CODE>NewStat</CODE>, and an sequential asynchronous stationary object is created with <CODE>NewSASO</CODE>. A stationary object is a good abstraction to build servers (see <A href="node3.html#making.stationary.objects">Section&nbsp;3.2.3</A>) and fault-tolerant servers. It is easy to program other distribution semantics in Oz. <A href="node3.html#chapter.examples">Chapter&nbsp;3</A> gives some examples. </P><H3><A name="label40">2.1.2 Other stateful entities</A></H3><P>The other stateful language entities have the following distributed semantics: </P><UL><LI><P><EM>Thread</EM>: <A name="label41"></A> A thread actively executes a sequence of instructions. The thread is stationary on the site it is created. Threads communicate through shared data and block when the data is unavailable, i.e., when trying to access unbound logic variables. <A name="label42"></A> This makes Oz a data-flow language. Threads are <EM>sited</EM> entities (see <A href="node2.html#sited.entities">Section&nbsp;2.1.5</A>). </P></LI><LI><P><EM>Port</EM>: <A name="label43"></A> <A name="label44"></A> <A name="label45"></A> A port is an asynchronous many-to-one channel that respects FIFO for messages sent from within the same thread. A port is stationary on the site it is created, which is called its <EM>owner site</EM>. The messages are appended to a stream on the port's site. Messages from the same thread appear in the stream in the same order in which they were sent in the thread. A port's stream is terminated by a <EM>future</EM> (see <A href="node2.html#single.assignment">Section&nbsp;2.1.3</A>). </P><P>Sending to a local port is always asynchronous. Sending to a remote port is asynchronous except if all available memory in the network layer is in use. In that case, the send blocks. The network layer frees memory after sending data across the network. When enough memory is freed, the send is continued. This provides an end-to-end flow control. </P><P>Oz ports, which are a language concept, should not be confused with <A name="label46"></A> <A name="label47"></A> Unix ports, which are an OS concept. Mozart applications do not need to use Unix ports explicitly except to communicate with applications that have a Unix port interface. </P></LI><LI><P><EM>Cell</EM>: A cell is an updatable pointer to any other entity, i.e., it is analogous to a standard updatable variable in imperative languages such as C and Java. <A name="label48"></A> <A name="label49"></A> <A name="label50"></A> Cells have the same distributed semantics as cached objects. Updating the pointer may need up to three network messages, but once the cell is local, then further updates do not use the network any more. </P></LI><LI><P><EM>Thread-reentrant lock</EM>: <A name="label51"></A> <A name="label52"></A> <A name="label53"></A> A thread-reentrant lock allows only a single thread to enter a given program region. Locks can be created dynamically and nested recursively. Locks have the same distributed semantics as cached objects and cells. This implements a standard distributed mutual exclusion algorithm.</P></LI></UL><P> </P><DIV id="single.assignment"><H3><A name="single.assignment">2.1.3 Single-assignment entities</A></H3><P>An important category of language entities are those that can be assigned only to one value: </P><UL><LI><P><EM>Logic variable</EM>: <A name="label54"></A> <A name="label55"></A> Logic variables have two operations: they can be bound (i.e., assigned) or read (i.e., wait until bound). A logic variable resembles a single-assignment variable, <A name="label56"></A> e.g., a <CODE>final</CODE> variable in Java. It is more than that because two logic variables can be bound together even before they are assigned, and because a variable can be assigned more than once, if always to the same value. Logic variables are important for three reasons: </P><UL><LI><P>They have a more efficient protocol than cells. Often, variables are used as placeholders, that is, they will be assigned only once. It would be highly inefficient in a distributed system to create a cell for that case.</P><P>When a logic variable is bound, the value is sent to its <EM>owner site</EM>, namely the site on which it was created. The owner site then <A name="label57"></A> multicasts the value to all the proxy sites, namely the sites that have the variable. The current release implements the multicast as a sequence of message sends. That is, if the variable is on <EM>n</EM> sites, then a maximum of <EM>n</EM>+1 messages are needed to bind the variable. When a variable arrives on a site for the first time, it is immediately registered with the owner site. This takes one message.</P></LI><LI><P>They can be used to improve <A name="label58"></A> latency tolerance. A logic variable can be passed in a message or stored in a data structure before it is assigned a value. When the value is there, then it is sent to all sites that need it.</P></LI><LI><P>They are the basic mechanism for synchronization and communication in concurrent execution. Data-flow execution in Oz is implemented with logic variables. Oz does not need an explicit monitor or signal concept--rather, logic variables let threads wait until data is available, <A name="label59"></A> <A name="label60"></A> which is 90% of the needs of concurrency. A further 9% is provided by reentrant locking, which is implemented by logic variables and cells. The remaining 1% are not so simply handled by these two cases and must be programmed explicitly. The reader is advised not to take the above numbers too seriously.</P></LI></UL><P> </P></LI><LI><P><EM>Future</EM>: <A name="label61"></A> <A name="label62"></A> A future is a read-only logic variable, i.e., it can only be <EM>read</EM>, not bound. Attempting to bind a future will block. A future can be created explicitly from a logic variable. Futures are useful to protect logic variables from being bound by unauthorized sites. Futures are also used to distribute constrained variables (see <A href="node2.html#sited.entities">Section&nbsp;2.1.5</A>). </P></LI><LI><P><EM>Stream</EM>: <A name="label63"></A> A stream is an asynchronous one-to-many communication channel. In fact, a stream is just a list whose last element is a logic variable or a future. If the stream is bound on the owner site, then the binding is sent asynchronously to all sites that have the variable. Bindings from the same thread appear in the stream in the same order that they occur in the thread. </P><P>A port together with a stream efficiently implement an asynchronous many-to-many channel that respects the order of messages sent from the same thread. No order is enforced between messages from different threads. </P></LI></UL><P> </P></DIV><DIV id="stateless.entities"><H3><A name="stateless.entities">2.1.4 Stateless entities</A></H3><P>Stateless entities never change, i.e., they do not have any internal state whatsoever. Their distributed semantics is very efficient: they are copied across the net in a single message. The different kinds of stateless entities differ in when the copy is done (eager or lazy) and in how many copies of the entity can exist on a site: </P><UL><LI><P><EM>Records and numbers</EM>: <A name="label64"></A> <A name="label65"></A> <A name="label66"></A> <A name="label67"></A> <A name="label68"></A> <A name="label69"></A> <A name="label70"></A> <A name="label71"></A> This includes lists and strings, which are just particular kinds of records. Records and numbers are copied eagerly across the network, in the message that references them. The same record and number may occur many times on a site, once per copy (remember that integers in Mozart may have any number of digits). Since these entities are so very basic and primitive, it would be highly inefficient to manage remote references to them and to ensure that they exist only once on a site. Of course, records and lists may refer to any other kind of entity, and the distributed semantics of that entity depends on its type, not on the fact of its being inside a record or a list. </P></LI><LI><P><EM>Procedures, functions, classes, functors, chunks, atoms, and names</EM>: <A name="label72"></A> <A name="label73"></A> <A name="label74"></A> <A name="label75"></A> <A name="label76"></A> <A name="label77"></A> <A name="label78"></A> <A name="label79"></A> <A name="label80"></A> <A name="label81"></A> <A name="label82"></A> <A name="label83"></A> <A name="label84"></A> <A name="label85"></A> These entities are copied eagerly across the network, but can only exist once on a given site. For example, an object's class contains the code of all the object's methods. If many objects of a given class exist on a site, then the class only exists there once. </P><P>Each instance of all the above (except atoms) is globally unique. For example, if the same source-code definition of a procedure is run more than once, then it will create a different procedure each time around. This is part of the Oz language semantics; one way to think of it is that a new Oz name is created for every procedure instance. This is true for functions, classes, functors, chunks, and of course for names too. It is not true for atoms; two atoms with the same print name are identical, even if created separately. </P></LI><LI><P><EM>Object-records</EM>: <A name="label86"></A> <A name="label87"></A> <A name="label88"></A> <A name="label89"></A> An object is a composite entity consisting of an object-record that references the object's features, a cell, and an internal class. The distribution semantics of the object's internal class are different from that of a class that is referenced explicitly independent of any object. An object-record and an internal class are both chunks that are copied lazily. I.e., if an object is passed to a site, then when the object is called there, the object-record is requested if it is missing and the class is requested if it is missing. If the internal class already exists on the site, then it is not requested at all. On the other hand, a class that referenced explicitly is passed eagerly, i.e., a message referencing the class will contain the class code, even if the site already has a copy. </P></LI></UL><P></P><P>In terms of the language semantics, there are only two different stateless language entities: procedures and records. All other entities are derived. Functions are syntactic sugar for procedures. Chunks are a particular kind of record. Classes are chunks that contain object methods, which are themselves procedures. Functors are chunks that contain a function taking modules as arguments and returning a module, where a module is a record. </P></DIV><DIV id="sited.entities"><H3><A name="sited.entities">2.1.5 Sited entities</A></H3><P>Entities that can be used only on one site are called <EM>sited</EM>. <A name="label90"></A> <A name="label91"></A> <A name="label92"></A> <A name="label93"></A> We call this site their <EM>owner site</EM> or <EM>home site</EM>. References to these entities can be passed to other sites, but they do not work there (an exception will be raised if an operation is attempted). They work only on their owner site. Entities that can be used on any site <A name="label94"></A> <A name="label95"></A> are called <EM>unsited</EM>. Because of network transparency, unsited entities have the same language semantics independent of where they are used. </P><P>In Mozart, all sited entities are modules, except for a few exceptional cases listed below. Not all modules are sited, though. <A name="label96"></A> <A name="label97"></A> <A name="label98"></A> A <EM>module</EM> is a record that groups related operations and that possibly has some internal state. The modules that are available in a Mozart <A name="label99"></A> <A name="label100"></A> process when it starts up are called <EM>base modules</EM>. The base modules contain all operations on all basic Oz types. <A name="label101"></A> <A name="label102"></A> There are additional modules, called <EM>system modules</EM>, that are part of the system but loaded only when needed. Furthermore, an application can define more modules by means of functors that are imported from other modules. A <EM>functor</EM> is a module specification that makes explicit the resources needed by the module. </P><P>All base modules are unsited. For example, a procedure that does additions can be used on another site, since the addition operation is <A name="label103"></A> <A name="label104"></A> <A name="label105"></A> <A name="label106"></A> <A name="label107"></A> <A name="label108"></A> <A name="label109"></A> <A name="label110"></A> <A name="label111"></A> part of the base module <CODE>Number</CODE>. Some commonly-used base modules are <CODE>Number</CODE>, <CODE>Int</CODE>, and <CODE>Float</CODE> (operations on numbers), <CODE>Record</CODE> and <CODE>List</CODE> (operations on records and lists), and <CODE>Procedure</CODE>, <CODE>Port</CODE>, <CODE>Cell</CODE>, and <CODE>Lock</CODE> (operations on common entities). </P><P>Due to limitations of the current release, <A name="label112"></A> <A name="label113"></A> <A name="label114"></A> <A name="label115"></A> <A name="label116"></A> <A name="label117"></A> <A name="label118"></A> <A name="label119"></A> <A name="label120"></A> threads, weak dictionaries, and spaces are sited even though they are in base modules. </P><P>When a reference to a constrained variable <A name="label121"></A> <A name="label122"></A> <A name="label123"></A> <A name="label124"></A> <A name="label125"></A> <A name="label126"></A> <A name="label127"></A> <A name="label128"></A> (finite domain, finite set, or free record) is passed to another site, then this reference <A name="label129"></A> <A name="label130"></A> is converted to a <EM>future</EM> (see <A href="node2.html#single.assignment">Section&nbsp;2.1.3</A>). The future will be bound when the constrained variable becomes determined. <A name="label131"></A> <A name="label132"></A></P><P>We call <EM>resource</EM> any module that is either a system module or that imports directly or indirectly from a system module. All resources are sited. The reason is that they contain state outside of the Oz language. This state is either part of the emulator or external to the Mozart process. Access to this state is limited to the machine hosting the Mozart process. Some commonly-used system modules are <A name="label133"></A> <A name="label134"></A> <A name="label135"></A> <A name="label136"></A> <A name="label137"></A> <A name="label138"></A> <A name="label139"></A> <A name="label140"></A> <A name="label141"></A> <A name="label142"></A> <A name="label143"></A> <A name="label144"></A> <CODE>Tk</CODE> and <CODE>Browser</CODE> (system graphics), <CODE>Connection</CODE> and <CODE>Remote</CODE> (site-specific distributed operations), <CODE>Application</CODE> and <CODE>Module</CODE> (standalone applications and dynamic linking), <CODE>Search</CODE> and <CODE>FD</CODE> (constraint programming), <CODE>Open</CODE> and <CODE>Pickle</CODE> (the file system), <CODE>OS</CODE> and <CODE>Property</CODE> (the OS and emulator), and so forth. </P></DIV></DIV><DIV id="sites"><H2><A name="sites">2.2 Sites</A></H2><DIV id="section.distmodel.shutdown"><H3><A name="section.distmodel.shutdown">2.2.1 Controlled system shutdown</A></H3><P>A site can be stopped in two ways: normally or abnormally. <A name="label145"></A> <A name="label146"></A> The normal way is a controlled shutdown initiated by <CODE>{Application<SPAN class="keyword">.</SPAN>exit&nbsp;I}</CODE>, where <CODE>I</CODE> is the return status (see the module <CODE>Application</CODE>). <A name="label147"></A> <A name="label148"></A> The abnormal way is a site crash triggered by an external problem. The failure model (see <A href="node4.html#chapter.failure">Chapter&nbsp;4</A>) is used to survive site crashes. Here we explain what a controlled shutdown means in the distribution model. </P><P>All language entities, except for stateless entities that are copied immediately, have an owner site and proxy sites. The owner site is always the site on which the entity was created. A controlled shutdown has no adverse effect on any distributed entity whose owner is on another site. This is enforced by the distributed protocols. For example, if a cell's state pointer is on the shutting-down site, then the state pointer is moved to the owner site before shutting down. If the owner node is on the shutting-down site, then that entity will no longer work. </P></DIV><H3><A name="label149">2.2.2 Distributed memory management</A></H3><P>All memory management in Mozart is automatic; the programmer does not have to worry about when an entity is no longer referenced. <A name="label150"></A> <A name="label151"></A> Mozart implements an efficient distributed garbage collection algorithm that reclaims all unused entities except those that form a <A name="label152"></A> <A name="label153"></A> cycle of references that exists on at least two different owner sites. For example, if two sites each own an object that references the other, then they will not be reclaimed. If the objects are both owned by the same site, then they will be reclaimed. </P><P>This means that the programmer must be somewhat careful when an application references an entity on another site. For example, let's say a client references a server and vice versa. If the client wishes to disconnect from the server, then it is sufficient that the server forget all references to the client. This will ensure there are no cross-site cycles. </P></DIV><DIV id="bringing"><H2><A name="bringing">2.3 Bringing it all together</A></H2><A name="label154"></A><A name="label155"></A><P>Does the Mozart distribution model give programmers a warm, fuzzy feeling when writing distributed applications? In short, yes it does. The distribution model has been designed in tandem with many application prototypes and numerous Gedankenexperimenten. We are confident that it is basically correct. </P><P>Developing an application is separated into two independent parts. First, the application is written without explicitly partitioning the computation among sites. One can in fact check the correctness and termination properties of the application by running it on one site. </P><P>Second, the objects are given distributed semantics to satisfy the geographic constraints (placement of resources, dependencies between sites) and the performance constraints (network bandwidth and latency, machine memory and speed). The large-scale structure of an application consists of a graph of threads and objects, which access resources. Threads are created initially and during execution to ensure that each site does the desired part of the execution. Objects exchange messages, which may refer to objects or other entities. Records and procedures, both stateless entities, are the basic data structures of the application--they are passed between sites when needed. Logic variables and locks are used to manage concurrency and data-flow execution. See <A href="node3.html#practical.tips">Section&nbsp;3.3</A> for more information on how to organize an application. </P><P>Functors and resources are the key players <A name="label156"></A> <A name="label157"></A> in distributed component-based programming. A functor specifies a software component. A functor is stateless, so it can be transparently copied anywhere across the net and made persistent by pickling on a file (see the module <A href="../system/node57.html#chapter.pickle"><CODE>Pickle</CODE></A>). A functor is linked on a site by evaluating it there with the site resources that it needs (see the modules <A href="../system/node7.html#chapter.module"><CODE>Module</CODE></A> and <A href="../system/node48.html#chapter.remote"><CODE>Remote</CODE></A>). The result is a new resource, which can be used as is or to link more functors. Our goal is for functors to be the core technology driving an open community of developers, who contribute to a growing global pool of useful components. </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.examples">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A>, <A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A>, <A href="http://www.sics.se/~perbrand">Per&nbsp;Brand</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~raph">Raphael&nbsp;Collet</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
