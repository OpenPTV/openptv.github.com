<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>C Syntax Tree Format</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#appendix.narrator">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#appendix.bytecode">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="appendix.syntax"><H1><A name="appendix.syntax">C Syntax Tree Format</A></H1><P> This appendix documents the syntax tree data structure used by the compiler. This information is only needed by implementors of custom front-ends. Most nodes are self-explanatory; if in doubt, it is recommended that you refer to the Gump sample implementing an Oz parser (installed at <CODE>examples/gump/OzParser.ozg</CODE>). </P><DIV class="apropos"><P class="margin">Input</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>input</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>parseError</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>[</CODE>&lt;<I>compilation unit</I>&gt;<CODE>]</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Compilation Units</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>compilation unit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>directive</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDeclare(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>directive</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>dirSwitch([</CODE>&lt;<I>switch</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>dirPushSwitches</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>dirPopSwitches</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>dirLocalSwitches</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>switch</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>on(</CODE>&lt;<I>switch name</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>off(</CODE>&lt;<I>switch name</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>switch name</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><H2><A name="label31">C.1 The Base Language</A></H2><DIV class="apropos"><P class="margin">Phrases</P><P> At the syntactical level, statements are not distinguished from expressions. Both are subsumed by &lt;<I>phrase</I>&gt;. In a top-down analysis of the tree, it can be determined which phrases need to be statements and which need to be expressions. The <CODE>fStepPoint</CODE> form is only required if you want to provide support for source-level debugging: It wraps the contained phrase into a step point (see <A href="../ozcar/index.html">``The Mozart Debugger''</A>); the atom can be freely chosen to indicate its kind (<CODE>call</CODE>, <CODE>conditional</CODE>, etc.). </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>phrase</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fStepPoint(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fAnd(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fEq(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fAssign(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOrElse(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fAndThen(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOpApply(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOpApplyStatement(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDotAssign(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fObjApply(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fAt(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>escapable variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>wildcard</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSelf(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDollar(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>int literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFloat(</CODE>&lt;<I>float</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fRecord(</CODE>&lt;<I>label</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>record argument</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOpenRecord(</CODE>&lt;<I>label</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>record argument</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fApply(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fProc(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>proc flag</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFun(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>proc flag</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFunctor(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>functor descriptor</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fClass(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>class descriptor</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>meth</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fLocal(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fBoolCase(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>opt else</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fCase(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>case clause</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>opt else</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFOR([</CODE>&lt;<I>for decl</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fLockThen(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fLock(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fThread(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fTry(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>catch</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>finally</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fRaise(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSkip(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>atom literal</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fAtom(</CODE>&lt;<I>literal</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>variable</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fVar(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>escapable variable</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fEscape(</CODE>&lt;<I>variable</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>wildcard</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fWildcard(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>int literal</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fInt(</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>record argument</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fColon(</CODE>&lt;<I>feature</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P>Procedures can carry flags (atoms following the <CODE><SPAN class="keyword">proc</SPAN></CODE> or <CODE><SPAN class="keyword">fun</SPAN></CODE> keyword). For the moment, the only recognized flags are <CODE>instantiate</CODE> (the body's code is copied upon application), <CODE>lazy</CODE> (the body has by-need semantics), <CODE>dynamic</CODE> (disable static-call optimization of this procedure), and <CODE>sited</CODE> (cannot be pickled). Other atoms are silently ignored. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>proc flag</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Functors</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>functor descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fRequire([</CODE>&lt;<I>import decl</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fPrepare(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fImport([</CODE>&lt;<I>import decl</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fExport([</CODE>&lt;<I>export decl</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDefine(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>import decl</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fImportItem(</CODE>&lt;<I>variable</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>aliased feature</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>opt import at</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>aliased feature</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>feature no var</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>feature no var</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>opt import at</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoImportAt</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fImportAt(</CODE>&lt;<I>atom literal</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>export decl</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fExportItem(</CODE>&lt;<I>export item</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>export item</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fColon(</CODE>&lt;<I>feature no var</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>variable</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Classes</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>class descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fFrom([</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fProp([</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fAttr([</CODE>&lt;<I>attr or feat</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFeat([</CODE>&lt;<I>attr or feat</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>attr or feat</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>escaped feature</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>escaped feature</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>phrase</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>meth</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fMeth(</CODE>&lt;<I>meth head</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>meth head</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>meth head 1</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fEq(</CODE>&lt;<I>meth head 1</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>variable</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>meth head 1</I>&gt;&nbsp;::=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>escapable variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fRecord(</CODE>&lt;<I>meth head label</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>meth argument</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOpenRecord(</CODE>&lt;<I>meth head label</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>meth argument</I>&gt;<CODE>])</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>meth head label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>escapable variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>meth argument</I>&gt;&nbsp;::=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD><CODE>fMethArg(</CODE>&lt;<I>meth arg term</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>default</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fMethColonArg(</CODE>&lt;<I>feature</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>meth arg term</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>default</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>meth arg term</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>wildcard</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDollar(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>default</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoDefault</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDefault(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Features</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>feature no var</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>int literal</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>feature</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>feature no var</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>escaped feature</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>feature no var</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>escapable variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Other</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>case clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fCaseClause(</CODE>&lt;<I>pattern</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>pattern</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSideCondition(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>catch</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoCatch</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fCatch([</CODE>&lt;<I>case clause</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>finally</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoFinally</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>opt else</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoElse(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>for decl</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>forFeature(</CODE>&lt;<I>atom literal</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>forPattern(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>for gen</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>for gen</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>forGeneratorList(</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>forGeneratorInt(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>opt phrase</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>forGeneratorC(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>opt phrase</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>opt phrase</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>phrase</I>&gt; </TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Coordinates</P><P> Each triple consisting of an &lt;<I>atom</I>&gt; and two &lt;<I>int</I>&gt;s denotes a file name (<CODE><SPAN class="string">''</SPAN></CODE> if none known), a line number (starting at&nbsp;<CODE>1</CODE>; required) and a column number (starting at&nbsp;<CODE>0</CODE>; <CODE><SPAN class="keyword">~</SPAN>1</CODE> if none known). If two triples are given, then they denote the starting and ending coordinates of a construct. A <CODE>pos</CODE> may be turned into a <CODE>fineStep</CODE> or a <CODE>coarseStep</CODE>, denoting a step point for debugging. <CODE><SPAN class="keyword">unit</SPAN></CODE> is an unknown coordinate. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>coord</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>pos(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>pos(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fineStep(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fineStep(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>coarseStep(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>coarseStep(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>int</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><H2><A name="label32">C.2 Finite Domain Extensions and Combinators</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>phrase</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD>&lt;<I>fd expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFail(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fNot(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fCond([</CODE>&lt;<I>clause</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>opt else</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fOr([</CODE>&lt;<I>clause opt then</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDis([</CODE>&lt;<I>clause opt then</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fChoice([</CODE>&lt;<I>phrase</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>fd expression</I>&gt;&nbsp;::=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD><CODE>fFdCompare(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fFdIn(</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fClause(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>clause opt then</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fClause(</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>opt then</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>opt then</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fNoThen(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>phrase</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><H2><A name="label33">C.3 Gump Extensions</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>compilation unit</I>&gt;&nbsp;+=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD><CODE>fSynTopLevelProductionTemplates([</CODE>&lt;<I>prod clause</I>&gt;<CODE>])</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>phrase</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE>fScanner(</CODE>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>class descriptor</I>&gt;<CODE>]&nbsp;[</CODE>&lt;<I>meth</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>scanner rule</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>atom</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fParser(</CODE>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>class descriptor</I>&gt;<CODE>]&nbsp;[</CODE>&lt;<I>meth</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>token clause</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>parser descriptor</I>&gt;<CODE>]&nbsp;</CODE>&lt;<I>int</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>grammar symbol</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><DIV class="apropos"><P class="margin">Scanners</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>scanner rule</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fMode(</CODE>&lt;<I>variable</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>mode descriptor</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>lex clause</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>mode descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fInheritedModes([</CODE>&lt;<I>variable</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>lex clause</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>lex clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fLexicalAbbreviation(</CODE>&lt;<I>grammar symbol</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>regex</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fLexicalRule(</CODE>&lt;<I>regex</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>regex</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>string</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Parsers</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>token clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fToken([</CODE>&lt;<I>token decl</I>&gt;<CODE>])</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>token decl</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>atom literal</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>phrase</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>parser descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>prod clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>syntax rule</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>prod clause</I>&gt;&nbsp;::=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD><CODE>fProductionTemplate(</CODE>&lt;<I>prod key</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>prod param</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>syntax rule</I>&gt;<CODE>]&nbsp;[</CODE>&lt;<I>syn expression</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[</CODE>&lt;<I>prod ret</I>&gt;<CODE>])</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>prod param</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>wildcard</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>prod key</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>none<SPAN class="keyword">#</SPAN></CODE>&lt;<I>string</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>atom</I>&gt;<CODE><SPAN class="keyword">#</SPAN></CODE>&lt;<I>string</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>prod ret</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>none</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDollar(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>syntax rule</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>fSyntaxRule(</CODE>&lt;<I>grammar symbol</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>syn formal</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>syn expression</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>syn formal</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>wildcard</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fDollar(</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0" class="compact"><TR valign="top"><TD colspan="3">&lt;<I>syn expression</I>&gt;&nbsp;::=&nbsp;</TD></TR><TR valign="top"><TD>&nbsp;&nbsp;&nbsp;&nbsp;</TD><TD></TD><TD><CODE>fSynApplication(</CODE>&lt;<I>grammar symbol</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>phrase</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSynAction(</CODE>&lt;<I>phrase</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSynSequence([</CODE>&lt;<I>variable</I>&gt;<CODE>]&nbsp;[</CODE>&lt;<I>syn expression</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSynAlternative([</CODE>&lt;<I>syn expression</I>&gt;<CODE>])</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSynAssignment(</CODE>&lt;<I>escapable variable</I>&gt;<CODE>&nbsp;</CODE>&lt;<I>syn expression</I>&gt;<CODE>)</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>fSynTemplateInstantiation(</CODE>&lt;<I>prod key</I>&gt;<CODE>&nbsp;[</CODE>&lt;<I>syn expression</I>&gt;<CODE>]</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>coord</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node6.html#appendix.narrator">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node8.html#appendix.bytecode">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
