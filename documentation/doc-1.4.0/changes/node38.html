<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>13.2 Syntax Improvements</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node37.html#section.m100.general">&lt;&lt; Prev</A></TD><TD><A href="node36.html">- Up -</A></TD><TD><A href="node39.html#section.m100.base">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="section.m100.syntax"><H2><A name="section.m100.syntax">13.2 Syntax Improvements</A></H2><P> Mozart implements the language Oz&nbsp;3, as opposed to DFKI Oz&nbsp;2, which implemented Oz&nbsp;2. This chapter summarizes language changes between Oz&nbsp;2 and Oz&nbsp;3, of which most are only of syntactical nature. </P><H3><A name="label51">13.2.1 Conditionals</A></H3><P> The <CODE><SPAN class="keyword">case</SPAN></CODE> keyword used to introduce one of two conditionals: the boolean or the pattern matching conditional. To adapt to common intuitions, the syntax and semantics have been changed. </P><DIV class="apropos"><P class="margin">Boolean Conditionals</P><P> The boolean conditional is now written as </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">if</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE><I>SE1</I><CODE>&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>SE2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> If the construct is statement position, the <CODE><SPAN class="keyword">else</SPAN>&nbsp;</CODE><I>SE2</I> part is optional and defaults to <CODE><SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN></CODE>. </P></DIV><P> Since the <CODE><SPAN class="keyword">if</SPAN></CODE> keyword is now used for boolean conditionals, the former (and seldom used) <CODE><SPAN class="keyword">if</SPAN></CODE> conditional has been renamed to <CODE><SPAN class="keyword">cond</SPAN></CODE>. There is no <CODE>elsecond</CODE> to replace <CODE><SPAN class="keyword">elseif</SPAN></CODE>. </P><DIV class="apropos"><P class="margin">Pattern-Matching</P><P> The <CODE><SPAN class="keyword">case</SPAN>&nbsp;</CODE><I>E</I><CODE>&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;</CODE>...<CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE> conditional retains its syntax but changes its semantics. Where formerly logic (dis-)entailment was used to match the value against a pattern, now a series of sequential tests is performed. This makes no difference if the match is entailed. Disentailment, however, may remain undiscovered and the thread block, e.&nbsp;g., in: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">case</SPAN>&nbsp;f(a&nbsp;b)&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;f(X&nbsp;X)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;</CODE>...<CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DIV><P> Furthermore, the box <CODE><SPAN class="keyword">[]</SPAN></CODE> separating pattern-matching clauses now also has sequential semantics, and is thus equivalent to the now deprecated, though still allowed, <CODE><SPAN class="keyword">elseof</SPAN></CODE>. </P><P> <CODE><SPAN class="keyword">elseif</SPAN></CODE> and <CODE><SPAN class="keyword">elsecase</SPAN></CODE> may still be freely intermixed within <CODE><SPAN class="keyword">if</SPAN></CODE> and <CODE><SPAN class="keyword">case</SPAN></CODE> conditionals. </P><H3><A name="label52">13.2.2 Functors</A></H3><P> To accomodate modular application development, a module system has been designed. The language itself supports the definition of <EM>functors</EM>, from which modules can be obtained via linking. </P><H3><A name="label53">13.2.3 Exceptions</A></H3><P> The construct <CODE><SPAN class="keyword">raise</SPAN>&nbsp;</CODE><I>E1</I><CODE>&nbsp;with&nbsp;</CODE><I>E2</I><CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE> has been removed. This was an experimental feature that has been found to be rarely used. </P><H3><A name="label54">13.2.4 Keywords</A></H3><DIV class="apropos"><P class="margin">New Keywords</P><P> Due to syntax changes, Oz&nbsp;3 has the following keywords, which thus cannot be used as unquoted atoms any more: </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TD><P><CODE><SPAN class="keyword">at</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">cond</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">define</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">export</SPAN></CODE></P></TD></TR><TR valign="top"><TD><P><CODE><SPAN class="keyword">functor</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">import</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">prepare</SPAN></CODE></P></TD><TD><P><CODE><SPAN class="keyword">require</SPAN></CODE></P></TD></TR></TABLE><P> </P></DIV><DIV class="apropos"><P class="margin">Removed Keywords</P><P> The following keywords have been returned atom status and do not count as keywords any more: </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TD><P><CODE>with</CODE></P></TD></TR></TABLE><P> </P></DIV><H3><A name="label55">13.2.5 Core Expansion</A></H3><P> The core expansion of Oz&nbsp;3 as defined in <A href="../notation/index.html">``The Oz Notation''</A> does not give core variables (written without backquotes) normal variable status any more, but considers them variables statically bound within a runtime library environment. This means that the used backquote variables are not part of the Base Environment. </P><P> This was necessary because the old design compromised language security. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node37.html#section.m100.general">&lt;&lt; Prev</A></TD><TD><A href="node36.html">- Up -</A></TD><TD><A href="node39.html#section.m100.base">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
