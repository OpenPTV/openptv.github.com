<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4 Creating a DLL</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.cpart">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.windll">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.unixdll"><H1><A name="chapter.unixdll">4 Creating a DLL</A></H1><DIV id="chapter.compiling"><H2><A name="chapter.compiling">4.1 Compiling the C++ program</A></H2><P>The Mozart system provides <A href="../tools/node14.html#chapter.oztool"><CODE>oztool</CODE></A> which we recommend you invoke instead of calling the C/C++ compiler directly: </P><BLOCKQUOTE class="code"><CODE>oztool&nbsp;c++&nbsp;-c&nbsp;getenv.cc&nbsp;-o&nbsp;getenv.o</CODE></BLOCKQUOTE><P> <CODE>oztool</CODE> takes care of many unpleasant details for you; for example, it supplies the compiler with the appropriate option for the generation of position independent code.</P></DIV><DIV id="chapter.linking"><H2><A name="chapter.linking">4.2 Creating a dynamic library</A></H2><P>Now, we create a shared object from the compiled object file obtained above. Again you should invoke <CODE>oztool</CODE> rather than call the linker directly: </P><BLOCKQUOTE class="code"><CODE>oztool&nbsp;ld&nbsp;getenv.o&nbsp;-o&nbsp;getenv.so</CODE></BLOCKQUOTE><P> This takes care of many ugly details (especially on Windows where they could easily drive you nuts). Actually, you should really create a shared object file with, as suffix, the platform for which it was created. For example: </P><BLOCKQUOTE class="code"><CODE>oztool&nbsp;ld&nbsp;getenv.o&nbsp;-o&nbsp;getenv.so-linux-i486</CODE></BLOCKQUOTE><P> The reason is that the Oz module manager was designed to support platform independent module import specifications, but, of course, native modules must be resolved to platform dependent implementations. The default resolution strategy achieves this by means of platform suffixes.</P><P>In order to write portable makefiles, you can use <CODE>oztool</CODE> to print out the platform name: </P><BLOCKQUOTE class="code"><CODE>oztool&nbsp;platform</CODE></BLOCKQUOTE><P> Thus a portable way to create the shared object is: </P><BLOCKQUOTE class="code"><CODE>oztool&nbsp;ld&nbsp;getenv.o&nbsp;-o&nbsp;getenv.so-`oztool&nbsp;platform`</CODE></BLOCKQUOTE><P> </P></DIV><DIV id="sec.foreignlink"><H2><A name="sec.foreignlink">4.3 Linking a native module</A></H2><P>In the last step we make the native module available by linking it into Oz. Lines 16--23 in <A href="node2.html#getenvc">Program&nbsp;2.1</A> are needed to declare the export signature of the native module. A function named <CODE>oz_init_module</CODE> must be exported by every native module: this function will be called when the module is linked into Oz. It can be used to do some module dependent initialization and has to return an array whose elements are of type <CODE>OZ_C_proc_interface</CODE>; the end of the array must be terminated by an empty structure. The array describes the signature of the functions being exported from the module: </P><BLOCKQUOTE class="code"><CODE>typedef&nbsp;struct&nbsp;{<BR>&nbsp;&nbsp;const&nbsp;char&nbsp;*&nbsp;name;<BR>&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inArity;<BR>&nbsp;&nbsp;short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;outArity;<BR>&nbsp;&nbsp;OZ_CFun&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func;<BR>}&nbsp;OZ_C_proc_interface;</CODE></BLOCKQUOTE><P> <CODE>name</CODE> is a string naming the feature under which the native function will be accessible from Oz (see below). <CODE>inArity</CODE> and <CODE>outArity</CODE> specify the number of input and output arguments. <CODE>func</CODE> is a pointer to the function being exported.</P><P>Now we can link our module into Oz by executing: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;<BR>[Goodies]={Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">'./getenv.so{native}'</SPAN>]}&nbsp;</CODE></BLOCKQUOTE><P> This will lazily load the module upon first access and bind <CODE>Goodies</CODE> to a record with a single (since we exported only one function) feature named <CODE>getenv</CODE> (this is derived from the value of the <CODE>name</CODE> field of <CODE>OZ_C_proc_interface</CODE>). Now we can call it like this: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;{Goodies<SPAN class="keyword">.</SPAN>getenv&nbsp;<SPAN class="string">'HOME'</SPAN>}}&nbsp;</CODE></BLOCKQUOTE><P> The module can also be imported by any Oz module: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;G&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'getenv.so{native}'</SPAN>&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;{G<SPAN class="keyword">.</SPAN>getenv&nbsp;<SPAN class="keyword">...</SPAN>}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> Note that the url used in the import specification does not supply the platform suffix, but adds the <CODE>{native}</CODE> annotation. The module manager (or more precisely the resolver) will remove the annotation and replace it with the suffix appropriate for the current platform. </P><P></P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.cpart">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.windll">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~mehl/">Michael&nbsp;Mehl</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~scheidhr/">Ralf&nbsp;Scheidhauer</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
