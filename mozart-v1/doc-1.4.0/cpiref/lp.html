<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Employing Linear Programming Solvers</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="ct.html#chapter.ct">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="pel.html#chapter.pel">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.lp"><H1><A name="chapter.lp">3 Employing Linear Programming Solvers</A></H1><DIV id="lp.reference"><H2><A name="lp.reference">3.1 The Module <CODE>LP</CODE></A></H2><P> The module <CODE>LP</CODE> is provided as contribution (being part of the Mozart Oz 3 distribution<A href="lp.html#label306"><SUP>1</SUP></A>) and can be accessed either by </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;[LP]&nbsp;=&nbsp;{Module<SPAN class="keyword">.</SPAN>link&nbsp;[<SPAN class="string">'x-oz://contrib/LP'</SPAN>]}</CODE></BLOCKQUOTE><P> or by </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">import</SPAN>&nbsp;RI&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'x-oz://contrib/LP'</SPAN></CODE></BLOCKQUOTE><P> as part of a functor definition. </P><P></P><DL><DT><CODE>{LP<SPAN class="keyword">.</SPAN>solve&nbsp;</CODE><CODE>$<I>RIs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>ObjFn</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Constrs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>OptSol</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RetVal</I></CODE><CODE>}</CODE> <A name="label303"></A></DT><DD><P>Invoke the LP solver. Use <CODE>LP<SPAN class="keyword">.</SPAN>config</CODE> for configuring the solver. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>VECTOR_OF(X)</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>tuple of <I>X</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>record of <I>X</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>list of <I>X</I></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>RIs</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD> <I>VECTOR_OF(RI)</I></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>RI</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>float | real interval variable </TD></TR></TABLE></BLOCKQUOTE><P>The first parameter is a vector of real-interval variables. The current bounds of the real-intervals are used as bound constraints by the LP solver. The second parameter determines the objective function: </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>ObjFn</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD> <CODE>objfn(row:&nbsp;</CODE> &lt;<I>VECTOR_OF(float)</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD> <CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;opt:&nbsp;min&nbsp;<SPAN class="keyword">|</SPAN>&nbsp;max)</CODE> </TD></TR></TABLE></BLOCKQUOTE><P>The value at <CODE>opt</CODE> stands for minimize (<CODE>min</CODE>) resp. maximize (<CODE>max</CODE>). The third parameter introduces the constraints to the LP solver. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>Constrs</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD> <I>VECTOR_OF(Constr)</I></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>Constr</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD> <CODE>constr(row:&nbsp;&nbsp;</CODE> &lt;<I>VECTOR_OF(float)</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD> <CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;<SPAN class="string">'=&lt;'</SPAN>&nbsp;<SPAN class="keyword">|</SPAN>&nbsp;<SPAN class="string">'=='</SPAN>&nbsp;<SPAN class="keyword">|</SPAN>&nbsp;<SPAN class="string">'&gt;=&quot;</SPAN></CODE> </TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD> <CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rhs:&nbsp;&nbsp;</CODE> float <CODE>)</CODE> </TD></TR></TABLE></BLOCKQUOTE><P>The fourth parameter <CODE>OptSol</CODE> is constrained to the optimal solution. In case it is already constrained to a real-interval variable, the LP solver derives an additional constraint which makes sure that no greater (minimize) resp. smaller (maximize) solution is found. The last parameter indicates the success of the LP solvers. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>RetVal</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>optimal</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>infeasable</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>unbounded</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>failure</CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DD><DT><CODE>{LP<SPAN class="keyword">.</SPAN>config&nbsp;</CODE><CODE>+<I>put</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>ConfigDirection</I></CODE><CODE>}</CODE> <A name="label304"></A></DT><DD><P>Set configuration of module <CODE>LP</CODE>. One can set <CODE>mode</CODE> and <CODE>solver</CODE>. </P></DD><DT><CODE>{LP<SPAN class="keyword">.</SPAN>config&nbsp;</CODE><CODE>+<I>get</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>CurrentConfig</I></CODE><CODE>}</CODE> <A name="label305"></A></DT><DD><P>Read current configuration of module <CODE>LP</CODE>. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>CurrentConfig</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD> <CODE>config(avail:&nbsp;&nbsp;</CODE>&lt;<I>AVAIL_SOLVERS</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mode:&nbsp;&nbsp;&nbsp;</CODE>&lt;<I>MODES</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solver:&nbsp;</CODE>&lt;<I>SOLVER</I>&gt;<CODE>)</CODE></TD></TR></TABLE></BLOCKQUOTE><P>Note that &lt;<I>SOLVER</I>&gt; takes a value out of &lt;<I>AVAIL_SOLVERS</I>&gt;. The solvers available depend on your local installation. The solver <EM>LP_SOLVE</EM> (<CODE>lpsolve</CODE>) is the default solver. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>AVAIL_SOLVERS</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>lpsolve</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>cplex_primopt</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>cplex_dualopt</CODE></TD></TR></TABLE></BLOCKQUOTE><P>The solver may run in two modes: </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD><I>MODES</I></TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>quiet</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>verbose</CODE></TD></TR></TABLE></BLOCKQUOTE><P>The <CODE>verbose</CODE> mode is intended for debugging and outputs whether an optimal was found (resp. if not what was the problem) and if so the optimal solution. </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="ct.html#chapter.ct">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="pel.html#chapter.pel">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label306">1. </A>The module <CODE>LP</CODE> is <EM>not</EM> provided on any Windows platform.</DIV><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
