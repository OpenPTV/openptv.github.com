<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Editing Oz Code</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.start">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.running">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.editing"><H1><A name="chapter.editing">3 Editing Oz Code</A></H1><P> The commands in this chapter assist in editing Oz code. To achieve this, many of these are aware of the lexical or syntactical structure of Oz programs. </P><H2><A name="label58">3.1 Managing Oz Buffers</A></H2><P> The Oz modes offer commands for creating new interactive buffers and quickly switching between Oz buffers: </P><DL><DT class="command"><A name="label59"></A><SPAN class="index"><CODE>oz-new-buffer</CODE></SPAN> (<A name="key.oz-new-buffer" id="key.oz-new-buffer"><SPAN class="key">C-. n</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Create a new buffer using the Oz major mode. Note that this buffer has no associated file name, so quitting Emacs will kill it without warning. </P></DD><DT class="command"><A name="label60"></A><SPAN class="index"><CODE>oz-next-buffer</CODE></SPAN> (<A name="key.oz-next-buffer" id="key.oz-next-buffer"><SPAN class="key">M-n</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DT class="command"><A name="label61"></A><SPAN class="index"><CODE>oz-previous-buffer</CODE></SPAN> (<A name="key.oz-previous-buffer" id="key.oz-previous-buffer"><SPAN class="key">M-p</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Switch to the previous resp. next buffer in the buffer list that runs in an Oz mode. If no such buffer exists, an error is signalled. </P></DD></DL><P> </P><H2><A name="label62">3.2 Indentation</A></H2><P> The preferred indentation style can currently be customized through the following user option: </P><DL><DT class="useroption"><A name="label63"></A><SPAN class="index"><CODE>oz-indent-chars</CODE></SPAN> (default: <CODE>3</CODE>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>user option</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Number of columns that statements are indented w.&nbsp;r.&nbsp;t. the block containing them. </P></DD></DL><P> Several commands assist in formatting existing Oz code. </P><DL><DT class="command"><A name="label64"></A><SPAN class="index"><CODE>oz-indent-line</CODE></SPAN> <CODE><SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>COUNT</I></CODE> (<SPAN class="key">TAB</SPAN>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Reindent the current line. If <CODE><I>COUNT</I></CODE> is given, reindent that many lines above and below point as well. </P></DD><DT class="command"><A name="label65"></A><SPAN class="index"><CODE>oz-indent-region</CODE></SPAN> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Reindent all lines at least partly covered by the current region. </P></DD><DT class="command"><A name="label66"></A><SPAN class="index"><CODE>oz-indent-buffer</CODE></SPAN> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Reindent every line in the buffer. </P></DD><DT class="command"><A name="label67"></A><SPAN class="index"><CODE>indent-oz-expr</CODE></SPAN> (<A name="key.indent-oz-expr" id="key.indent-oz-expr"><SPAN class="key">M-C-q</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P><A name="label68"></A> Reindent all lines at least partly covered by the Oz expression following point. For a description of what constitutes an Oz expression, see <A href="node3.html#section.expression-commands">Section&nbsp;3.5</A>. </P></DD></DL><P> The following command assists in authoring Oz code. </P><DL><DT class="command"><A name="label69"></A><SPAN class="index"><CODE>oz-electric-terminate-line</CODE></SPAN> (<SPAN class="key">RET</SPAN>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Terminate the current line, i.&nbsp;e., delete all whitespace around point and break the line. If the user option <CODE>oz-auto-indent</CODE> is non-<CODE>nil</CODE>, indent both lines. </P></DD><DT class="useroption"><A name="label70"></A><SPAN class="index"><CODE>oz-auto-indent</CODE></SPAN> (default: <CODE>t</CODE>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>user option</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>See <CODE>oz-electric-terminate-line</CODE>. </P></DD></DL><P> Additionally, <SPAN class="key">DEL</SPAN> is bound to the Emacs command <CODE>backward-delete-char-untabify</CODE>. </P><H2><A name="label71">3.3 Fontification</A></H2><P> <A name="label72"></A><A name="label73"></A> <EM class="noindex">Fontification</EM> is the term used in Emacs for displaying text in different font faces, depending on its syntactical form and context, to ease reading of code. For example, <A name="label74"></A><SPAN class="index">comments</SPAN> and <A name="label75"></A><SPAN class="index">strings</SPAN> may be displayed in different colours. </P><P> Many major modes in Emacs provide several levels of fontification with increasing use of faces, but also increasing resource consumption. In the Oz modes, there are three levels. You can select one using the <CODE>font-lock-maximum-decoration</CODE> user option, e.&nbsp;g., add the following line to your <CODE>.emacs</CODE>: </P><BLOCKQUOTE class="code"><CODE>(<SPAN class="keyword">setq</SPAN>&nbsp;<SPAN class="variablename">font-lock-maximum-decoration</SPAN>&nbsp;3)</CODE></BLOCKQUOTE><P> The default level depends on your version of Emacs. </P><P> The following user option controls automatic fontification in the OPI. </P><DL><DT class="useroption"><A name="label76"></A><SPAN class="index"><CODE>oz-want-font-lock</CODE></SPAN> (default: <CODE>t</CODE>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>user option</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>If non-<CODE>nil</CODE>, automatically invoke <CODE>font-lock-mode</CODE> when any of the Oz modes is activated. If you prefer to control this via <CODE>global-font-lock-mode</CODE>, you can set this to <CODE>nil</CODE>. </P></DD></DL><P> You might like the following user option and command if you care about superfluous (usually invisible) <A name="label77"></A><A name="label78"></A><SPAN class="index">spaces</SPAN>: </P><DL><DT class="useroption"><A name="label79"></A><SPAN class="index"><CODE>oz-pedantic-spaces</CODE></SPAN> (default: <CODE>nil</CODE>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>user option</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>If non-nil, highlight ill-placed whitespace. Note that this user option must be set before the <CODE>oz</CODE> library is loaded. </P></DD><DT class="face"><A name="label80"></A><SPAN class="index"><CODE>oz-space-face</CODE></SPAN> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>face</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>The face in which ill-placed whitespace is highlighted. </P></DD><DT class="command"><A name="label81"></A><SPAN class="index"><CODE>oz-remove-annoying-spaces</CODE></SPAN> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Remove all ill-placed whitespace from the current buffer. This is all the whitespace that is highlighted in <CODE>oz-space-face</CODE>. </P></DD></DL><P> </P><H2><A name="label82">3.4 Comments</A></H2><P> <A name="label83"></A> </P><DL><DT class="command"><A name="label84"></A><SPAN class="index"><CODE>oz-fill-paragraph</CODE></SPAN> <CODE><SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>JUSTIFY</I></CODE> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Like the <A name="label85"></A><SPAN class="index"><CODE>fill-paragraph</CODE></SPAN> command, but handles Oz comments. If any of the current line is a comment, fill the comment or the paragraph of it that point is in, preserving the comment's indentation and initial percent signs. The buffer-local variable <CODE>fill-paragraph-function</CODE> is bound to this command, so it will also be invoked by <SPAN class="key">M-x fill-paragraph</SPAN> (<SPAN class="key">M-q</SPAN>). </P></DD><DT class="command"><A name="label86"></A><SPAN class="index"><CODE>oz-comment-region</CODE></SPAN> <CODE><I>START</I></CODE><CODE>&nbsp;</CODE><CODE><I>END</I></CODE><CODE>&nbsp;<SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>ARG</I></CODE> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Comment or uncomment each line in the region. With just <SPAN class="key">C-u</SPAN> as prefix argument, uncomment each line in region. A numeric prefix argument <CODE><I>ARG</I></CODE> means use <CODE><I>ARG</I></CODE> comment characters. If <CODE><I>ARG</I></CODE> is negative, delete that many comment characters instead. Blank lines do not get comments. </P></DD><DT class="command"><A name="label87"></A><SPAN class="index"><CODE>oz-uncomment-region</CODE></SPAN> <CODE><I>START</I></CODE><CODE>&nbsp;</CODE><CODE><I>END</I></CODE><CODE>&nbsp;<SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>ARG</I></CODE> <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Comment or uncomment each line in the region. See the <CODE>oz-comment-region</CODE> command for more information; note that the prefix argument is negated though. </P></DD></DL><P> </P><DIV id="section.expression-commands"><H2><A name="section.expression-commands">3.5 Expression-Level Commands</A></H2><P> In this section, we use the term <A name="label88"></A><A name="label89"></A><EM>Oz definition</EM> to stand for the text from a <A name="label90"></A><SPAN class="index"><CODE><SPAN class="keyword">proc</SPAN></CODE></SPAN>, <A name="label91"></A><SPAN class="index"><CODE><SPAN class="keyword">fun</SPAN></CODE></SPAN>, <A name="label92"></A><SPAN class="index"><CODE><SPAN class="keyword">class</SPAN></CODE></SPAN> or <A name="label93"></A><SPAN class="index"><CODE><SPAN class="keyword">meth</SPAN></CODE></SPAN> keyword up to its matching <A name="label94"></A><SPAN class="index"><CODE><SPAN class="keyword">end</SPAN></CODE></SPAN>. Also, we use the term <A name="label95"></A><A name="label96"></A><EM>Oz expression</EM> to stand for the text corresponding to either a bracketed Oz construct (such as <CODE><SPAN class="keyword">proc</SPAN>&nbsp;</CODE>...<CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE> or <CODE><SPAN class="keyword">local</SPAN>&nbsp;</CODE>...<CODE>&nbsp;<SPAN class="keyword">end</SPAN></CODE>) or a single word. </P><P> </P><DL><DT class="command"><A name="label97"></A><SPAN class="index"><CODE>forward-oz-expr</CODE></SPAN> <CODE><SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>COUNT</I></CODE> (<A name="key.forward-oz-expr" id="key.forward-oz-expr"><SPAN class="key">M-C-f</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Move point forward by one balanced Oz expression. With <CODE><I>COUNT</I></CODE>, do it that many times. Negative <CODE><I>COUNT</I></CODE> means backwards. </P></DD><DT class="command"><A name="label98"></A><SPAN class="index"><CODE>backward-oz-expr</CODE></SPAN> <CODE><SPAN class="type">&amp;optional</SPAN>&nbsp;</CODE><CODE><I>COUNT</I></CODE> (<A name="key.backward-oz-expr" id="key.backward-oz-expr"><SPAN class="key">M-C-b</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P><A name="label99"></A> Move point backward by one balanced Oz expression. With <CODE><I>COUNT</I></CODE>, do it that many times. <CODE><I>COUNT</I></CODE> must be positive. </P></DD><DT class="command"><A name="label100"></A><SPAN class="index"><CODE>mark-oz-expr</CODE></SPAN> <CODE><I>COUNT</I></CODE> (<A name="key.mark-oz-expr-1" id="key.mark-oz-expr-1"><SPAN class="key">M-C-@</SPAN></A>, <A name="key.mark-oz-expr-2" id="key.mark-oz-expr-2"><SPAN class="key">M-C-SPC</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P><A name="label101"></A> Set mark <CODE><I>COUNT</I></CODE> balanced Oz expressions from point. The place mark goes to is the same place the <CODE>forward-oz-expr</CODE> command would move to with the same argument. </P></DD><DT class="command"><A name="label102"></A><SPAN class="index"><CODE>transpose-oz-exprs</CODE></SPAN> <CODE><I>ARG</I></CODE> (<A name="key.transpose-oz-exprs" id="key.transpose-oz-exprs"><SPAN class="key">M-C-t</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Like the <CODE>transpose-words</CODE> command (<SPAN class="key">M-t</SPAN>) but applies to balanced Oz expressions. Caveat: This might not produce nice results in all cases. </P></DD><DT class="command"><A name="label103"></A><SPAN class="index"><CODE>kill-oz-expr</CODE></SPAN> <CODE><I>COUNT</I></CODE> (<A name="key.kill-oz-expr" id="key.kill-oz-expr"><SPAN class="key">M-C-k</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P><A name="label104"></A><A name="label105"></A> Kill the balanced Oz expression following point. With <CODE><I>COUNT</I></CODE>, kill that many Oz expressions after point. Negative <CODE><I>COUNT</I></CODE> means kill <CODE>-</CODE><CODE><I>COUNT</I></CODE> Oz expressions before point. </P></DD><DT class="command"><A name="label106"></A><SPAN class="index"><CODE>backward-kill-oz-expr</CODE></SPAN> <CODE><I>COUNT</I></CODE> (<A name="key.backward-kill-oz-expr" id="key.backward-kill-oz-expr"><SPAN class="key">M-C-DEL</SPAN></A> <A href="node3.html#label109"><SUP>1</SUP></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Kill the balanced Oz expression preceding point. With <CODE><I>COUNT</I></CODE>, kill that many Oz expressions before point. Negative <CODE><I>COUNT</I></CODE> means kill <CODE>-</CODE><CODE><I>COUNT</I></CODE> Oz expressions after point. </P></DD><DT class="command"><A name="label107"></A><SPAN class="index"><CODE>oz-beginning-of-defun</CODE></SPAN> (<A name="key.oz-beginning-of-defun" id="key.oz-beginning-of-defun"><SPAN class="key">M-C-a</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Move point to the start of the Oz definition it is in. If point is not inside an Oz definition, move to start of buffer. Returns <CODE>t</CODE> unless search stops due to beginning or end of buffer. </P></DD><DT class="command"><A name="label108"></A><SPAN class="index"><CODE>oz-end-of-defun</CODE></SPAN> (<A name="key.oz-end-of-defun" id="key.oz-end-of-defun"><SPAN class="key">M-C-e</SPAN></A>) <SPAN class="entrycategory"><SPAN class="entrycategorybracket">&nbsp;[</SPAN><I>command</I><SPAN class="entrycategorybracket">]</SPAN></SPAN></DT><DD><P>Move point to the end of the Oz definition it is in. If point is not inside an Oz definition, move to end of buffer. </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.start">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.running">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label109">1. </A>Note that under some configurations, this key combination kills the X&nbsp;server.</DIV><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
