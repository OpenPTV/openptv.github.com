<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 The Interactive Development Environment</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.opi"><H1><A name="chapter.opi">2 The Interactive Development Environment</A></H1><H3 class="authors"><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A> and&nbsp;<A href="http://www.sics.se/~andreas">Andreas&nbsp;Sundström</A></H3><P>This tutorial contains many code examples and you are highly encouraged to try them out interactively as you go. This can be done very comfortably by taking advantage of the Mozart system's interactive development environment. We normally call it the OPI, which stands for the <EM>Oz Programming Interface</EM>, and it is described extensively in <A href="../opi/index.html">``The Oz Programming Interface''</A>. In the present section, you will learn just enough about the OPI to allow you to start experimenting with our code examples.</P><H2><A name="label7">2.1 Starting The OPI</A></H2><P>Under Unix, the OPI is normally started by invoking the command <CODE>oz</CODE> at the shell prompt. Under Windows, the installation procedure will have provided you with a Mozart system program group: click on the Mozart item in this group. Shortly thereafter you get a window that looks like this: </P><DIV align="center"><IMG alt="" src="opi1.gif"></DIV><P> The OPI uses the Emacs editor as the programming front-end. If you are not familiar with Emacs or its terminology, you should consult the Emacs on-line tutorial <A href="bib.html#stallman91">[Sta91]</A> available from the Help menu in the Emacs menu bar.</P><P>The initial window is split in two text buffers. The upper buffer called <CODE>Oz</CODE> is a space where you can write small pieces of code and interactively execute them: it essentially plays, for Oz code, the same role as the <CODE><SPAN class="keyword">*</SPAN>scratch<SPAN class="keyword">*</SPAN></CODE> buffer for emacs lisp code. The lower text buffer is called <CODE><SPAN class="keyword">*</SPAN>Oz&nbsp;Compiler<SPAN class="keyword">*</SPAN></CODE> and shows a transcript of your interaction with the compiler of the Mozart subprocess. </P><H2><A name="label8">2.2 Hello World</A></H2><P>Let us begin with the traditional <EM>Hello World</EM> example. In the <CODE>Oz</CODE> buffer, type the following: </P><BLOCKQUOTE class="code"><CODE>{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE></BLOCKQUOTE><P> This example illustrates the unconventional syntax of procedure invocation in Oz: it is indicated by curly braces. Here, procedure <CODE>Show</CODE> is invoked with, as single argument, the atom <CODE><SPAN class="string">'Hello&nbsp;World'</SPAN></CODE>.</P><P>In order to execute this fragment, we position the point on the line we just typed and select <EM>Feed Line</EM> from the Oz menu in the menubar. We now see: </P><DIV align="center"><IMG alt="" src="opi2.gif"></DIV><P> The transcript from the compiler indicates that <CODE>{Show&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE> was <EM>fed</EM> to the compiler and <EM>accepted</EM>, i.&nbsp;e. successfully parsed and compiled. But was it executed, and, if yes, where is the output? Indeed it was executed, but the output appears in a different buffer called <CODE><SPAN class="keyword">*</SPAN>Oz&nbsp;Emulator<SPAN class="keyword">*</SPAN></CODE>: this contains the execution transcript. If we select from the Oz menu <EM>Show/Hide -&gt; Emulator</EM>, we now see: </P><DIV align="center"><IMG alt="" src="opi3.gif"></DIV><P></P><H2><A name="label9">2.3 Good News For The Programmer</A></H2><P>The OPI has many features to support interactive code development. </P><H3><A name="label10">2.3.1 Code Editing</A></H3><P>The <CODE>oz-mode</CODE> is a major mode for editing Oz code, and provides automatic indentation as well <CODE>font-lock</CODE> support for code colorization.</P><H3><A name="label11">2.3.2 Key Bindings</A></H3><P>You may interact with the underlying Mozart subprocess from any buffer in <CODE>oz-mode</CODE>, not just from the <CODE>Oz</CODE> buffer as demonstrated earlier. Furthermore, all the actions that we carried out in the <EM>Hello World</EM> example can be invoked more conveniently through key bindings instead of through the Oz menu. </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TD><P><SPAN class="key">C-. C-l</SPAN></P></TD><TD><P>Feed current line</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-r</SPAN></P></TD><TD><P>Feed selected region</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-b</SPAN></P></TD><TD><P>Feed whole buffer</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">M-C-x</SPAN></P></TD><TD><P>Feed current paragraph</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. C-p</SPAN></P></TD><TD><P><EM>idem</EM></P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. c</SPAN></P></TD><TD><P>Toggle display of <CODE>*Oz&nbsp;Compiler*</CODE> buffer</P></TD></TR><TR valign="top"><TD><P><SPAN class="key">C-. e</SPAN></P></TD><TD><P>Toggle display of <CODE>*Oz&nbsp;Emulator*</CODE> buffer</P></TD></TR></TABLE><P> a ``paragraph'' is a region of text delimited by empty lines. </P><H3><A name="label12">2.3.3 Compiler Errors</A></H3><P>The OPI also has support for conveniently dealing with errors reported by the compiler. Let us type the following erroneous code in the <CODE>Oz</CODE> buffer: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;A&nbsp;B&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;3<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">B</SPAN>}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;A&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;<SPAN class="string">'Tinman'</SPAN>}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{B&nbsp;7}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> and feed it to the compiler using <SPAN class="key">M-C-x</SPAN>. The compiler reports 2 errors and we see: </P><DIV align="center"><IMG alt="" src="opi4.gif"></DIV><P> <SPAN class="key">C-x `</SPAN> (that is <EM>Control-x backquote</EM>) positions the transcript to make the first error message visible and moves the point, in the source buffer, to where the bug is likely to be located. </P><DIV align="center"><IMG alt="" src="opi5.gif"></DIV><P> Indeed, we should not try to add an integer and an atom! If we invoke <SPAN class="key">C-x `</SPAN> once more, we see: </P><DIV align="center"><IMG alt="" src="opi6.gif"></DIV><P> Here, we have mistakenly applied a nullary procedure to an argument. </P><H3><A name="label13">2.3.4 Graphical Development Tools</A></H3><P>The mozart system has many graphical tools. Here we only mention the <EM>Browser</EM> which is otherwise extensively documented in <A href="../browser/index.html">``The Oz Browser''</A>. So far, we merely used the procedure <CODE>Show</CODE> to print out values. Instead, we can invoke <CODE>Browse</CODE> to get a graphical display interface. For example, feeding: </P><BLOCKQUOTE class="code"><CODE>{Browse&nbsp;<SPAN class="string">'Hello&nbsp;World'</SPAN>}</CODE></BLOCKQUOTE><P> causes the following new window to pop up: </P><DIV align="center"><IMG alt="" src="opi7.gif"></DIV><P> This is not very exciting, but let's now feed this code: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;W&nbsp;H<BR>{Browse&nbsp;foo(width:W&nbsp;height:H&nbsp;surface:<SPAN class="keyword">thread</SPAN>&nbsp;W<SPAN class="keyword">*</SPAN>H&nbsp;<SPAN class="keyword">end</SPAN>)}</CODE></BLOCKQUOTE><P> Now the browser window shows a term that is only partially known (instantiated) since variable <CODE>W</CODE> and <CODE>H</CODE> have been declared but not yet bound to values: </P><DIV align="center"><IMG alt="" src="opi8.gif"></DIV><P> Now let us feed <CODE>W=3</CODE> and we see that the browser automatically updates the display to reflect the information we just added. </P><DIV align="center"><IMG alt="" src="opi9.gif"></DIV><P> Now we feed <CODE>H=5</CODE> and again the browser updates the display and now shows a fully instantiated term: </P><DIV align="center"><IMG alt="" src="opi10.gif"></DIV><P> The browser allows you to see the evolution of the instantiation of a term as concurrent computations (threads) proceed and add more information. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.basics">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A> and&nbsp;<A href="http://www.sics.se/~nilsf">Nils&nbsp;Franzén</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
