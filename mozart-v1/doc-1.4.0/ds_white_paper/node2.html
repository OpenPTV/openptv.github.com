<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Connection Establishment</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.entities">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.connections"><H1><A name="chapter.connections">2 Connection Establishment</A></H1><P>When a Mozart site is a participant in a distributed computation, entities are automatically distributed via lexical scoping and connections are opened when needed. Before this can take place an initial entry point in the distributed application must exist. This is what we refer to as bootstrapping a connection. </P><H2><A name="label4">2.1 Bootstrapping a Connection</A></H2><P>The Mozart programmer establishes connections to the outside world by offering a ticket to an entity. Such a ticket is an character string containing enough information for other Mozart sites to connect to the offering site and access the offered entity. This connection establishment procedure is illustrated in <A href="node2.html#figure.bootstrap">Figure&nbsp;2.1</A>. </P><DIV id="figure.bootstrap"><HR><P><A name="figure.bootstrap"></A></P><DIV align="center"><IMG alt="" src="bootstrap.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;2.1:</STRONG> Bootstrapping a Connection</P><HR></DIV><P> </P><OL type="1"><LI><P>Site <CODE>A</CODE> offers a ticket to entity X and saves the string to persistent storage available to B. </P></LI><LI><P>Site <CODE>B</CODE> loads the string and <EM>takes</EM> this ticket which will cause a representation of site <CODE>A</CODE> and a representation of X to be created at B. </P></LI><LI><P>Site <CODE>B</CODE> creates a message requesting access to X and passes the message down to the representation of <CODE>A</CODE>. </P></LI><LI><P>A connection to <CODE>A</CODE> is requested from the connect-accept-module. </P></LI><LI><P>At site <CODE>A</CODE> an incoming request for a connection is accepted. During a hand-shake phase the representation of <CODE>B</CODE> is passed to <CODE>A</CODE>. </P></LI><LI><P>Site <CODE>B</CODE> marshals the message and sends it to <CODE>A</CODE>. </P></LI><LI><P>Site <CODE>A</CODE> unmarshals the message and passes it to the appropriate protocol message handler. </P></LI></OL><P> </P><H2><A name="label5">2.2 Dynamic Connection Establishment through Connect-Accept-Pairs</A></H2><P>How a message is transferred between two sites, and how a physical connection is initialized is of no importance to the semantics of entities. However, this is of great importance when it comes to communicating over different types of networks with different restrictions such as security requirements or firewalls. Mozart offers a default connect-accept-module with non-secure initialization of a connection over TCP, but the interfaces are open for the programmer to customize parts or all of the procedure. This is possible through the notion of Connect-Accept-Pairs and the three layer design, allowing for replacement of the transport layer. </P><DIV class="apropos"><P class="margin">Connect-Accept-Pairs</P><P></P></DIV><P>To define how a physical connection is initialized, a pair consisting of a connection and an accept procedure can be customly defined. The accept procedure defines how a site accepts incoming requests for connections and runs locally at that specific site. The connection and accept procedure must agree on a scheme to establish a connection, and the connection procedure should in the future be possible to pass around with any reference to the site. Currently an application programmer can create a custom pair and manually install it in all processes involved in a distributed application. This will create a subdomain only accessible to those processes. </P><DIV class="apropos"><P class="margin">Transport Modules</P><P></P></DIV><P>A transport module is responsible of delivering messages from one site to another. It may be a very lean layer interfacing TCP or contain a complete implementation of a new transport protocol. </P><H2><A name="label6">2.3 Automatic Connection Opening and Closing</A></H2><P>For efficiency reasons, physical connections should be open while there is a need for them from at least one end, and there are enough resources to maintain them. To achieve this, connections are automatically established when the need arises and closed when the need no longer remains. The latter part is handled by the garbage collector; once the last reference is garbage collected locally, the connection will be closed. When resources are low, connections will be taken down temporarily. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.entities">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.sics.se/~erik">Erik&nbsp;Klintskog</A> and&nbsp;<A href="http://www.sics.se/~annan">Anna&nbsp;Neiderud</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
