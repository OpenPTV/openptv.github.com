<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Entities and Protocols - a Background</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.connections">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.efficient">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.entities"><H1><A name="chapter.entities">3 Entities and Protocols - a Background</A></H1><P>Distribution in Mozart is realized by sharing language entities. How this is done depends on if they are stateless or stateful. Stateless entities are replicated between sites whereas stateful entities create access structures. The local semantics of the stateful entities are maintained in a distributed setting by a number of consistency protocols. </P><P>Mozart entities may be in one of two states: plain or globalized. A plain entity is only referenced within its virtual machine. This virtual machine is called the entity's home site. A plain entity will become globalized at the instance when a reference to it is shared. A globalized entity is returned to being plain when no more remote references exist; this is called localization. </P><P>The Distribution Subsystem offers four kinds of distribution behavior and four kinds of replication patterns. Distribution behavior and replication patterns are paired together to create different distribution semantics. Each entity type in Mozart has been assigned a pair to define its distributed semantics and behavior. </P><H2><A name="label7">3.1 Distribution of References</A></H2><P>At globalization an entity is given a globally unique identity (GUId). This name is used to identify imported references, to see if a copy of the entity already exists at the importing site. The GUId consists of a reference to the home site and an identifier that is unique at the home site. </P><P>When entities are transferred from one site to another five kinds of replication patterns exist. The importing site is responsible for building a structure according to the replication pattern. The five patterns are described here: </P><DIV class="apropos"><P class="margin">Replicated</P><P></P></DIV><P>Replicated entities do not have a GUId. Instead enough information is transferred at distribution time to enable the importer to build a complete copy of the data structure. Without a GUId it is not possible to determine whether the entity already exists at the importing site or not. </P><DIV class="apropos"><P class="margin">Replicated Uniquely</P><P></P></DIV><P>An entity that is Replicated Uniquely transfers enough information to build a complete replica of it at the importing site. In contrast to Replicated entities, Replicated Uniquely entities have a GUId that enables the importer to make sure that there may exist one and only one instance of the entity at the importing site. </P><DIV class="apropos"><P class="margin">Access Structure </P><P></P></DIV><P> When a stateful entity is globalized, a Manager is constructed at its home site. References to the the entity imported at other sites result in the construction of proxies pointing to the manager (see <A href="node3.html#figure.proxy_manager">Figure&nbsp;3.1</A>). This structure is called an access structure. The GUId of the entity is used to ensure that one and only one proxy is built at site that imports references to the entity. </P><DIV id="figure.proxy_manager"><HR><P><A name="figure.proxy_manager"></A></P><DIV align="center"><IMG alt="" src="proxy_manager.gif"></DIV><P class="caption"><STRONG>Figure&nbsp;3.1:</STRONG> A Proxy at site A refers to its Manager at site B</P><HR></DIV><P> </P><P>Access structures are used to maintain reference consistency and as a base for the consistency protocols described below. </P><DIV class="apropos"><P class="margin">Lazy Replication </P><P> </P></DIV><P>Lazy Replication is a special case of Replicated Uniquely. Instead of sending the whole value of the entity the possibility to build an access structure is transferred. If no instance of the entity exists at the importer, the access structure is built. When a Lazy Replicated entity is accessed for the first time the value of the entity is requested and the access structure is removed when the value arrives. </P><DIV class="apropos"><P class="margin">Resource Placeholder </P><P> </P></DIV><P>Some data structures should not be available remotely. This is handled by replacing those entities with a placeholder on which no operations can be performed except equality. This placeholder is reflected to language level as a Resource. </P><H2><A name="label8">3.2 Consistency Protocols</A></H2><P>As stated earlier, the DS uses consistency protocols to maintain the semantics of a plain entity also when it has been globalized. Note that this is of course not necessary for replicated stateless entities. </P><P>Stateful entities can have a real state or be single assignment, where single assignment means transforming into another entity once. This is used to implement distributed logic variables. Single assignment entities can be dealt with efficiently by a proxy-manager structure where the manager knows and notifies its proxies. Other stateful entities may implement distribution by letting their state move around to active proxies or by letting a manager act as a server for read and write requests. This gives us with three different protocols for maintaining entity semantics: </P><DIV class="apropos"><P class="margin">Stationary State</P><P> The manager maintains the state of a stateful entity locally, and proxies send read and write requests asynchronously to access the state. </P></DIV><DIV class="apropos"><P class="margin">Mobile State</P><P> Any proxy can attract the state of a stateful entity and operate on it locally as on a plain entity while the state is present. </P></DIV><DIV class="apropos"><P class="margin">Single Assignment</P><P> The manager knows all of its proxies and can administer any request to transform the entity to a reference to another entity, and forward this to all proxies. </P></DIV><H2><A name="label9">3.3 Distribution of Mozart Entities</A></H2><P><A href="node3.html#data-types-dist">Table&nbsp;3.1</A> shows the class of reference distribution and the consistency protocol used for entities in Mozart. </P><DIV class="table" id="data-types-dist"><HR><P><A name="data-types-dist"></A></P></DIV><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>Entity Type </P></TH><TH><P>Reference Distribution </P></TH><TH><P>Consistency Protocol </P></TH></TR><TR valign="top"><TD><P>Port </P></TD><TD><P>Access Structure </P></TD><TD><P>Stationary </P></TD></TR><TR valign="top"><TD><P>Variable </P></TD><TD><P>Access Structure </P></TD><TD><P>Single assignment </P></TD></TR><TR valign="top"><TD><P>Cell </P></TD><TD><P>Access Structure </P></TD><TD><P>Mobile state </P></TD></TR><TR valign="top"><TD><P>Lock </P></TD><TD><P>Access Structure </P></TD><TD><P>Mobile state </P></TD></TR><TR valign="top"><TD><P>Object </P></TD><TD><P>Lazy Replication </P></TD><TD><P>Mobile state </P></TD></TR><TR valign="top"><TD><P>Record </P></TD><TD><P>Replicated </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Atoms </P></TD><TD><P>Replicated </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>List </P></TD><TD><P>Replicated </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Chunk </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Name </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Class </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Functor </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Procedure </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Code </P></TD><TD><P>Replicated Unique </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Dictionary </P></TD><TD><P>Resource Placeholder </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Array </P></TD><TD><P>Resource Placeholder </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Sited Entities</P></TD><TD><P>Resource Placeholder </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Builtin </P></TD><TD><P>Resource Placeholder </P></TD><TD><P>none needed </P></TD></TR><TR valign="top"><TD><P>Constraint Variable </P></TD><TD><P>Resource Placeholder </P></TD><TD><P>none needed </P></TD></TR></TABLE><DIV class="table"><P class="caption"><STRONG>Table&nbsp;3.1.</STRONG></P><HR></DIV><P></P><H2><A name="label10">3.4  Distributed Memory Management</A></H2><P>Every Mozart site performs garbage collection locally. During this process all replicated entities and proxies are treated as plain Mozart data structures. Managers on the other hand act as roots for the local garbage collector. </P><P>To ensure that globalized entities are localized if and only if no more remote references exist, the DS has a distributed reference consistency algorithm. This is currently implemented by an extended version of Weighted Reference Counting<A href="node3.html#label11"><SUP>1</SUP></A> called Secondary Weight. Weighted Reference Counting is an algorithm that assigns a total weight to an entity. When references are shared, a part of this weight is shared too. When all weight is present at the manager, the entity is local. The original algorithm has a problem in that weight is limited. Secondary Weight overcomes that problem, by allowing proxies to create a new range of weight that they manage. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.connections">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.efficient">Next &gt;&gt;</A></TD></TR></TABLE><HR align="left" width="30%"><DIV class="footnote"><A name="label11">1. </A>Presented independently by D I Bevan in <EM>Distributed Garbage Collection Using Reference Counting</EM>,1987, and Watson and Watson in <EM>An Efficient Garbage Collection Scheme for Parallel Computer Architecture</EM>, 1987.</DIV><HR><ADDRESS><A href="http://www.sics.se/~erik">Erik&nbsp;Klintskog</A> and&nbsp;<A href="http://www.sics.se/~annan">Anna&nbsp;Neiderud</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
