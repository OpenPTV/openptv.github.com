<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Lexical Syntax</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.intro">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.context-free">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.lexical"><H1><A name="chapter.lexical">2 Lexical Syntax</A></H1><P> A <EM>program text</EM> is a sequence of <EM>characters</EM> represented by integers following ISO&nbsp;8859-1&nbsp;<A href="bib.html#iso_8859_1">[ISO87]</A>, also called ``Latin&nbsp;1''. In this section, we describe how such a sequence is split into a sequence of <EM>words</EM>. Each word represents zero or more <EM>tokens</EM> such that the result is a sequence of tokens. We call this process <EM>tokenization</EM>. In this section, we give regular expressions for the different kinds of words and describe the resulting tokens. </P><DIV class="apropos"><P class="margin">Resolving Ambiguities</P><P> The splitting of a sequence of characters using these regular expressions is not unique. We use the usual left to right longest match tokenization obtaining either error or a unique sequence of tokens from a given sequence of characters. Longest match means that if two or more prefixes of the remaining character string are matched by (possibly different) regular expressions, we select the match that accepts the longest prefix. Note that the regular expressions are designed such that left to right longest match tokenization is unique. </P></DIV><DIV class="apropos"><P class="margin">Lexical Errors</P><P> When no regular expression matches a prefix of the remaining character string, we speak of a <EM>lexical error</EM>. Such an input sequence does not represent a valid Oz program. </P></DIV><H2><A name="label4">2.1 Character Class Definitions</A></H2><P> This section defines character classes used in the regular expressions given in the remainder of the chapter. Note that these regular expressions do not - on their own - define any splitting of the input into words. </P><P> We use NUL to denote the ISO character with code&nbsp;0 and &lt;<I>any character</I>&gt; to denote the set of all ISO characters. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>upper-case letter</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>A</CODE> | ... | <CODE>Z</CODE> | <CODE>À</CODE> | ... | <CODE>Ö</CODE> | <CODE>Ø</CODE> | ... | <CODE>Þ</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>lower-case letter</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>a</CODE> | ... | <CODE>z</CODE> | <CODE>ß</CODE> | ... | <CODE>ö</CODE> | <CODE>ø</CODE> | ... | <CODE>ÿ</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>digit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>0</CODE> | ... | <CODE>9</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>non-zero digit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>1</CODE> | ... | <CODE>9</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>alphanumerical</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>upper-case letter</I>&gt; | &lt;<I>lower-case letter</I>&gt; | &lt;<I>digit</I>&gt; | <CODE>_</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>atom char</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>any character</I>&gt; - ( <CODE>'</CODE> | <CODE>\</CODE> | NUL )</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>string char</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>any character</I>&gt; - ( <CODE><SPAN class="string">&quot;</SPAN></CODE> | <CODE>\</CODE> | NUL )</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>variable char</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>any character</I>&gt; - ( <CODE>`</CODE> | <CODE>\</CODE> | NUL )</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>escape character</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>a</CODE> | <CODE>b</CODE> | <CODE>f</CODE> | <CODE>n</CODE> | <CODE>r</CODE> | <CODE>t</CODE> | <CODE>v</CODE> | <CODE>\</CODE> | <CODE>'</CODE> | <CODE><SPAN class="string">&quot;</SPAN></CODE> | <CODE>`</CODE> | <CODE>&amp;</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>octal digit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>0</CODE> | ... | <CODE>7</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>hex digit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>0</CODE> | ... | <CODE>9</CODE> | <CODE>A</CODE> | ... | <CODE>F</CODE> | <CODE>a</CODE> | ... | <CODE>f</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>binary digit</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>0</CODE> | <CODE>1</CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Pseudo-Characters</P><P> In the classes of words &lt;<I>variable</I>&gt;, &lt;<I>atom</I>&gt;, &lt;<I>string</I>&gt;, and &lt;<I>character</I>&gt; we use pseudo-characters, which represent single characters in different notations. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>pseudo char</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>\</CODE> &lt;<I>octal digit</I>&gt; &lt;<I>octal digit</I>&gt; &lt;<I>octal digit</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>\</CODE> ( <CODE>x</CODE> | <CODE>X</CODE> ) &lt;<I>hex digit</I>&gt; &lt;<I>hex digit</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>\</CODE> &lt;<I>escape character</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> Pseudo-characters allow to enter any ISO&nbsp;8859-1 character using octal or hexadecimal notation. Octal notation is restricted to numbers less than 256. The NUL character (ISO code&nbsp;0) is forbidden. The pseudo-characters <CODE>\a</CODE>&nbsp;(=&nbsp;<CODE>\007</CODE>), <CODE>\b</CODE>&nbsp;(=&nbsp;<CODE>\010</CODE>), <CODE>\f</CODE>&nbsp;(=&nbsp;<CODE>\014</CODE>), <CODE>\n</CODE>&nbsp;(=&nbsp;<CODE>\012</CODE>), <CODE>\r</CODE>&nbsp;(=&nbsp;<CODE>\015</CODE>), <CODE>\t</CODE>&nbsp;(=&nbsp;<CODE>\011</CODE>), <CODE>\v</CODE>&nbsp;(=&nbsp;<CODE>\013</CODE>) denote special purpose characters, and <CODE>\\</CODE>&nbsp;(=&nbsp;<CODE>\134</CODE>), <CODE>\'</CODE>&nbsp;(=&nbsp;<CODE>\047</CODE>), <CODE>\&quot;</CODE>&nbsp;(=&nbsp;<CODE>\042</CODE>), <CODE>\`</CODE>&nbsp;(=&nbsp;<CODE>\140</CODE>), <CODE>\&amp;</CODE>&nbsp;(=&nbsp;<CODE>\046</CODE>) denote their second component character. </P></DIV><H2><A name="label5">2.2 Spaces and Comments</A></H2><P> Spaces are tab (code&nbsp;9), newline (code&nbsp;10), vertical tab (code&nbsp;11), form feed (code&nbsp;12), carriage return (code&nbsp;13), and blank (code&nbsp;32). </P><P> A comment is: </P><UL><LI><P>a sequence of characters from&nbsp;<CODE>%</CODE> until the end of the line or file, </P></LI><LI><P>a sequence of characters within and including the comment brackets <CODE>/*</CODE> and&nbsp;<CODE>*/</CODE>, in which <CODE>/*</CODE> and&nbsp;<CODE>*/</CODE> are properly nested, and </P></LI><LI><P>the character&nbsp;<CODE>?</CODE>. </P></LI></UL><P> </P><P> Spaces and comments produce no tokens. This means that they are ignored, except that they separate words form each other. </P><H2><A name="label6">2.3 Keywords</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>keyword</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">andthen</SPAN></CODE> | <CODE><SPAN class="keyword">at</SPAN></CODE> | <CODE><SPAN class="keyword">attr</SPAN></CODE> | <CODE><SPAN class="keyword">case</SPAN></CODE> | <CODE><SPAN class="keyword">catch</SPAN></CODE> | <CODE><SPAN class="keyword">choice</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">class</SPAN></CODE> | <CODE><SPAN class="keyword">cond</SPAN></CODE> | <CODE><SPAN class="keyword">declare</SPAN></CODE> | <CODE><SPAN class="keyword">define</SPAN></CODE> | <CODE><SPAN class="keyword">dis</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">div</SPAN></CODE> | <CODE><SPAN class="keyword">else</SPAN></CODE> | <CODE><SPAN class="keyword">elsecase</SPAN></CODE> | <CODE><SPAN class="keyword">elseif</SPAN></CODE> | <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">export</SPAN></CODE> | <CODE><SPAN class="keyword">fail</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE> | <CODE><SPAN class="keyword">feat</SPAN></CODE> | <CODE><SPAN class="keyword">finally</SPAN></CODE> | <CODE><SPAN class="keyword">from</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">fun</SPAN></CODE> | <CODE><SPAN class="keyword">functor</SPAN></CODE> | <CODE><SPAN class="keyword">if</SPAN></CODE> | <CODE><SPAN class="keyword">import</SPAN></CODE> | <CODE><SPAN class="keyword">in</SPAN></CODE> | <CODE><SPAN class="keyword">local</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">lock</SPAN></CODE> | <CODE><SPAN class="keyword">meth</SPAN></CODE> | <CODE><SPAN class="keyword">mod</SPAN></CODE> | <CODE><SPAN class="keyword">not</SPAN></CODE> | <CODE><SPAN class="keyword">of</SPAN></CODE> | <CODE><SPAN class="keyword">or</SPAN></CODE> | <CODE><SPAN class="keyword">orelse</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">prepare</SPAN></CODE> | <CODE><SPAN class="keyword">proc</SPAN></CODE> | <CODE><SPAN class="keyword">prop</SPAN></CODE> | <CODE><SPAN class="keyword">raise</SPAN></CODE> | <CODE><SPAN class="keyword">require</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">self</SPAN></CODE> | <CODE><SPAN class="keyword">skip</SPAN></CODE> | <CODE><SPAN class="keyword">then</SPAN></CODE> | <CODE><SPAN class="keyword">thread</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">try</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE>(</CODE> | <CODE>)</CODE> | <CODE>[</CODE> | <CODE>]</CODE> | <CODE>{</CODE> | <CODE>}</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">|</SPAN></CODE> | <CODE><SPAN class="keyword">#</SPAN></CODE> | <CODE>:</CODE> | <CODE><SPAN class="keyword">...</SPAN></CODE> | <CODE>=</CODE> | <CODE><SPAN class="keyword">.</SPAN></CODE> | <CODE><SPAN class="keyword">:=</SPAN></CODE> | <CODE>^</CODE> | <CODE><SPAN class="keyword">[]</SPAN></CODE> | <CODE>$</CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">!</SPAN></CODE> | <CODE>_</CODE> | <CODE><SPAN class="keyword">~</SPAN></CODE> | <CODE><SPAN class="keyword">+</SPAN></CODE> | <CODE><SPAN class="keyword">-</SPAN></CODE> | <CODE><SPAN class="keyword">*</SPAN></CODE> | <CODE><SPAN class="keyword">/</SPAN></CODE> | <CODE><SPAN class="keyword">@</SPAN></CODE> | <CODE><SPAN class="keyword">&lt;-</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">,</SPAN></CODE> | <CODE><SPAN class="keyword">!!</SPAN></CODE> | <CODE><SPAN class="keyword">&lt;=</SPAN></CODE> | <CODE><SPAN class="keyword">==</SPAN></CODE> | <CODE><SPAN class="keyword">\=</SPAN></CODE> | <CODE><SPAN class="keyword">&lt;</SPAN></CODE> | <CODE><SPAN class="keyword">=&lt;</SPAN></CODE> | <CODE><SPAN class="keyword">&gt;</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">&gt;=</SPAN></CODE> | <CODE><SPAN class="keyword">=:</SPAN></CODE> | <CODE><SPAN class="keyword">\=:</SPAN></CODE> | <CODE><SPAN class="keyword">&lt;:</SPAN></CODE> | <CODE><SPAN class="keyword">=&lt;:</SPAN></CODE> | <CODE><SPAN class="keyword">&gt;:</SPAN></CODE> | <CODE><SPAN class="keyword">&gt;=:</SPAN></CODE> | <CODE><SPAN class="keyword">::</SPAN></CODE> | <CODE><SPAN class="keyword">:::</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P>Each keyword represents itself as token. </P><H2><A name="label7">2.4 Variables</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>variable</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>upper-case letter</I>&gt; { &lt;<I>alphanumerical</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>`</CODE> { &lt;<I>variable char</I>&gt; | &lt;<I>pseudo char</I>&gt; } <CODE>`</CODE></TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>variable</I>&gt; represents a variable token of the form <IMG alt="\lfloor" src="latex5.png"><CODE>variable</CODE>, <I>n</I>+<IMG alt="\rfloor" src="latex6.png">, where <I>n</I>+ is the sequence of characters that make up the word, including the possibly surrounding <CODE>`</CODE>&nbsp;characters. </P><P> For example, the word <CODE>Xs</CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>variable</CODE>, 88 115<IMG alt="\rfloor" src="latex6.png"> and the word <CODE><SPAN class="string">`\n`</SPAN></CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>variable</CODE>, 96 10 96<IMG alt="\rfloor" src="latex6.png">. Variable tokens are denoted by the terminal symbol &lt;<I>variable</I>&gt; in the following context-free grammars. </P><H2><A name="label8">2.5 Atoms</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>atom</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>lower-case letter</I>&gt; { &lt;<I>alphanumerical</I>&gt; } - &lt;<I>keyword</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE>'</CODE> { &lt;<I>atom char</I>&gt; | &lt;<I>pseudo char</I>&gt; } <CODE>'</CODE></TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>atom</I>&gt; represents an atom token of the form <IMG alt="\lfloor" src="latex5.png"><CODE>atom</CODE>, <I>n</I>*<IMG alt="\rfloor" src="latex6.png">, where <I>n</I>* is the sequence of characters that make up the word, excluding the possibly surrounding <CODE>'</CODE>&nbsp;characters. </P><P> For example, the word <CODE>atom</CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>atom</CODE>, 97 116 111 109<IMG alt="\rfloor" src="latex6.png"> and the word <CODE><SPAN class="string">'\n'</SPAN></CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>atom</CODE>, 10<IMG alt="\rfloor" src="latex6.png">. Atom tokens are denoted by the terminal symbol &lt;<I>atom</I>&gt; in the following context-free grammars. </P><H2><A name="label9">2.6 Labels</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>( &lt;<I>variable</I>&gt; | &lt;<I>atom</I>&gt; | <CODE>true</CODE> | <CODE>false</CODE> | <CODE>unit</CODE> ) <CODE>(</CODE></TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>label</I>&gt; represents a sequence of two tokens. The first is a label token of the form <IMG alt="\lfloor" src="latex5.png"><CODE>variablelabel</CODE>, <I>n</I>+<IMG alt="\rfloor" src="latex6.png">, <IMG alt="\lfloor" src="latex5.png"><CODE>atomlabel</CODE>, <I>n</I>*<IMG alt="\rfloor" src="latex6.png"> (similar to the corresponding tokens for words of the form &lt;<I>variable</I>&gt; and &lt;<I>atom</I>&gt;), <CODE>truelabel</CODE>, <CODE>falselabel</CODE>, or <CODE>unitlabel</CODE>. The second token is the keyword&nbsp;<CODE>(</CODE>. For example, the word <CODE>Xs(</CODE> represents the tokens <IMG alt="\lfloor" src="latex5.png"><CODE>variablelabel</CODE>, 88 115<IMG alt="\rfloor" src="latex6.png"> and&nbsp;<CODE>(</CODE>, and the word <CODE><SPAN class="keyword">true</SPAN>(</CODE> represents the tokens <CODE>truelabel</CODE> and&nbsp;<CODE>(</CODE>. The label tokens are denoted by the terminal symbols &lt;<I>variable label</I>&gt;, &lt;<I>atom label</I>&gt;, &lt;<I>unit label</I>&gt;, &lt;<I>true label</I>&gt;, and &lt;<I>false label</I>&gt; in the following context-free grammars. </P><H2><A name="label10">2.7 Integers</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>int</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <CODE>~</CODE> ] ( <CODE>0</CODE> | &lt;<I>non-zero digit</I>&gt; { &lt;<I>digit</I>&gt; } ) </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% decimal representation</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>[ <CODE>~</CODE> ] <CODE>0</CODE> { &lt;<I>octal digit</I>&gt; }+ </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% octal representation</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>[ <CODE>~</CODE> ] <CODE>0</CODE> ( <CODE>x</CODE> | <CODE>X</CODE> ) { &lt;<I>hex digit</I>&gt; }+ </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% hexadecimal representation</I></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>[ <CODE>~</CODE> ] <CODE>0</CODE> ( <CODE>b</CODE> | <CODE>B</CODE> ) { &lt;<I>binary digit</I>&gt; }+ </TD><TD align="left"><I>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;% binary representation</I></TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>int</I>&gt; represents an integer token of the form <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, <I>n</I><IMG alt="\rfloor" src="latex6.png">, where <I>n</I> represents the integer for which &lt;<I>int</I>&gt; is the representation. </P><P> For example, the word <CODE><SPAN class="keyword">~</SPAN>159</CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, -159<IMG alt="\rfloor" src="latex6.png">, the word <CODE>077</CODE> the token <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, 63<IMG alt="\rfloor" src="latex6.png">, the word <CODE>0xFF</CODE> the token <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, 255<IMG alt="\rfloor" src="latex6.png">, and the word <CODE><SPAN class="keyword">~</SPAN>0b11111</CODE> the token <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, -31<IMG alt="\rfloor" src="latex6.png">. Integer tokens are denoted by the terminal symbol &lt;<I>int</I>&gt; in the following context-free grammars. </P><H2><A name="label11">2.8 Floats</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>float</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <CODE>~</CODE> ] { &lt;<I>digit</I>&gt; }+ <CODE>.</CODE> { &lt;<I>digit</I>&gt; } [ ( <CODE>e</CODE> | <CODE>E</CODE> ) [ <CODE>~</CODE> ] { &lt;<I>digit</I>&gt; }+ ]</TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>float</I>&gt; represents a float token of the form <IMG alt="\lfloor" src="latex5.png"><CODE>float</CODE>, <I>f</I><IMG alt="\rfloor" src="latex6.png">, where <I>f</I> represents the floating point number for which the word is the decimal representation. The letters <CODE>e</CODE> and <CODE>E</CODE> both indicate the exponent to&nbsp;10. </P><P> For example, the word <CODE><SPAN class="keyword">~</SPAN>1<SPAN class="keyword">.</SPAN>5e2</CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>float</CODE>, -150.0<IMG alt="\rfloor" src="latex6.png">. Float tokens are denoted by the terminal symbol &lt;<I>float</I>&gt; in the following context-free grammars. </P><P> The syntax of floats is implementation-dependent in that syntactically correct floats may be approximated by the compiler if they cannot be represented by the implementation. </P><H2><A name="label12">2.9 Strings</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>string</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="string">&quot;</SPAN></CODE> { &lt;<I>string char</I>&gt; | &lt;<I>pseudo char</I>&gt; } <CODE><SPAN class="string">&quot;</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> The word <CODE><SPAN class="string">&quot;&quot;</SPAN></CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>atom</CODE>, 110 105 108<IMG alt="\rfloor" src="latex6.png">, which denotes the empty list <CODE>nil</CODE>. A word of the form <CODE><SPAN class="string">&quot;</SPAN></CODE><IMG alt="c_1" src="latex7.png"> ... <IMG alt="c_m" src="latex8.png"><CODE><SPAN class="string">&quot;</SPAN></CODE>, where <IMG alt="m \geq 1" src="latex9.png">, represents a sequence of <IMG alt="m + 2" src="latex10.png"> tokens of the form <CODE>[</CODE>&nbsp;<IMG alt="n_1" src="latex11.png"> ... <IMG alt="n_m" src="latex12.png">&nbsp;<CODE>]</CODE>, where the <IMG alt="n_i" src="latex13.png"> represent integer tokens according to the ISO&nbsp;8859-1 code of&nbsp;<IMG alt="c_i" src="latex14.png">. </P><P> For example, the word <CODE><SPAN class="string">&quot;ab&quot;</SPAN></CODE> represents the sequence of tokens <CODE>[</CODE>&nbsp;<IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, 97<IMG alt="\rfloor" src="latex6.png"> <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, 98<IMG alt="\rfloor" src="latex6.png">&nbsp;<CODE>]</CODE>. </P><H2><A name="label13">2.10 Characters</A></H2><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>character</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE>&amp;</CODE> ( &lt;<I>any character</I>&gt; - ( <CODE>\</CODE> | NUL ) | &lt;<I>pseudo char</I>&gt; )</TD></TR></TABLE></BLOCKQUOTE><P> A word of the form &lt;<I>character</I>&gt; represents the integer token according to the code of the character denoted by the word without the <CODE>&amp;</CODE>&nbsp;prefix. </P><P> For example, the word <CODE><SPAN class="string">&amp;a</SPAN></CODE> represents the token <IMG alt="\lfloor" src="latex5.png"><CODE>int</CODE>, 97<IMG alt="\rfloor" src="latex6.png">. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.intro">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node3.html#chapter.context-free">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.iscs.nus.edu.sg/~henz">Martin&nbsp;Henz</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
