<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>3 Context-Free Syntax</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.lexical">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.core">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.context-free"><H1><A name="chapter.context-free">3 Context-Free Syntax</A></H1><P> In this section, we give a context-free grammar for a superset of Oz programs. Any sequence of tokens that is not a member of the language described by this grammar, starting from the &lt;<I>statement</I>&gt; nonterminal, is considered erroneous. </P><P> Implementations may accept a larger language, e.&nbsp;g., something more than only a statement at top-level, or treat lexical syntax that has no assigned meaning in the report as compiler directives. </P><H2><A name="label14">3.1 The Base Language</A></H2><DIV class="apropos"><P class="margin">Statements</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>statement</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>statement</I>&gt; &lt;<I>statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">local</SPAN></CODE> &lt;<I>in statement</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> &lt;<I>in statement</I>&gt; <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">proc</SPAN></CODE> { &lt;<I>atom</I>&gt; } <SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; { &lt;<I>pattern</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>in phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">fun</SPAN></CODE> { &lt;<I>atom</I>&gt; } <SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; { &lt;<I>pattern</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>in expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; { &lt;<I>expression</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">if</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">case</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">of</SPAN></CODE> &lt;<I>case statement clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <CODE><SPAN class="keyword">[]</SPAN></CODE> &lt;<I>case statement clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">lock</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">thread</SPAN></CODE> &lt;<I>in statement</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">try</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">catch</SPAN></CODE> &lt;<I>case statement clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>case statement clause</I>&gt; } ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">finally</SPAN></CODE> &lt;<I>in statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">raise</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE>=</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">skip</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Expressions</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>expression</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">local</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> &lt;<I>in expression</I>&gt; <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">proc</SPAN></CODE> { &lt;<I>atom</I>&gt; } <SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> <SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN> { &lt;<I>pattern</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>in phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">fun</SPAN></CODE> { &lt;<I>atom</I>&gt; } <SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> <SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN> { &lt;<I>pattern</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>in expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>{</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; { &lt;<I>expression</I>&gt; } <SPAN class="terminal">&quot;<CODE>}</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">if</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>else expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">case</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">of</SPAN></CODE> &lt;<I>case expression clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <CODE><SPAN class="keyword">[]</SPAN></CODE> &lt;<I>case expression clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else expression</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">lock</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">thread</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">try</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">catch</SPAN></CODE> &lt;<I>case expression clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>case expression clause</I>&gt; } ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">finally</SPAN></CODE> &lt;<I>in statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">raise</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE>=</CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">orelse</SPAN></CODE> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">andthen</SPAN></CODE> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>monop</I>&gt; &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; &lt;<I>binop</I>&gt; &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>possibly escaped variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>_</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt; | &lt;<I>float</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>label</I>&gt; <SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> { &lt;<I>subtree</I>&gt; } [ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">...</SPAN></CODE>&quot;</SPAN> ] <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>[</CODE>&quot;</SPAN> { &lt;<I>expression</I>&gt; }+ <SPAN class="terminal">&quot;<CODE>]</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">|</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">#</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable label</I>&gt; | &lt;<I>atom label</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>unit label</I>&gt; | &lt;<I>true label</I>&gt; | &lt;<I>false label</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>feature</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt; | &lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>subtree</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>feature</I>&gt; <SPAN class="terminal">&quot;<CODE>:</CODE>&quot;</SPAN> ] &lt;<I>expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Precedence</P><P> Note that in both &lt;<I>statement</I>&gt;s and &lt;<I>expression</I>&gt;s there is potential ambiguity between &lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; and &lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;. In fact <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN>&nbsp;<SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> is a ternary operator and has precedence. Parenthesis must be used for the alternate parse, that is, (&lt;<I>expression</I>&gt;<SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN></CODE>&quot;</SPAN>&lt;<I>expression</I>&gt;) <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;. </P></DIV><P> The assignment operators <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN>&nbsp;<SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> and <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN>, when used in expression position, perform an atomic exchange, the result of the operation being the previous value of the stateful entity assigned to. </P><DIV class="apropos"><P class="margin">Operators</P><P> Expressions with operators need additional disambiguating rules introduced in&nbsp;<A href="node3.html#section.context-free.operators">Section&nbsp;3.5</A>. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>monop</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE><SPAN class="keyword">~</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">!!</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">@</SPAN></CODE>&quot;</SPAN></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>binop</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE><SPAN class="keyword">.</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE>^</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE><SPAN class="keyword">==</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">\=</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">=&lt;</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&gt;</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&gt;=</SPAN></CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE><SPAN class="keyword">+</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">-</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">*</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">/</SPAN></CODE>&quot;</SPAN> | <CODE><SPAN class="keyword">div</SPAN></CODE> | <CODE><SPAN class="keyword">mod</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P></P></DIV><DIV class="apropos"><P class="margin">Declarations</P><P> A &lt;<I>declaration part</I>&gt; is a sequence of variables and statements. Singleton variables serve only for explicit declaration and are otherwise ignored. Variables within statements are implicitly declared if they occur at a <EM>pattern position</EM>. A prefixed escape&nbsp;(<CODE><SPAN class="keyword">!</SPAN></CODE>) prevents implicit declaration. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>declaration part</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>declaration part</I>&gt; &lt;<I>declaration part</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>in statement</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>statement</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>in expression</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] [ &lt;<I>statement</I>&gt; ] &lt;<I>expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>possibly escaped variable</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">!</SPAN></CODE>&quot;</SPAN> ] &lt;<I>variable</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><P> As procedure body either a statement or an expression may be possible, depending on whether the procedure's formal parameter patterns contain a nesting marker&nbsp;(<CODE>$</CODE>) or not. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>in phrase</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>in statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>in expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Patterns</P><P> Pattern matching is performed as a top-down left-to-right sequence of tests. Record patterns test a value's constructor; constant patterns and escaped variable patterns test for equality with the given value; nonlinearities (variables occurring multiply in one pattern) test for equality of the corresponding subtrees. Equation patterns and non-escaped variables introduce variable bindings. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>pattern</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>label</I>&gt; <SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> { &lt;<I>subpattern</I>&gt; } [ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">...</SPAN></CODE>&quot;</SPAN> ] <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>[</CODE>&quot;</SPAN> { &lt;<I>pattern</I>&gt; }+ <SPAN class="terminal">&quot;<CODE>]</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>pattern</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">|</SPAN></CODE>&quot;</SPAN> &lt;<I>pattern</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>pattern</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">#</SPAN></CODE>&quot;</SPAN> &lt;<I>pattern</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt; | &lt;<I>float</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>possibly escaped variable</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>_</CODE>&quot;</SPAN></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>pattern</I>&gt; <SPAN class="terminal">&quot;<CODE>=</CODE>&quot;</SPAN> &lt;<I>pattern</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> &lt;<I>pattern</I>&gt; <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>subpattern</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>feature</I>&gt; <SPAN class="terminal">&quot;<CODE>:</CODE>&quot;</SPAN> ] &lt;<I>pattern</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><P> Following the pattern an additional side condition can be given. It is only evaluated if the pattern matched, in the environment extended by the bindings introduced by the pattern. The variables introduced in the optional &lt;<I>declaration part</I>&gt; are also visible in the clause's body. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>case statement clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>pattern</I>&gt; [ <CODE><SPAN class="keyword">andthen</SPAN></CODE> [ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>expression</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>case expression clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>pattern</I>&gt; [ <CODE><SPAN class="keyword">andthen</SPAN></CODE> [ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>expression</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Else Clauses</P><P> If the <CODE><SPAN class="keyword">else</SPAN></CODE> part to an <CODE><SPAN class="keyword">if</SPAN></CODE> statement is omitted, it is taken to be <CODE><SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN></CODE>. The <CODE><SPAN class="keyword">else</SPAN></CODE> part to an <CODE><SPAN class="keyword">if</SPAN></CODE> expression is mandatory. </P></DIV><P> If the <CODE><SPAN class="keyword">else</SPAN></CODE> part to a <CODE><SPAN class="keyword">case</SPAN></CODE> statement or expression is omitted and no pattern matches, an error exception is raised. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>else statement</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">elseif</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">elsecase</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">of</SPAN></CODE> &lt;<I>case statement clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>case statement clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">else</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>else expression</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">elseif</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>else expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">elsecase</SPAN></CODE> &lt;<I>expression</I>&gt; <CODE><SPAN class="keyword">of</SPAN></CODE> &lt;<I>case expression clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>case expression clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ &lt;<I>else expression</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">else</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><H2><A name="label15">3.2 Constraint Extensions and Combinators</A></H2><DIV class="apropos"><P class="margin">Statements</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>statement</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD>&lt;<I>fd compare</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>fd in</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">fail</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">not</SPAN></CODE> &lt;<I>in statement</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">cond</SPAN></CODE> &lt;<I>cond statement clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>cond statement clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">else</SPAN></CODE> &lt;<I>in statement</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">or</SPAN></CODE> &lt;<I>dis statement clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>dis statement clause</I>&gt; }+ <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">dis</SPAN></CODE> &lt;<I>dis statement clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>dis statement clause</I>&gt; }+ <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">choice</SPAN></CODE> &lt;<I>in statement</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>in statement</I>&gt; } <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>cond statement clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>statement</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>dis statement clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>statement</I>&gt; [ <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in statement</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Expressions</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>expression</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD>&lt;<I>fd compare</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>fd in</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">fail</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">cond</SPAN></CODE> &lt;<I>cond expression clause</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>cond expression clause</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <CODE><SPAN class="keyword">else</SPAN></CODE> &lt;<I>in expression</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">or</SPAN></CODE> &lt;<I>cond expression clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>cond expression clause</I>&gt; }+ <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">dis</SPAN></CODE> &lt;<I>cond expression clause</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>cond expression clause</I>&gt; }+ <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">choice</SPAN></CODE> &lt;<I>in expression</I>&gt; { <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">[]</SPAN></CODE>&quot;</SPAN> &lt;<I>in expression</I>&gt; } <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>cond expression clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>declaration part</I>&gt; <CODE><SPAN class="keyword">in</SPAN></CODE> ] &lt;<I>statement</I>&gt; <CODE><SPAN class="keyword">then</SPAN></CODE> &lt;<I>in expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>fd compare</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>expression</I>&gt; ( <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">=:</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">\=:</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;:</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">=&lt;:</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&gt;:</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&gt;=:</SPAN></CODE>&quot;</SPAN> ) &lt;<I>expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>fd in</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>expression</I>&gt; ( <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">::</SPAN></CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:::</SPAN></CODE>&quot;</SPAN> ) &lt;<I>expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><H2><A name="label16">3.3 Class Extensions</A></H2><DIV class="apropos"><P class="margin">Class Definitions</P><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>statement</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">class</SPAN></CODE> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ &lt;<I>class descriptor</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ &lt;<I>method</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>expression</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">class</SPAN></CODE> [ <SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN> ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ &lt;<I>class descriptor</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>{ &lt;<I>method</I>&gt; }</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>class descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">from</SPAN></CODE> { &lt;<I>expression</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">prop</SPAN></CODE> { &lt;<I>expression</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">attr</SPAN></CODE> { &lt;<I>attr or feat</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">feat</SPAN></CODE> { &lt;<I>attr or feat</I>&gt; }+</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><P> Non-escaped variables are implicitly introduced with class scope, bound to new names. This allows to model private components. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>attr or feat</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">!</SPAN></CODE>&quot;</SPAN> ] &lt;<I>variable</I>&gt; | &lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Methods</P><P> The first-class message used to invoke a method can be referenced by appending <CODE>=</CODE>&nbsp;&lt;<I>variable</I>&gt; to the method head. This message does not contain defaulted arguments (see below) if they have not been explicitly given. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>method</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">meth</SPAN></CODE> &lt;<I>method head</I>&gt; [ <SPAN class="terminal">&quot;<CODE>=</CODE>&quot;</SPAN> &lt;<I>variable</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>&lt;<I>in phrase</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD><CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><P> If dots are given, any additional features are allowed in the first-class message; else, extraneous features cause an error exception to be raised. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>method head</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">!</SPAN></CODE>&quot;</SPAN> ] &lt;<I>variable</I>&gt; | &lt;<I>atom</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">unit</SPAN></CODE> | <CODE><SPAN class="keyword">true</SPAN></CODE> | <CODE><SPAN class="keyword">false</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>method head label</I>&gt; <SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> { &lt;<I>method formal</I>&gt; } [ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">...</SPAN></CODE>&quot;</SPAN> ] <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR></TABLE></BLOCKQUOTE><P></P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>method head label</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">!</SPAN></CODE>&quot;</SPAN> ] &lt;<I>variable label</I>&gt; | &lt;<I>atom label</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>unit label</I>&gt; | &lt;<I>true label</I>&gt; | &lt;<I>false label</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> </P><P> A default <CODE><SPAN class="keyword">&lt;=</SPAN></CODE> after a formal argument allows for the corresponding actual argument to be omitted from a first-class method. In this case, the default expression will be evaluated (inside the method) and the formal argument variable bound to the result. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>method formal</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ &lt;<I>feature</I>&gt; <SPAN class="terminal">&quot;<CODE>:</CODE>&quot;</SPAN> ] ( &lt;<I>variable</I>&gt; | <SPAN class="terminal">&quot;<CODE>_</CODE>&quot;</SPAN> | <SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN> )</TD></TR><TR valign="top"><TD></TD><TD align="center"></TD><TD>[ <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Operations</P><P> To the following operators, <CODE><SPAN class="keyword">self</SPAN></CODE> is an implicit operand. Their use is syntactically restricted to the body of method definitions. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>statement</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">lock</SPAN></CODE> &lt;<I>in statement</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;-</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">,</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> The assignment operators <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN>, <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;-</SPAN></CODE>&quot;</SPAN>, when used in an expression position, perform an atomic exchange, the result of the operation being the previous value of the attribute assigned to. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>expression</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">lock</SPAN></CODE> &lt;<I>in expression</I>&gt; <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE><SPAN class="keyword">@</SPAN></CODE>&quot;</SPAN>&lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">:=</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">&lt;-</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>expression</I>&gt; <SPAN class="terminal">&quot;<CODE><SPAN class="keyword">,</SPAN></CODE>&quot;</SPAN> &lt;<I>expression</I>&gt;</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">self</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><H2><A name="label17">3.4 Functor Extensions</A></H2><P> A functor definition creates a chunk with (at least) features <CODE><SPAN class="string">'import'</SPAN></CODE> and <CODE><SPAN class="string">'export'</SPAN></CODE> describing its interface and a feature <CODE>apply</CODE> containing a procedure mapping an import record to an export module. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>statement</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">functor</SPAN></CODE> &lt;<I>expression</I>&gt; { &lt;<I>functor descriptor</I>&gt; } <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>expression</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">functor</SPAN></CODE> [ <SPAN class="terminal">&quot;<CODE>$</CODE>&quot;</SPAN> ] { &lt;<I>functor descriptor</I>&gt; } <CODE><SPAN class="keyword">end</SPAN></CODE></TD></TR></TABLE></BLOCKQUOTE><P> </P><DIV class="apropos"><P class="margin">Import Specification</P><P> The import specification names values (usually modules) to be made available to the body. They represent formal arguments to the body abstraction. The additional <CODE><SPAN class="keyword">at</SPAN></CODE> clause allows to specify where the actual argument is to come from. This must be an atom (interpreted as a relative URL) so that a functor creating the referenced module may be located at compile time. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>functor descriptor</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><CODE><SPAN class="keyword">import</SPAN></CODE> { &lt;<I>import clause</I>&gt; }+</TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>import clause</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>variable</I>&gt; [ <CODE><SPAN class="keyword">at</SPAN></CODE> &lt;<I>atom</I>&gt; ]</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD>&lt;<I>variable label</I>&gt; &lt;<I>import features</I>&gt; [ <CODE><SPAN class="keyword">at</SPAN></CODE> &lt;<I>atom</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> If the expected structure of an imported value is partially specified, occurrences of the module name are restricted to a single syntactic context: the first operand in applications of the dot operator, where the second operand is one of the features mentioned in the import specification. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>import features</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD><SPAN class="terminal">&quot;<CODE>(</CODE>&quot;</SPAN> { &lt;<I>module feature</I>&gt; &lt;<I>import alias</I>&gt; }+ <SPAN class="terminal">&quot;<CODE>)</CODE>&quot;</SPAN></TD></TR></TABLE></BLOCKQUOTE><P> </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>module feature</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>&lt;<I>atom</I>&gt; | &lt;<I>int</I>&gt;</TD></TR></TABLE></BLOCKQUOTE><P> An <EM>import alias</EM> introduces a variable bound to one of the imported module's subtrees. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>import alias</I>&gt;</TD><TD align="center">&nbsp;::=&nbsp;</TD><TD>[ <SPAN class="terminal">&quot;<CODE>:</CODE>&quot;</SPAN> &lt;<I>variable</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Functor Body</P><P> The body of the functor is a statement (usually a sequence of definitions that compute the exported values). This statement is a pattern position. Note the difference between this abbreviated declaration and the &lt;<I>in statement</I>&gt; rule: The &lt;<I>statement</I>&gt; following the <CODE><SPAN class="keyword">in</SPAN></CODE> keyword is optional, not the &lt;<I>declaration part</I>&gt; preceding it. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>functor descriptor</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">define</SPAN></CODE> &lt;<I>declaration part</I>&gt; [ <CODE><SPAN class="keyword">in</SPAN></CODE> &lt;<I>statement</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV class="apropos"><P class="margin">Export Specification</P><P> The export specification specifies the structure the modules created by applications of this functor will have. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>functor descriptor</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">export</SPAN></CODE> { [ &lt;<I>module feature</I>&gt; <SPAN class="terminal">&quot;<CODE>:</CODE>&quot;</SPAN> ] &lt;<I>variable</I>&gt; }+</TD></TR></TABLE></BLOCKQUOTE><P> The value of the variables mentioned in the export declaration are made available under the given features. If a feature is omitted, then it is computed from the corresponding variable's print name by changing its initial capital letter into a lower-case letter (unless it's a backquote variable, in which case the print name is taken as-is). </P></DIV><P> All variables introduced in the import and the body are visible in the export declaration. </P><DIV class="apropos"><P class="margin">Computed Functors</P><P> A functor that contains one of the following additional functor descriptors is called a <EM>computed functor</EM>. The <CODE><SPAN class="keyword">require</SPAN></CODE> and <CODE><SPAN class="keyword">prepare</SPAN></CODE> clauses correspond to the <CODE><SPAN class="keyword">import</SPAN></CODE> and <CODE><SPAN class="keyword">define</SPAN></CODE> clauses respectively, only they are executed upon functor definition instead of functor application. The variables introduced by these clauses are visible in the <CODE><SPAN class="keyword">define</SPAN></CODE> and <CODE><SPAN class="keyword">export</SPAN></CODE> clauses. </P><BLOCKQUOTE><TABLE border="0" cellpadding="0" cellspacing="0"><TR valign="top"><TD>&lt;<I>functor descriptor</I>&gt;</TD><TD align="center">&nbsp;+=&nbsp;</TD><TD><CODE><SPAN class="keyword">require</SPAN></CODE> { &lt;<I>import clause</I>&gt; }+</TD></TR><TR valign="top"><TD></TD><TD align="center">&nbsp;|&nbsp;</TD><TD><CODE><SPAN class="keyword">prepare</SPAN></CODE> &lt;<I>declaration part</I>&gt; [ <CODE><SPAN class="keyword">in</SPAN></CODE> &lt;<I>statement</I>&gt; ]</TD></TR></TABLE></BLOCKQUOTE><P> </P></DIV><DIV id="section.context-free.operators"><H2><A name="section.context-free.operators">3.5 Operator Associativity and Precedence</A></H2><P> The grammar given above is ambiguous. Some ambiguities do not affect the semantics (such as associativity of &lt;<I>statement</I>&gt;s and &lt;<I>declaration part</I>&gt;s). Those that do are resolved according to the following table stating the associativity of operators in increasing order of precedence: </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>Operators</P></TH><TH><P>Associativity</P></TH></TR><TR valign="top"><TD><P><CODE>X=Y</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">&lt;-</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">:=</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">.</SPAN>Y<SPAN class="keyword">:=</SPAN>Z</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE>X&nbsp;<SPAN class="keyword">orelse</SPAN>&nbsp;Y</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE>X&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;Y</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">==</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">\=</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp; <CODE>X<SPAN class="keyword">&lt;</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">=&lt;</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp; <CODE>X<SPAN class="keyword">&gt;</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">&gt;=</SPAN>Y</CODE></P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">=:</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">\=:</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp; <CODE>X<SPAN class="keyword">&lt;:</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">=&lt;:</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp; <CODE>X<SPAN class="keyword">&gt;:</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">&gt;=:</SPAN>Y</CODE></P></TD><TD><P>none</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">::</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">:::</SPAN>Y</CODE></P></TD><TD><P>none</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">|</SPAN>Y</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">#</SPAN>Y</CODE></P></TD><TD><P>mixfix</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">+</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">-</SPAN>Y</CODE></P></TD><TD><P>left</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">*</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X<SPAN class="keyword">/</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp; <CODE>X&nbsp;<SPAN class="keyword">div</SPAN>&nbsp;Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X&nbsp;<SPAN class="keyword">mod</SPAN>&nbsp;Y</CODE></P></TD><TD><P>left</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">,</SPAN>Y</CODE></P></TD><TD><P>right</P></TD></TR><TR valign="top"><TD><P><CODE><SPAN class="keyword">~</SPAN>X</CODE></P></TD><TD><P>prefix</P></TD></TR><TR valign="top"><TD><P><CODE>X<SPAN class="keyword">.</SPAN>Y</CODE>&nbsp;&nbsp;&nbsp;<CODE>X^Y</CODE></P></TD><TD><P>left</P></TD></TR><TR valign="top"><TD><P><CODE><SPAN class="keyword">@</SPAN>X</CODE>&nbsp;&nbsp;&nbsp;<CODE><SPAN class="keyword">!!</SPAN>X</CODE></P></TD><TD><P>prefix</P></TD></TR></TABLE><P> ``Having higher precedence'' means ``binding tighter''; e.&nbsp;g., the expression <CODE>c<SPAN class="keyword">#</SPAN>X<SPAN class="keyword">.</SPAN>g&nbsp;=&nbsp;Y</CODE> is parsed as <CODE>(c<SPAN class="keyword">#</SPAN>(X<SPAN class="keyword">.</SPAN>g))&nbsp;=&nbsp;Y</CODE>. </P><P> Attempts to exploit associativity of non-associative operators (without using parentheses to make the intention clear), as in <CODE>X&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;Y&nbsp;<SPAN class="keyword">&lt;</SPAN>&nbsp;Z</CODE>, are considered erroneous. </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html#chapter.lexical">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node4.html#chapter.core">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.iscs.nus.edu.sg/~henz">Martin&nbsp;Henz</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
