<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1 Regular Expressions</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.gdbm">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.regex"><H1><A name="chapter.regex">1 Regular Expressions</A></H1><P>The <CODE>regex</CODE> module implements an interface to the POSIX regex library and builds some higher level facilities on top of it. The module may be imported as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">import</SPAN>&nbsp;Regex&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'x-oz://contrib/regex'</SPAN></CODE></BLOCKQUOTE><P> </P><DL><DT><CODE>Regex<SPAN class="keyword">.</SPAN>is</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="keyword">true</SPAN></CODE> iff <CODE><I>X</I></CODE> is a regex object. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>make</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>make&nbsp;</CODE><CODE>+<I>PAT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RE</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Creates regex object <CODE><I>RE</I></CODE> from virtual string pattern <CODE><I>PAT</I></CODE>. Note that <CODE><I>Regex.make</I></CODE> cannot be used in (subordinated) spaces. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>search</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>search&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>MATCH</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the next <CODE><I>MATCH</I></CODE> of regex <CODE><I>RE</I></CODE> in virtual string <CODE><I>TXT</I></CODE>, or <CODE><SPAN class="keyword">false</SPAN></CODE> if there is no such match. <CODE><I>RE</I></CODE> is also permitted to be a virtual string pattern, in which case it is automatically compiled into a regex object.</P><P>A match is a record with integer features: one for each group in the pattern and also feature 0 for the whole match. The value on each feature is a pair <CODE>I<SPAN class="keyword">#</SPAN>J</CODE> of start and end indices into <CODE><I>TXT</I></CODE>. If <CODE><I>TXT</I></CODE> is a byte string, you can simply invoke <CODE>{ByteString<SPAN class="keyword">.</SPAN>slice&nbsp;TXT&nbsp;I&nbsp;J}</CODE> to extract the match. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>group</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>group&nbsp;</CODE><CODE>+<I>N</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>MATCH</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>GROUP</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Return the substring <CODE><I>GROUP</I></CODE> matched by the <CODE><I>N</I></CODE> group of <CODE><I>MATCH</I></CODE> in virtual string <CODE><I>TXT</I></CODE>. <CODE><I>MATCH</I></CODE> should be the result of calling <CODE>Regex<SPAN class="keyword">.</SPAN>search</CODE> on <CODE><I>TXT</I></CODE>. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>groups</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>groups&nbsp;</CODE><CODE>+<I>MATCH</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>GROUPS</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the record <CODE><I>GROUPS</I></CODE>, with label <CODE>group</CODE>, of substrings of <CODE><I>TXT</I></CODE> corresponding to the groups of <CODE><I>MATCH</I></CODE>. Group 0 (the whole match) is not included. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>allMatches</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>allMatches&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>MATCHES</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns the list of all <CODE><I>MATCHES</I></CODE> of regular expression <CODE><I>RE</I></CODE> in virtual string <CODE><I>TXT</I></CODE>. <CODE><I>RE</I></CODE> should not be anchored. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>forAll</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>forAll&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Applies the 1 argument procedure <CODE><I>P</I></CODE> to every match of <CODE><I>RE</I></CODE> in <CODE><I>TXT</I></CODE>. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>map</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>map&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>F</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RESULTS</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Applies the 1 argument function <CODE><I>F</I></CODE> to every match of <CODE><I>RE</I></CODE> in <CODE><I>TXT</I></CODE> and returns the corresponding list of <CODE><I>RESULTS</I></CODE>. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>foldR</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>foldR&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>F</I></CODE><CODE>&nbsp;</CODE><CODE><I>INIT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RESULT</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>foldL</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>foldL&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>F</I></CODE><CODE>&nbsp;</CODE><CODE><I>INIT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RESULT</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>The usual reduction procedure (see List module). </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>split</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>split&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>STRINGS</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Splits the input <CODE><I>TXT</I></CODE> at every match of separator <CODE><I>RE</I></CODE>, and returns the resulting list of strings. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>compile</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>compile&nbsp;</CODE><CODE>+<I>PAT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>CFLAGS</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RE</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>This is the more complicated version of <CODE>Regex<SPAN class="keyword">.</SPAN>make</CODE>. The additional <CODE><I>CFLAGS</I></CODE> argument further parametrizes the regex compilation process. It is either an atom or a list of atoms, from the set: <CODE>extended</CODE>, <CODE>icase</CODE>, <CODE>nosub</CODE>, <CODE>newline</CODE>. The default is <CODE>[extended&nbsp;newline]</CODE>. See the man page for <CODE>regcomp</CODE> for further details. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>execute</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>execute&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>IDX</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>EFLAGS</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>MATCH</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>This is the more complicated version of <CODE>Regex<SPAN class="keyword">.</SPAN>search</CODE>. Integer <CODE><I>IDX</I></CODE> is the offset at which to start the search in <CODE>+<I>TXT</I></CODE>. <CODE><I>EFLAGS</I></CODE> further specify how to search: it is an atom or list of atoms, from the set: <CODE>notbol</CODE>, <CODE>noteol</CODE>. The default is <CODE>nil</CODE>. See the man page for <CODE>regexec</CODE> for further details. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>cflags<SPAN class="keyword">.</SPAN>set</CODE> </DT><DT><CODE>Regex<SPAN class="keyword">.</SPAN>cflags<SPAN class="keyword">.</SPAN>get</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>cflags<SPAN class="keyword">.</SPAN>set&nbsp;</CODE><CODE>+<I>SPEC</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>cflags<SPAN class="keyword">.</SPAN>get&nbsp;</CODE><CODE>?<I>SPEC</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Set or get the current <CODE><I>CFLAGS</I></CODE> defaults, e.&nbsp;g. used by <CODE>Regex<SPAN class="keyword">.</SPAN>make</CODE>. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>eflags<SPAN class="keyword">.</SPAN>set</CODE> </DT><DT><CODE>Regex<SPAN class="keyword">.</SPAN>eflags<SPAN class="keyword">.</SPAN>get</CODE> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>eflags<SPAN class="keyword">.</SPAN>set&nbsp;</CODE><CODE>+<I>SPEC</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>eflags<SPAN class="keyword">.</SPAN>get&nbsp;</CODE><CODE>?<I>SPEC</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Set or get the current <CODE><I>EFLAGS</I></CODE> defaults, e.&nbsp;g. used by <CODE>Regex<SPAN class="keyword">.</SPAN>search</CODE>. </P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>replace</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>replace&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>FUN</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RES</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Replace every occurrence of <CODE><I>RE</I></CODE> in <CODE><I>TXT</I></CODE> with the result of applying <CODE><I>FUN</I></CODE> to the current <CODE><I>TXT</I></CODE> and the current match.</P></DD><DT><CODE>Regex<SPAN class="keyword">.</SPAN>replaceRegion</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Regex<SPAN class="keyword">.</SPAN>replaceRegion&nbsp;</CODE><CODE>+<I>TXT</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LO</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>HI</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>RE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>FUN</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>RES</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Same as above, but only operate on the region starting at <CODE><I>LO</I></CODE> inclusive and ending at <CODE><I>HI</I></CODE> exclusive.</P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="index.html">- Up -</A></TD><TD><A href="node2.html#chapter.gdbm">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
