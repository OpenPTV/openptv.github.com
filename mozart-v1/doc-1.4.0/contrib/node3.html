<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2.1 Interface</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html">- Up -</A></TD><TD><A href="node4.html#chapter.gdbm.install">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.gdbm.interface"><H2><A name="chapter.gdbm.interface">2.1 Interface</A></H2><P>The module may be imported as follows: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">import</SPAN>&nbsp;Gdbm&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'x-oz://contrib/gdbm'</SPAN></CODE></BLOCKQUOTE><P> The interface provided is similar to dictionaries and allows to store stateless Oz terms under keys. A key is an arbitrary virtual string. </P><DL><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>is</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns <CODE><SPAN class="keyword">true</SPAN></CODE> iff <CODE><I>X</I></CODE> is a gdbm object. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>new</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>new&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>DB</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>This is the convenient way of creating a gdbm object <CODE><I>DB</I></CODE>. <CODE><I>R</I></CODE> is a record that describes how to open the database. The label is the opening method, e.&nbsp;g. <CODE>read</CODE>, <CODE>write</CODE>, <CODE>create</CODE>, or <CODE>new</CODE>. The first argument of the record is the file name. For example <CODE>read(<SPAN class="string">'/usr/local/people.db'</SPAN>)</CODE> asks to open the database located in <CODE>/usr/local/people.db</CODE> for reading only. <CODE>create(<SPAN class="string">'~/data'</SPAN>)</CODE> opens or creates the database <CODE>data</CODE> in the user's home directory and opens it both for reading and writing; <CODE>new(<SPAN class="string">'~/data'</SPAN>)</CODE> is similar, but overwrites it if it already existed. </P><P>Optional feature <CODE>mode</CODE> indicates with what permissions the file should be created (this of course is only relevant for creating a new database). The mode may be specified as an integer, with the usual Unix meaning. It may also be specified symbolically, as a record or list of records: </P><BLOCKQUOTE class="code"><CODE>[owner&nbsp;group(read)]</CODE></BLOCKQUOTE><P> This indicates that the owner has all permission rights and that group members are granted read access. Others have no rights. To also grant write access to group members, you could say: </P><BLOCKQUOTE class="code"><CODE>[owner&nbsp;group(read&nbsp;write)]</CODE></BLOCKQUOTE><P> The default is 0644: owner has read and write access; all others have read access. </P><P>Optional feature boolean <CODE>fast</CODE> requests updates without disk synchronization. See the GDBM documentation for details. Default is <CODE><SPAN class="keyword">false</SPAN></CODE>. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>open</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>open&nbsp;</CODE><CODE>+<I>FILE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>FLAGS</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>MODE</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>BLOCK</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>DB</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>This is the more complicated way of opening a gdbm database. The <CODE><I>FLAGS</I></CODE> specify the opening method. This is an atom or list of atoms from the set: <CODE>read</CODE>, <CODE>write</CODE>, <CODE>create</CODE> (equivalently <CODE>new</CODE> or <CODE>truncate</CODE>). It may also include the atom <CODE>fast</CODE> (see above). Each symbol may be abbreviated to its initial letter. <CODE><I>MODE</I></CODE> was described above. <CODE><I>BLOCK</I></CODE> is an integer for the block size of transfers (see GDBM documentation): use 0 to get a system dependent appropriate default. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>get</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>get&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>KEY</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>VAL</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Retrieves the Oz value <CODE><I>VAL</I></CODE> stored under <CODE><I>KEY</I></CODE>. The latter may be an arbitrary virtual string. If there is no such <CODE><I>KEY</I></CODE> in <CODE><I>DB</I></CODE>, an exception is raised. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>condGet</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>condGet&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>KEY</I></CODE><CODE>&nbsp;</CODE><CODE><I>DEFAULT</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>VAL</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Similar to the above, but returns <CODE><I>DEFAULT</I></CODE> if there is no such <CODE><I>KEY</I></CODE> in <CODE><I>DB</I></CODE>. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>put</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>put&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>KEY</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>VAL</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Stores Oz value <CODE><I>VAL</I></CODE> under <CODE><I>KEY</I></CODE> in <CODE><I>DB</I></CODE>. <CODE><I>VAL</I></CODE> must be ground and stateless. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>firstkey</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>firstkeyBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>firstkey&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KEY</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns a <CODE><I>KEY</I></CODE> in <CODE><I>DB</I></CODE> (see below). There is absolutely no guarantee as to which key this is going to be. Returns <CODE><SPAN class="keyword">unit</SPAN></CODE> if the database is empty. <CODE>Gdbm<SPAN class="keyword">.</SPAN>firstkey</CODE> returns <CODE><I>KEY</I></CODE> as an atom, <CODE>Gdbm<SPAN class="keyword">.</SPAN>firstkeyBS</CODE> as a bytestring. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>nextkey</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>nextkeyBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>nextkey&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>KEY</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>NEXT</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns the <CODE><I>NEXT</I></CODE> key after <CODE><I>KEY</I></CODE>. Again, there is no guarantee as to which key this is going to be. The only guarantee is that if you continue in this manner, you will enumerate all the keys in the database, in some order, without repeats. Returns <CODE><SPAN class="keyword">unit</SPAN></CODE> when there are no more keys. <CODE>Gdbm<SPAN class="keyword">.</SPAN>nextkey</CODE> returns <CODE><I>NEXT</I></CODE> as an atom, <CODE>Gdbm<SPAN class="keyword">.</SPAN>nextkeyBS</CODE> as a bytestring. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>close</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>close&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Closes the database. Subsequent access attempts raise an exception. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>remove</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>remove&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>KEY</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Deletes the entry for <CODE><I>KEY</I></CODE> if it exists. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>reorganize</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>reorganize&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>see the GDBM documentation. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>keys</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>keysBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>key&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>KEYS</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns the lazy list of all <CODE><I>KEYS</I></CODE> in the database. <CODE>Gdbm<SPAN class="keyword">.</SPAN>keys</CODE> returns each key as an atom, <CODE>Gdbm<SPAN class="keyword">.</SPAN>keysBS</CODE> as a bytestring. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>entries</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>entriesBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>entries&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>ENTRIES</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns the lazy list of all pairs <CODE>KEY<SPAN class="keyword">#</SPAN>VALUE</CODE> in the database. <CODE>Gdbm<SPAN class="keyword">.</SPAN>entries</CODE> returns each key as an atom, <CODE>Gdbm<SPAN class="keyword">.</SPAN>entriesBS</CODE> as a bytestring. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>items</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>itemsBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>items&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>ITEMS</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Returns the lazy list of all values stored in the database. <CODE>Gdbm<SPAN class="keyword">.</SPAN>items</CODE> returns each key as an atom, <CODE>Gdbm<SPAN class="keyword">.</SPAN>itemsBS</CODE> as a bytestring. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>forAll</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>forAll&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Calls <CODE>{P&nbsp;VALUE}</CODE> for every entry in the database. <CODE>Gdbm<SPAN class="keyword">.</SPAN>forAll</CODE> loops over all keys as atoms, <CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllBS</CODE> as bytestrings. </P></DD><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllInd</CODE></DT><DT><CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllIndBS</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Gdbm<SPAN class="keyword">.</SPAN>forAllInd&nbsp;</CODE><CODE>+<I>DB</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE></P></BLOCKQUOTE></DD><DD><P>Calls <CODE>{P&nbsp;KEY&nbsp;VALUE}</CODE> for every entry in the database. <CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllInd</CODE> loops over all keys as atoms, <CODE>Gdbm<SPAN class="keyword">.</SPAN>forAllIndBS</CODE> as bytestrings. </P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node2.html">- Up -</A></TD><TD><A href="node4.html#chapter.gdbm.install">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
