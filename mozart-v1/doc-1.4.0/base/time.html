<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>10.3 Time</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="loop.html#section.control.loops">&lt;&lt; Prev</A></TD><TD><A href="node12.html">- Up -</A></TD><TD><A href="exception.html#section.control.exceptions">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="section.control.time"><H2><A name="section.control.time">10.3 Time</A></H2><P> The module <A name="label707"></A><SPAN class="index"><CODE>Time</CODE></SPAN> contains procedures for real-time applications. </P><DL><DT><A name="label708"></A><SPAN class="index"><CODE>Alarm</CODE></SPAN> <A name="label709"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Time<SPAN class="keyword">.</SPAN>alarm&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>U</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns <CODE><SPAN class="keyword">unit</SPAN></CODE> after <CODE><I>I</I></CODE> milliseconds. This is done asynchronously in that it is evaluated on its own thread. </P></DD><DT><A name="label710"></A><SPAN class="index"><CODE>Delay</CODE></SPAN> <A name="label711"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Time<SPAN class="keyword">.</SPAN>delay&nbsp;</CODE><CODE>+<I>I</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>reduces to <CODE><SPAN class="keyword">skip</SPAN></CODE> after <CODE><I>I</I></CODE> milliseconds. Whenever <CODE><I>I</I></CODE><CODE>&nbsp;<SPAN class="keyword">=&lt;</SPAN>&nbsp;0</CODE>, <CODE>{Delay&nbsp;</CODE><CODE><I>I</I></CODE><CODE>}</CODE> reduces immediately. </P></DD><DT><CODE>time</CODE> <A name="label713"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Time<SPAN class="keyword">.</SPAN>time&nbsp;</CODE><CODE>?<I>T</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>T</I></CODE> to the number of seconds elapsed since January, 1st of the current year. </P></DD></DL><P> </P><DIV class="unnumbered"><H3><A name="label714">The Repeater Class</A></H3><P> </P><DL><DT><CODE>repeat</CODE> <A name="label716"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>Time<SPAN class="keyword">.</SPAN>repeat</CODE> </P></BLOCKQUOTE></DD><DD><P>is a class which allows to </P><UL><LI><P>repeat an action infinitely often, or a fixed number of times and perform some final action thereafter, </P></LI><LI><P>with a fixed delay between iterations (or, alternatively, a delay specified by a unary procedure), </P></LI><LI><P>stop and resume the iteration. </P></LI></UL><P> There are default values for any of the iteration parameters. These are set on creation of an object inheriting from <CODE>Time<SPAN class="keyword">.</SPAN>repeat</CODE> and can be changed by inheritance. The functionality is controlled by the following methods. </P><DL><DT><CODE>setRepAll</CODE> <A name="label717"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>setRepAll(action:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>ActionPR</I></CODE><CODE>&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;dummyRep<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>FinalPR</I></CODE><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;finalRep<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>DelayI</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;1000<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delayFun:&nbsp;</CODE><CODE>+<I>DelayFunP</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;1000&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number:&nbsp;&nbsp;&nbsp;</CODE><CODE>+<I>NumI</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">~</SPAN>1)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>initializes the loop with the action <CODE><I>ActionPR</I></CODE> to iterate (default: message <CODE>dummyRep</CODE>), the action <CODE><I>FinalPR</I></CODE> to finalize a finite iteration (default: message <CODE>finalRep</CODE>), the delay <CODE><I>DelayI</I></CODE> between iterations (default: one second), the function <CODE><I>DelayFunP</I></CODE> yielding the delay between iterations (default: constant <CODE>1000</CODE>), and the maximal number <CODE><I>NumI</I></CODE> of iterations (default: infinitely many). </P><P> The methods <CODE>dummyRep</CODE> and <CODE>finalRep</CODE> do nothing. Only one of the <CODE>delay</CODE> and <CODE>delayFun</CODE> parameters can be given. The default actions <CODE><I>ActionPR</I></CODE> and <CODE><I>FinalPR</I></CODE> can be changed by inheritance. </P><P> The loop is started on the calling thread. </P><P> For example, try the following: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;O&nbsp;=&nbsp;{New&nbsp;Time<SPAN class="keyword">.</SPAN>repeat<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setRepAll(action:&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{OS<SPAN class="keyword">.</SPAN>system&nbsp;<SPAN class="string">'fortune'</SPAN>&nbsp;_}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number:&nbsp;10)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{O&nbsp;go()}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>getRep</CODE> <A name="label718"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>getRep(action:&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>ActionPR</I></CODE><CODE>&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;final:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>FinalPR</I></CODE><CODE>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay:&nbsp;&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>DelayI</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delayFun:&nbsp;</CODE><CODE>?<I>DelayFunP</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number:&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>LimitI</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual:&nbsp;&nbsp;&nbsp;</CODE><CODE>?<I>NumI</I></CODE><CODE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;_)</CODE></BLOCKQUOTE><P> </P></BLOCKQUOTE></DD><DD><P>returns the current loop parameters: <CODE><I>LimitI</I></CODE> returns the current limit of the iteration, and <CODE><I>NumI</I></CODE> the number of iterations left to be done. If the delay was specified via <CODE><I>DelayFunP</I></CODE> (which need not be constant), then <CODE><I>DelayI</I></CODE> returns the <EM>last</EM> delay used. If <CODE><I>DelayI</I></CODE> is requested before the start of the iteration, then <CODE><SPAN class="keyword">~</SPAN>1</CODE> is returned. The other values correspond to the fields of the method <CODE>setRepAll</CODE>. </P><P> For example try: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">Counter</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Time.repeat</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;a:&nbsp;0<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">inc</SPAN>()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">@</SPAN>a&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">get</SPAN>(?A)&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;=&nbsp;<SPAN class="keyword">@</SPAN>a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">finalRep</SPAN>()&nbsp;a&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;C&nbsp;=&nbsp;{New&nbsp;Counter&nbsp;setRepAll(action:&nbsp;inc&nbsp;number:&nbsp;1000)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{C&nbsp;go()}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{C&nbsp;getRep(final:&nbsp;{Browse}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:&nbsp;{Browse}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;actual:&nbsp;{Browse})}<BR>&nbsp;&nbsp;&nbsp;{C&nbsp;get({Browse})}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> This will show the atoms <CODE><SPAN class="string">'finalRep'</SPAN></CODE> and <CODE><SPAN class="string">'inc'</SPAN></CODE> in the Browser, as well as a number between <CODE>1</CODE> and&nbsp;<CODE>1000</CODE>. After termination of the loop, the value of <CODE><SPAN class="keyword">@</SPAN>a</CODE> will be reset to&nbsp;<CODE>0</CODE>. </P></DD><DT><CODE>setRepDelay</CODE> <A name="label719"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>setRepDelay(</CODE><CODE>+<I>DelayI</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;1000}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>setRepNum</CODE> <A name="label720"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>setRepNum(</CODE><CODE>+<I>NumI</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">~</SPAN>1)}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>setRepAction</CODE> <A name="label721"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>setRepAction(</CODE><CODE>+<I>ActionPR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;dummyRep)</CODE> </P></BLOCKQUOTE></DD><DT><CODE>setRepFinal</CODE> <A name="label722"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>setRepFinal(</CODE><CODE>+<I>FinalPR</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;finalRep)}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>setRepDelayFun</CODE> <A name="label723"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>setRepDelayFun(</CODE><CODE>+<I>DelayFunP</I></CODE><CODE>&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;1000&nbsp;<SPAN class="keyword">end</SPAN>)</CODE> </P></BLOCKQUOTE></DD><DD><P>allow to set the numeric parameters of the iteration. </P><P> <CODE><I>DelayI</I></CODE> and <CODE><I>NumI</I></CODE> must be integers. The iteration limit <CODE><I>NumI</I></CODE> is stored and subsequent loop instances (triggered by <CODE>go</CODE>) also obey it, unless the limit is reset to&nbsp;<CODE><SPAN class="keyword">~</SPAN>1</CODE>. </P><P> <CODE><I>ActionPR</I></CODE> and <CODE><I>FinalPR</I></CODE> may be nullary procedures or records. If they are procedures they are called as is. If they are records, they are interpreted as messages to be sent to <CODE><SPAN class="keyword">self</SPAN></CODE>. </P><P> <CODE><I>DelayFunP</I></CODE> must be a unary procedure which returns an integer value on application. </P></DD><DT><CODE>go</CODE> <A name="label724"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>go()</CODE> </P></BLOCKQUOTE></DD><DD><P>starts the loop if it is not currently running. </P></DD><DT><CODE>stop</CODE> <A name="label725"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>stop()</CODE> </P></BLOCKQUOTE></DD><DD><P>halts the loop and resets the iteration index. The loop may be restarted with <CODE>go</CODE>. </P></DD></DL><P> </P></DD></DL><P> </P></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="loop.html#section.control.loops">&lt;&lt; Prev</A></TD><TD><A href="node12.html">- Up -</A></TD><TD><A href="exception.html#section.control.exceptions">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
