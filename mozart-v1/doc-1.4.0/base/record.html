<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>6.1 Records in General</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html">- Up -</A></TD><TD><A href="tuple.html#section.records.tuples">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="section.records.records"><H2><A name="section.records.records">6.1 Records in General</A></H2><P> The module <A name="label176"></A><SPAN class="index"><CODE>Record</CODE></SPAN> contains procedures operating on records. </P><P> Procedures that iterate over the subtrees of a record operate in ascending order as specified for <CODE>Arity</CODE>. </P><DL><DT><A name="label177"></A><SPAN class="index"><CODE><SPAN class="keyword">.</SPAN></CODE></SPAN> <A name="label178"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Value<SPAN class="keyword">.</SPAN><SPAN class="string">'.'</SPAN>&nbsp;</CODE><CODE>+<I>RC</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LI</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the field&nbsp;<CODE><I>X</I></CODE> of&nbsp;<CODE><I>RC</I></CODE> at feature&nbsp;<CODE><I>LI</I></CODE>. </P></DD><DT><A name="label179"></A><SPAN class="index"><CODE>HasFeature</CODE></SPAN> <A name="label180"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Value<SPAN class="keyword">.</SPAN>hasFeature&nbsp;</CODE><CODE>+<I>RC</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>RC</I></CODE> has feature&nbsp;<CODE><I>LI</I></CODE>. </P></DD><DT><A name="label181"></A><SPAN class="index"><CODE>CondSelect</CODE></SPAN> <A name="label182"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Value<SPAN class="keyword">.</SPAN>condSelect&nbsp;</CODE><CODE>+<I>RC</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LI</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE><I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the field of&nbsp;<CODE><I>RC</I></CODE> at feature&nbsp;<CODE><I>LI</I></CODE>, if <CODE><I>RC</I></CODE> has feature&nbsp;<CODE><I>LI</I></CODE>. Otherwise, return&nbsp;<CODE><I>X</I></CODE>. </P></DD><DT><A name="label183"></A><SPAN class="index"><CODE>IsRecord</CODE></SPAN> <A name="label185"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is a record. </P></DD><DT><A name="label186"></A><SPAN class="index"><CODE>MakeRecord</CODE></SPAN> <A name="label188"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>make&nbsp;</CODE><CODE>+<I>L</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LIs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a new record with label&nbsp;<CODE><I>L</I></CODE>, features&nbsp;<CODE><I>LIs</I></CODE>, and fresh variables at every field. All elements of&nbsp;<CODE><I>LIs</I></CODE> must be pairwise distinct, else an error exception is raised. </P><P> For example, <CODE>{MakeRecord&nbsp;L&nbsp;A&nbsp;R}</CODE> waits until <CODE>L</CODE> is bound to a literal, say&nbsp;<CODE>b</CODE>, and <CODE>A</CODE> is bound to a list of literals and integers, say <CODE>[c&nbsp;d&nbsp;1]</CODE>, and then binds <CODE>R</CODE> to <CODE>b(_&nbsp;c:&nbsp;_&nbsp;d:&nbsp;_)</CODE>. </P></DD><DT><A name="label189"></A><SPAN class="index"><CODE>clone</CODE></SPAN> <A name="label191"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>clone&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a record <CODE><I>R2</I></CODE> with the same label and features as <CODE><I>R1</I></CODE> and fresh variables at every field. </P></DD><DT><A name="label192"></A><SPAN class="index"><CODE>Label</CODE></SPAN> <A name="label193"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>label&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>L</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the label of&nbsp;<CODE><I>R</I></CODE> in&nbsp;<CODE><I>L</I></CODE>. </P></DD><DT><A name="label194"></A><SPAN class="index"><CODE>Width</CODE></SPAN> <A name="label195"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>width&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>I</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the width of&nbsp;<CODE><I>R</I></CODE> in&nbsp;<CODE><I>I</I></CODE>. </P></DD><DT><A name="label196"></A><SPAN class="index"><CODE>Arity</CODE></SPAN> <A name="label197"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>arity&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>LIs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the arity <CODE><I>LIs</I></CODE> of&nbsp;<CODE><I>R</I></CODE>. The arity of&nbsp;<CODE><I>R</I></CODE> is the list of its features, beginning with all integer features in ascending order, followed by the literal features. The atomic literals occur in ascending order interspersed with names. </P><P> For example, <CODE>{Arity&nbsp;a(nil&nbsp;7&nbsp;c:&nbsp;1&nbsp;b:&nbsp;c)}</CODE> yields <CODE>[1&nbsp;2&nbsp;b&nbsp;c]</CODE> as output. </P></DD><DT><A name="label198"></A><SPAN class="index"><CODE>Adjoin</CODE></SPAN> <A name="label199"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>adjoin&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the result of adjoining <CODE><I>R2</I></CODE> to&nbsp;<CODE><I>R1</I></CODE>. Note that features and label in R2 take precedence over R1. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Adjoin&nbsp;a(a&nbsp;b&nbsp;c:&nbsp;1)&nbsp;b(4&nbsp;b:&nbsp;3&nbsp;c:&nbsp;2)}</CODE></BLOCKQUOTE><P> yields the record <CODE>b(4&nbsp;b&nbsp;b:&nbsp;3&nbsp;c:&nbsp;2)</CODE> as output. </P></DD><DT><A name="label200"></A><SPAN class="index"><CODE>AdjoinAt</CODE></SPAN> <A name="label201"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>adjoinAt&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LI</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>R2</I></CODE> to the result of adjoining the field&nbsp;<CODE><I>X</I></CODE> to&nbsp;<CODE><I>R1</I></CODE> at feature&nbsp;<CODE><I>LI</I></CODE>. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{AdjoinAt&nbsp;a(a&nbsp;c:&nbsp;1)&nbsp;2&nbsp;b}</CODE></BLOCKQUOTE><P> yields <CODE>a(a&nbsp;b&nbsp;c:&nbsp;1)</CODE> as output, whereas </P><BLOCKQUOTE class="code"><CODE>{AdjoinAt&nbsp;a(a&nbsp;c:&nbsp;1)&nbsp;c&nbsp;b}</CODE></BLOCKQUOTE><P> yields <CODE>a(a&nbsp;c:&nbsp;b)</CODE> as output. </P></DD><DT><A name="label202"></A><SPAN class="index"><CODE>AdjoinList</CODE></SPAN> <A name="label203"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>adjoinList&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>Ts</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>R2</I></CODE> to the result of adjoining to <CODE><I>R1</I></CODE> all entries of&nbsp;<CODE><I>Ts</I></CODE>, a finite list of pairs whose first components are literals or integers, representing features. Features further to the right overwrite features further to the left. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{AdjoinList&nbsp;a(b:1&nbsp;c:2)&nbsp;[d<SPAN class="keyword">#</SPAN>3&nbsp;c<SPAN class="keyword">#</SPAN>4&nbsp;d<SPAN class="keyword">#</SPAN>5]}</CODE></BLOCKQUOTE><P> yields <CODE>a(b:&nbsp;1&nbsp;c:&nbsp;4&nbsp;d:&nbsp;5)</CODE> as output. </P></DD><DT><CODE>subtract</CODE> <A name="label205"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>subtract&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LI</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>If <CODE><I>R1</I></CODE> has feature&nbsp;<CODE><I>LI</I></CODE>, returns record&nbsp;<CODE><I>R1</I></CODE> with feature&nbsp;<CODE><I>LI</I></CODE> removed. Otherwise, returns&nbsp;<CODE><I>R1</I></CODE>. </P></DD><DT><CODE>subtractList</CODE> <A name="label207"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>subtractList&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>LIs</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Returns record&nbsp;<CODE><I>R1</I></CODE> with all features in&nbsp;<CODE><I>LIs</I></CODE> removed. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>subtractList&nbsp;f(jim:&nbsp;1&nbsp;jack:&nbsp;2&nbsp;jesse:&nbsp;4)&nbsp;[jesse&nbsp;jim]}</CODE></BLOCKQUOTE><P> returns the record <CODE>f(jack:&nbsp;2)</CODE>. </P></DD><DT><CODE>zip</CODE> <A name="label209"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>zip&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Given two records <CODE><I>R1</I></CODE> and&nbsp;<CODE><I>R2</I></CODE> and a ternary procedure&nbsp;<CODE><I>P</I></CODE>, <CODE><I>R3</I></CODE>&nbsp;is bound to a record with the same label as&nbsp;<CODE><I>R1</I></CODE> and those features which are common to <CODE><I>R1</I></CODE> and&nbsp;<CODE><I>R2</I></CODE>. Features appearing only in one of the records are silently dropped. Each fields&nbsp;<CODE><I>X</I></CODE> of <CODE><I>R3</I></CODE> is computed by applying <CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R1</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE><I>R2</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE><I>R3</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>X</I></CODE><CODE>}</CODE>. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>zip<BR>&nbsp;f(jim:&nbsp;1&nbsp;jack:&nbsp;2&nbsp;jesse:&nbsp;4)<BR>&nbsp;g(jim:&nbsp;a&nbsp;jack:&nbsp;b&nbsp;joe:&nbsp;c)<BR>&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Y}&nbsp;X<SPAN class="keyword">#</SPAN>Y&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> yields as output the record <CODE>f(jim:&nbsp;1<SPAN class="keyword">#</SPAN>a&nbsp;jack:&nbsp;2<SPAN class="keyword">#</SPAN>b)</CODE>. </P></DD><DT><CODE>toList</CODE> <A name="label211"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>toList&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Xs</I></CODE> to list of all fields of&nbsp;<CODE><I>R</I></CODE> in the order as given by <CODE>Arity</CODE> (which see). </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>toList&nbsp;f(a&nbsp;a:&nbsp;2&nbsp;b:&nbsp;3)}</CODE></BLOCKQUOTE><P> yields <CODE>[a&nbsp;2&nbsp;3]</CODE> as output. </P></DD><DT><CODE>toListInd</CODE> <A name="label213"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>toListInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ts</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>binds <CODE><I>Ts</I></CODE> to the property list that contains the feature-field pairs of&nbsp;<CODE><I>R</I></CODE> in the order as given by <CODE>Arity</CODE> (which see). </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>toListInd&nbsp;f(a&nbsp;a:&nbsp;2&nbsp;b:&nbsp;3)}</CODE></BLOCKQUOTE><P> yields <CODE>[1<SPAN class="keyword">#</SPAN>a&nbsp;a<SPAN class="keyword">#</SPAN>2&nbsp;b<SPAN class="keyword">#</SPAN>3]</CODE> as output. </P></DD><DT><CODE>toDictionary</CODE> <A name="label215"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>toDictionary&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Dictionary</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a dictionary <CODE><I>Dictionary</I></CODE> whose keys and their entries correspond to the features and their fields of&nbsp;<CODE><I>R</I></CODE>. </P></DD></DL><P> </P><P> All of the following procedures are provided in two versions. The so-called <EM>index</EM> version passes to the procedures an additional index as first actual argument. The index is an integer or a literal giving the feature of the field currently processed. </P><DL><DT><CODE>map</CODE> <A name="label217"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>map&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a record with same label and arity as&nbsp;<CODE><I>R1</I></CODE>, whose fields are computed by applying the binary procedure&nbsp;<CODE><I>P</I></CODE> to all fields of <CODE><I>R1</I></CODE>. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>map&nbsp;a(12&nbsp;b:&nbsp;13&nbsp;c:&nbsp;1)&nbsp;IntToFloat}</CODE></BLOCKQUOTE><P> yields the record <CODE>a(12<SPAN class="keyword">.</SPAN>0&nbsp;b:&nbsp;13<SPAN class="keyword">.</SPAN>0&nbsp;c:&nbsp;1<SPAN class="keyword">.</SPAN>0)</CODE> as output. </P></DD><DT><CODE>mapInd</CODE> <A name="label219"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>mapInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>Record<SPAN class="keyword">.</SPAN>map</CODE>, but the ternary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the index as first actual argument. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>mapInd&nbsp;a(1:&nbsp;d&nbsp;3:&nbsp;a&nbsp;f:&nbsp;e)&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I&nbsp;A}&nbsp;A(I)&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> yields the record <CODE>a(1:&nbsp;d(1)&nbsp;3:&nbsp;a(3)&nbsp;f:&nbsp;e(f))</CODE> as output. </P></DD><DT><CODE>foldL</CODE> <A name="label221"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>foldL&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>foldR</CODE> <A name="label223"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>foldR&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>Used for <A name="label224"></A><SPAN class="index">folding</SPAN> the fields of&nbsp;<CODE><I>R</I></CODE> by applying the ternary procedure&nbsp;<CODE><I>P</I></CODE>. </P><P> Suppose that <CODE><I>R</I></CODE> has the arity <CODE>[</CODE><CODE><I>F1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Fn</I></CODE><CODE>]</CODE>. Applying the left folding procedure <CODE>{Record<SPAN class="keyword">.</SPAN>foldL&nbsp;</CODE><CODE><I>R</I></CODE><CODE>&nbsp;</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE> reduces to </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>F1</I></CODE><CODE>}&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>F2</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>Fn</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> The first actual argument of&nbsp;<CODE><I>P</I></CODE> is the accumulator in which the result of the previous application or the start value&nbsp;<CODE><I>Z</I></CODE> is passed. The second actual argument is a field of&nbsp;<CODE><I>R</I></CODE>. </P><P> Besides the left folding procedure there exists a right folding variant. The application <CODE>{Record<SPAN class="keyword">.</SPAN>foldR&nbsp;</CODE><CODE><I>R</I></CODE><CODE>&nbsp;</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE> reduces to </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>F1</I></CODE><CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>F2</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>Fn</I></CODE><CODE>&nbsp;</CODE><CODE><I>Z</I></CODE><CODE>}&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Out</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> The first actual argument of&nbsp;<CODE><I>P</I></CODE> is a field of&nbsp;<CODE><I>R</I></CODE>; the second actual argument is the accumulator in which the result of the previous application or the start value&nbsp;<CODE><I>Z</I></CODE> is passed. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>foldL&nbsp;a(3&nbsp;a:&nbsp;7&nbsp;b:&nbsp;4)&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Xr&nbsp;X}&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;nil}</CODE></BLOCKQUOTE><P> yields the output <CODE>[4&nbsp;7&nbsp;3]</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>foldR&nbsp;a(3&nbsp;a:&nbsp;7&nbsp;b:&nbsp;4)&nbsp;<SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X&nbsp;Xr}&nbsp;X<SPAN class="keyword">|</SPAN>Xr&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;nil}</CODE></BLOCKQUOTE><P> yields the output <CODE>[3&nbsp;7&nbsp;4]</CODE>. </P></DD><DT><CODE>foldLInd</CODE> <A name="label226"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>foldLInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>foldRInd</CODE> <A name="label228"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>foldRInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Y</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>Record<SPAN class="keyword">.</SPAN>foldL</CODE> and <CODE>Record<SPAN class="keyword">.</SPAN>foldR</CODE>, but the 4-ary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><CODE>forAll</CODE> <A name="label230"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>forAll&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>PO</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>applies the unary procedure or object&nbsp;<CODE><I>PO</I></CODE> to each field of&nbsp;<CODE><I>R</I></CODE>. </P><P> Suppose that the arity of&nbsp;<CODE><I>R</I></CODE> is <CODE>[</CODE><CODE><I>F1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>Fn</I></CODE><CODE>]</CODE>. The application <CODE>{Record<SPAN class="keyword">.</SPAN>forAll&nbsp;</CODE><CODE><I>R</I></CODE><CODE>&nbsp;</CODE><CODE><I>P</I></CODE><CODE>}</CODE> reduces to the sequence of statements </P><BLOCKQUOTE class="code"><CODE>{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>F1</I></CODE><CODE>}&nbsp;</CODE>...<CODE>&nbsp;{</CODE><CODE><I>P</I></CODE><CODE>&nbsp;</CODE><CODE><I>R</I></CODE><CODE><SPAN class="keyword">.</SPAN></CODE><CODE><I>Fn</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>forAll&nbsp;O1<SPAN class="keyword">#</SPAN>O2<SPAN class="keyword">#</SPAN>O3&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;O}&nbsp;{O&nbsp;<SPAN class="keyword">do</SPAN>()}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> sends the message <CODE><SPAN class="keyword">do</SPAN>()</CODE> to the objects <CODE>O1</CODE>, <CODE>O2</CODE>, and&nbsp;<CODE>O3</CODE>. </P></DD><DT><CODE>forAllInd</CODE> <A name="label232"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>forAllInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>Record<SPAN class="keyword">.</SPAN>forAll</CODE>, but the binary procedure&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P><P> For example, assuming <CODE>O1</CODE>, <CODE>O2</CODE>, and&nbsp;<CODE>O3</CODE> are objects, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>forAllInd&nbsp;a(<SPAN class="keyword">do</SPAN>:&nbsp;O1&nbsp;stop:&nbsp;O2&nbsp;run:&nbsp;O3)<BR>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;M&nbsp;O}&nbsp;{O&nbsp;M}&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> sends the message <CODE><SPAN class="keyword">do</SPAN></CODE> to the object&nbsp;<CODE>O1</CODE>, the message <CODE>stop</CODE> to&nbsp;<CODE>O2</CODE>, and the message <CODE>run</CODE> to&nbsp;<CODE>O3</CODE>. </P></DD><DT><CODE>all</CODE> <A name="label234"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>all&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>some</CODE> <A name="label236"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>some&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether the unary boolean function&nbsp;<CODE><I>P</I></CODE> yields <CODE><SPAN class="keyword">true</SPAN></CODE> when applied to all fields resp. some field of&nbsp;<CODE><I>R</I></CODE>. Stops at the first field for which <CODE><I>P</I></CODE> yields <CODE><SPAN class="keyword">false</SPAN></CODE> resp. <CODE><SPAN class="keyword">true</SPAN></CODE>. The fields are tested in the order given by <CODE>Arity</CODE> (which see). </P></DD><DT><CODE>allInd</CODE> <A name="label238"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>allInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>someInd</CODE> <A name="label240"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>someInd&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>is similar to <CODE>Record<SPAN class="keyword">.</SPAN>all</CODE> resp. <CODE>Record<SPAN class="keyword">.</SPAN>some</CODE>, but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><CODE>filter</CODE> <A name="label242"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>filter&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>partition</CODE> <A name="label244"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>partition&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P><CODE>Record<SPAN class="keyword">.</SPAN>filter</CODE> computes a record&nbsp;<CODE><I>R2</I></CODE> which contains all the features and fields of the record&nbsp;<CODE><I>R1</I></CODE> for which the unary boolean procedure&nbsp;<CODE><I>P</I></CODE> applied to the field yields <CODE><SPAN class="keyword">true</SPAN></CODE>. <CODE>Record<SPAN class="keyword">.</SPAN>partition</CODE> works similarly, but returns in&nbsp;<CODE><I>R3</I></CODE> a record with all remaining fields of&nbsp;<CODE><I>R1</I></CODE>. </P><P> For example, the application </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>partition&nbsp;a(1&nbsp;4&nbsp;7&nbsp;a:&nbsp;3&nbsp;b:&nbsp;6&nbsp;c:&nbsp;5)&nbsp;IsOdd&nbsp;?R2&nbsp;?R3}</CODE></BLOCKQUOTE><P> returns <CODE>a(1:&nbsp;1&nbsp;3:&nbsp;7&nbsp;a:&nbsp;3&nbsp;c:&nbsp;5)</CODE> in <CODE>R2</CODE> and <CODE>a(2:&nbsp;4&nbsp;b:&nbsp;6)</CODE> in <CODE>R3</CODE>. </P></DD><DT><CODE>filterInd</CODE> <A name="label246"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>filterInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>partitionInd</CODE> <A name="label248"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>partitionInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>Record<SPAN class="keyword">.</SPAN>filter</CODE> and <CODE>Record<SPAN class="keyword">.</SPAN>partition</CODE>, but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><CODE>takeWhile</CODE> <A name="label250"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>takeWhile&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>dropWhile</CODE> <A name="label252"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>dropWhile&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>takeDropWhile</CODE> <A name="label254"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>takeDropWhile&nbsp;</CODE><CODE>+<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>While <CODE>Record<SPAN class="keyword">.</SPAN>filter</CODE> selects all fields and features of a record which satisfy a certain condition, the procedure <CODE>Record<SPAN class="keyword">.</SPAN>takeWhile</CODE> selects only the starting sequence of features and fields which fulfill this condition. The procedure <CODE>Record<SPAN class="keyword">.</SPAN>dropWhile</CODE> is dual: It computes a record with the remaining features and fields. <CODE>Record<SPAN class="keyword">.</SPAN>takeWhileDrop</CODE> computes both records. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>takeWhile&nbsp;a(1&nbsp;4&nbsp;7&nbsp;a:&nbsp;3&nbsp;b:&nbsp;6&nbsp;c:&nbsp;5)&nbsp;IsOdd}</CODE></BLOCKQUOTE><P> yields as output <CODE>a(1)</CODE>, whereas </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>dropWhile&nbsp;a(1&nbsp;4&nbsp;7&nbsp;a:&nbsp;3&nbsp;b:&nbsp;6&nbsp;c:&nbsp;5)&nbsp;IsOdd}</CODE></BLOCKQUOTE><P> yields <CODE>a(2:&nbsp;4&nbsp;3:&nbsp;7&nbsp;a:&nbsp;3&nbsp;b:&nbsp;6&nbsp;c:&nbsp;5)</CODE> as output. Both records can be computed simultaneously by </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>takeDropWhile&nbsp;&nbsp;a(1&nbsp;4&nbsp;7&nbsp;a:&nbsp;3&nbsp;b:&nbsp;6&nbsp;c:&nbsp;5)&nbsp;IsOdd&nbsp;?R2&nbsp;?R3}</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>takeWhileInd</CODE> <A name="label256"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>takeWhileInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>dropWhileInd</CODE> <A name="label258"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>dropWhileInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DT><CODE>takeDropWhileInd</CODE> <A name="label260"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>takeDropWhileInd&nbsp;</CODE><CODE>+<I>R1</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R2</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>R3</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>are similar to <CODE>Record<SPAN class="keyword">.</SPAN>takeWhile</CODE>, <CODE>Record<SPAN class="keyword">.</SPAN>dropWhile</CODE> and <CODE>Record<SPAN class="keyword">.</SPAN>takeDropWhile</CODE> but the binary boolean function&nbsp;<CODE><I>P</I></CODE> is applied with the current index as first actual argument. </P></DD><DT><CODE>waitOr</CODE> <A name="label262"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{Record<SPAN class="keyword">.</SPAN>waitOr&nbsp;</CODE><CODE>+<I>R</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>LI</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>blocks until at least one field of&nbsp;<CODE>+<I>R</I></CODE> is determined. Returns the feature <CODE><I>LI</I></CODE> of a determined field. Raises an exception if <CODE><I>R</I></CODE> is not a proper record, that is, if <CODE><I>R</I></CODE> is a literal. </P><P> For example, </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>waitOr&nbsp;a(_&nbsp;b:&nbsp;1)}</CODE></BLOCKQUOTE><P> returns&nbsp;<CODE>b</CODE> while </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>waitOr&nbsp;a(2&nbsp;b:&nbsp;_)}</CODE></BLOCKQUOTE><P> returns&nbsp;<CODE>1</CODE>, and </P><BLOCKQUOTE class="code"><CODE>{Record<SPAN class="keyword">.</SPAN>waitOr&nbsp;a(_&nbsp;b:&nbsp;_)}</CODE></BLOCKQUOTE><P> blocks. </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html">- Up -</A></TD><TD><A href="tuple.html#section.records.tuples">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
