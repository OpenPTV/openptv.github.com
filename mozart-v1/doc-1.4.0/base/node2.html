<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2 Type Structure and Description Format</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="value.html#chapter.values">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.typestruct"><H1><A name="chapter.typestruct">2 Type Structure and Description Format</A></H1><H2><A name="label3">2.1 Type Structure</A></H2><P> Types are sets of values of the Oz universe which share a common structure and common operations. Types are divided into primary types and secondary types. </P><DIV class="unnumbered"><H3><A name="label4">Primary Types</A></H3><P> <A name="label5"></A><A name="label6"></A>  The primary types of Oz are depicted in <A href="node2.html#figure.types">Figure&nbsp;2.1</A>. Primary types provide a classification of values in the Oz Universe such that any two different subtypes of some primary type are disjoint. To check for a value to belong to a primary type, only its top-level constructor needs to be tested. Note that implementations of Oz are free to introduce more primary types (so called <EM>extensions</EM>) as immediate subtypes of either ``value'' or ``chunk''. </P><DIV class="apropos"><P class="margin">Numbers</P><P> Numbers are either integers or floats. </P></DIV><DIV class="apropos"><P class="margin">Literals</P><P> Literals are either atoms or names. </P></DIV><DIV class="apropos"><P class="margin">Tuples</P><P> Tuples are special records whose features are the integers from 1 to&nbsp;<I>n</I> for some integer&nbsp;<I>n</I>, <I>n</I><CODE>&nbsp;<SPAN class="keyword">&gt;=</SPAN>&nbsp;0</CODE>. </P></DIV><DIV class="apropos"><P class="margin">Procedures</P><P> Procedures are classified according to their arity. We speak about <I>n</I>-ary procedures. </P></DIV><DIV class="apropos"><P class="margin">Chunks</P><P> Chunks serve to represent abstract data structures. They are defined similarly to records but provide only a restricted set of operations. This makes it possible to hide some or all of their features. Typical chunks are objects and classes, locks and ports, and arrays and dictionaries. There are chunks which do not belong to these types. </P></DIV></DIV><DIV class="unnumbered"><DIV class="maxi" id="figure.types"><TABLE width="100%"><TR><TD><HR><P><A name="figure.types"></A></P><P> </P><DIV align="center"><IMG alt="" src="latex1.png"></DIV><P> </P><P class="caption"><STRONG>Figure&nbsp;2.1:</STRONG> Standard Primary Types in Oz.</P><HR></TD></TR></TABLE></DIV><H3><A name="label7">Secondary Types</A></H3><P> Secondary types are additional types for which Oz provides standard procedures or modules. </P><DIV class="apropos"><P class="margin">Features</P><P> <A name="label8"></A><EM class="noindex">Features</EM> are either integers or literals. </P></DIV><DIV class="apropos"><P class="margin">Pairs</P><P> A <EM>pair</EM> is a record matching <CODE><SPAN class="string">'#'</SPAN>(_&nbsp;_)</CODE>. </P></DIV><DIV class="apropos"><P class="margin">Lists</P><P> A <EM>list</EM> is either the atom <CODE>nil</CODE> or a record matching <CODE><SPAN class="string">'|'</SPAN>(X&nbsp;Y)</CODE> (or, equivalently, <CODE>X<SPAN class="keyword">|</SPAN>Y</CODE>) such that <CODE>Y</CODE> is again a list. Note that Oz allows cyclic lists which have an infinite unrolling. </P></DIV><DIV class="apropos"><P class="margin">Property Lists</P><P> A <EM>property list</EM> is a list of pairs whose first component is a feature, i.&nbsp;e., a literal or an integer. </P></DIV><DIV class="apropos"><P class="margin">Virtual Strings</P><P> <A name="label9"></A><EM class="noindex">Virtual strings</EM> are used to encode strings. Virtual strings contain atoms, strings, byte strings, integers, and floats, and are closed under tuple construction with the label&nbsp;<CODE><SPAN class="string">'#'</SPAN></CODE>. For more details see <A href="node9.html#chapter.text">Chapter&nbsp;7</A>. </P></DIV></DIV><H2><A name="label10">2.2 Variable Status</A></H2><P> Each node&nbsp;<I>X</I> in the store has exactly one of the following statuses: free, determined, future, or kinded. </P><DIV class="apropos"><P class="margin">Free Variable</P><P> A variable&nbsp;<CODE>X</CODE> is <EM>free</EM> if the constraint store does not know anything about&nbsp;<CODE>X</CODE> apart from variable equalities <CODE>X&nbsp;=&nbsp;Y</CODE>. </P></DIV><DIV class="apropos"><P class="margin">Determined Variable</P><P> A variable&nbsp;<CODE>X</CODE> is <EM>determined</EM> if the constraint store entails <CODE>X&nbsp;=&nbsp;</CODE><CODE><I>N</I></CODE> for some number&nbsp;<CODE><I>N</I></CODE>, or if it entails <CODE>X&nbsp;=&nbsp;</CODE><CODE><I>f</I></CODE><CODE>(</CODE><CODE><I>a1</I></CODE><CODE>:&nbsp;_&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>an</I></CODE><CODE>:&nbsp;_)</CODE> for some label&nbsp;<CODE><I>f</I></CODE> and the arity <CODE>[</CODE><CODE><I>a1</I></CODE><CODE>&nbsp;</CODE>...<CODE>&nbsp;</CODE><CODE><I>an</I></CODE><CODE>]</CODE>, or if it entails <CODE>X&nbsp;=&nbsp;</CODE><I>Y</I> for some byte string, procedure, cell, chunk, space or thread&nbsp;<CODE><I>Y</I></CODE>. </P></DIV><DIV class="apropos"><P class="margin">Future</P><P> A variable&nbsp;<CODE>X</CODE> is <EM>future</EM> if the constraint store entails <CODE>X&nbsp;=&nbsp;</CODE><CODE><I>F</I></CODE> for some future&nbsp;<CODE><I>F</I></CODE>. </P></DIV><DIV class="apropos"><P class="margin">Kinded Variable</P><P> A variable&nbsp;<CODE>X</CODE> is <EM>kinded</EM> if it is neither free nor determined nor future. </P></DIV><DIV id="section.typestruct.format"><H2><A name="section.typestruct.format">2.3 Description Format</A></H2><P> Every standard procedure has an associated signature of the form </P><BLOCKQUOTE class="code"><CODE>{Map&nbsp;</CODE><CODE>+<I>Xs</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>P</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Ys</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> which specifies its arity, as well as types and modes of its arguments. </P><DIV class="unnumbered"><H3><A name="label11">Types</A></H3><P> The type of an argument is indicated by its name, using the abbreviations summarized in the following table: </P><TABLE align="center" bgcolor="#f0f0e0"><TR valign="top"><TH><P>Abbreviation</P></TH><TH><P>Type</P></TH></TR><TR valign="top"><TD><P><CODE><I>A</I></CODE></P></TD><TD><P>atom</P></TD></TR><TR valign="top"><TD><P><CODE><I>B</I></CODE></P></TD><TD><P>bool</P></TD></TR><TR valign="top"><TD><P><CODE><I>C</I></CODE></P></TD><TD><P>chunk</P></TD></TR><TR valign="top"><TD><P><CODE><I>F</I></CODE></P></TD><TD><P>float</P></TD></TR><TR valign="top"><TD><P><CODE><I>I</I></CODE></P></TD><TD><P>integer</P></TD></TR><TR valign="top"><TD><P><CODE><I>K</I></CODE></P></TD><TD><P>class</P></TD></TR><TR valign="top"><TD><P><CODE><I>L</I></CODE></P></TD><TD><P>literal</P></TD></TR><TR valign="top"><TD><P><CODE><I>N</I></CODE></P></TD><TD><P>name</P></TD></TR><TR valign="top"><TD><P><CODE><I>O</I></CODE></P></TD><TD><P>object</P></TD></TR><TR valign="top"><TD><P><CODE><I>P</I></CODE></P></TD><TD><P>procedure</P></TD></TR><TR valign="top"><TD><P><CODE><I>R</I></CODE></P></TD><TD><P>record</P></TD></TR><TR valign="top"><TD><P><CODE><I>S</I></CODE></P></TD><TD><P>string</P></TD></TR><TR valign="top"><TD><P><CODE><I>T</I></CODE></P></TD><TD><P>tuple</P></TD></TR><TR valign="top"><TD><P><CODE><I>U</I></CODE></P></TD><TD><P>unit</P></TD></TR><TR valign="top"><TD><P><CODE><I>V</I></CODE></P></TD><TD><P>virtual string</P></TD></TR><TR valign="top"><TD><P><CODE><I>X</I></CODE> <CODE><I>Y</I></CODE> <CODE><I>Z</I></CODE></P></TD><TD><P>value</P></TD></TR><TR valign="top"><TD><P><CODE><I>FI</I></CODE></P></TD><TD><P>number</P></TD></TR><TR valign="top"><TD><P><CODE><I>LI</I></CODE></P></TD><TD><P>feature</P></TD></TR><TR valign="top"><TD><P><CODE><I>AFI</I></CODE></P></TD><TD><P>atom, float, or int</P></TD></TR><TR valign="top"><TD><P><CODE><I>PO</I></CODE></P></TD><TD><P>unary procedure or object</P></TD></TR><TR valign="top"><TD><P><CODE><I>Xs</I></CODE></P></TD><TD><P>lists of elements of type&nbsp;<CODE><I>X</I></CODE></P></TD></TR></TABLE><P> We use indices such as <CODE><I>R1</I></CODE> or&nbsp;<CODE><I>R2</I></CODE> to disambiguate several occurrences of arguments of the same type. We combine these abbreviations as in&nbsp;<CODE><I>FI</I></CODE> meaning ``float or integer'' (i.&nbsp;e., number) or <CODE><I>LI</I></CODE> meaning ``literal or integer'' (i.&nbsp;e., feature). We use the plural-``s'' suffix to indicate lists of values of a certain type. For instance, <CODE><I>Is</I></CODE> stands for a list of integers. This suffix can be repeated to indicate lists of lists etc. Additionally, these arguments can be prefixed as in <CODE><I>LowI</I></CODE>, which indicates that the integer represents a lower bound. </P></DIV><DIV class="unnumbered"><H3><A name="label12">Modes</A></H3><DIV class="apropos"><P class="margin">Modes <CODE>+<I></I></CODE>, <CODE>?<I></I></CODE>, none</P><P> The arguments of procedures can have one of four modes which are indicated by a symbol (<CODE>+<I></I></CODE>, <CODE>?<I></I></CODE>, none) attached to the arguments in the signature. </P></DIV><P> Modes indicate the synchronisation behaviour of a procedure. The application of a procedure&nbsp;<CODE>P</CODE> waits until its inputs (<CODE>+<I></I></CODE>) are determined. If the input arguments are well-typed, <CODE>P</CODE> will return outputs (<CODE>?<I></I></CODE>) of the specified types. Ill-typed input arguments will raise a type error exception. Types may be incompletely checked, especially those of of output arguments: This happens when a value needs not be completely processed to perform an operation, e.&nbsp;g., in <CODE>List<SPAN class="keyword">.</SPAN>dropWhile</CODE>. </P><P> Occasionally, signatures of the base language will use the input mode&nbsp;<CODE>*<I></I></CODE>. Unless one uses any primitives from the constraint extensions, this is identical with&nbsp;<CODE>+<I></I></CODE>. </P></DIV><DIV class="unnumbered"><H3><A name="label13">Naming Conventions</A></H3><DIV class="apropos"><P class="margin">Aliases</P><P> </P></DIV><P> Some of the standard values are so frequent that a special name is provided for them. For example, <CODE>List<SPAN class="keyword">.</SPAN>map</CODE> is also available as <CODE>Map</CODE>. The signature of <CODE>Map</CODE> occurring in the description of module <CODE>List</CODE> (see <A href="list.html#section.records.lists">Section&nbsp;6.3</A>) says that the procedure <CODE>List<SPAN class="keyword">.</SPAN>map</CODE> is available via the abbreviation <CODE>Map</CODE>. </P><DIV class="apropos"><P class="margin">Procedure Names</P><P> Given the signature </P><BLOCKQUOTE class="code"><CODE>{</CODE><I>procname</I><CODE>&nbsp;</CODE>...<CODE>}</CODE></BLOCKQUOTE><P> in the description of the module <I>module</I>, the procedure is available as: </P><UL><LI><P><I>procname</I>, provided <I>procname</I> is just a variable; </P></LI><LI><P><I>module</I><CODE><SPAN class="keyword">.</SPAN></CODE><I>procname'</I>, where <I>procname'</I> can be obtained from <I>procname</I> by downcasing the first letter and deleting the string <I>module</I>. </P></LI></UL><P> For example, the test for lists is available as <CODE>IsList</CODE> and as <CODE>List<SPAN class="keyword">.</SPAN>is</CODE>. </P></DIV><DIV class="apropos"><P class="margin">Infix Notation</P><P> For very frequent procedures like arithmetic operations, there exists a convenient infix notation (see <A href="node14.html#chapter.infix">Chapter&nbsp;11</A>). By convention, the procedure names as they appear in the modules are the infix operators as atoms (i.&nbsp;e., wrapped in quotes). For instance, <CODE>Number<SPAN class="keyword">.</SPAN><SPAN class="string">'+'</SPAN></CODE> and <CODE>Value<SPAN class="keyword">.</SPAN><SPAN class="string">'&lt;'</SPAN></CODE> have an infix notation using the operators <CODE><SPAN class="keyword">+</SPAN></CODE> and <CODE><SPAN class="keyword">&lt;</SPAN></CODE>. </P></DIV></DIV><DIV class="unnumbered"><H3><A name="label14">A Note on the Examples</A></H3><P> Several examples used in this document assume a unary procedure <A name="label15"></A><SPAN class="index"><CODE>Browse</CODE></SPAN> in the environment, which is supposed to display its argument value in a tool called <EM>browser</EM>.</P></DIV></DIV></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node1.html#chapter.introduction">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="value.html#chapter.values">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
