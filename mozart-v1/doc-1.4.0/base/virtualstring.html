<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>7.4 Virtual Strings</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="bytestring.html#section.text.bytestrings">&lt;&lt; Prev</A></TD><TD><A href="node9.html">- Up -</A></TD></TR></TABLE><DIV id="section.text.virtualstrings"><H2><A name="section.text.virtualstrings">7.4 Virtual Strings</A></H2><P> <A name="label457"></A> The module <A name="label458"></A><SPAN class="index"><CODE>VirtualString</CODE></SPAN> contains procedures operating on virtual strings. Virtual strings are designed as a convenient way to combine strings, byte strings, atoms, integers and floats to compound strings without explicit concatenation and conversion. </P><DL><DT><A name="label459"></A><SPAN class="index"><CODE>IsVirtualString</CODE></SPAN> <A name="label461"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>is&nbsp;</CODE><CODE>+<I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>B</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>tests whether <CODE><I>X</I></CODE> is a virtual string. Virtual strings are defined recursively as the set of all integers, floats, atoms, strings, byte strings, and tuples with label&nbsp;<CODE><SPAN class="string">'#'</SPAN></CODE> whose subtrees are virtual strings. </P></DD><DT><CODE>toString</CODE> <A name="label463"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;</CODE><CODE>+<I>V</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>S</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts a virtual string&nbsp;<CODE><I>V</I></CODE> to a string&nbsp;<CODE><I>S</I></CODE>. </P><P> The transformation is straightforward: Atoms (except <CODE>nil</CODE> and&nbsp;<CODE><SPAN class="string">'#'</SPAN></CODE>), integers, floats and byte strings are transformed into strings using <CODE>Atom<SPAN class="keyword">.</SPAN>toString</CODE>, <CODE>Int<SPAN class="keyword">.</SPAN>toString</CODE>, <CODE>Float<SPAN class="keyword">.</SPAN>toString</CODE>, and <CODE>ByteString<SPAN class="keyword">.</SPAN>toString</CODE> respectively, where in numbers <CODE>-</CODE> is used instead of <CODE>~</CODE>. A tuple with label&nbsp;<CODE><SPAN class="string">'#'</SPAN></CODE> is transformed by concatenation of the transformed subtrees. Note that both <CODE>nil</CODE> and <CODE><SPAN class="string">'#'</SPAN></CODE> denote the empty string. </P><P> The following relation holds for all virtual strings <CODE>V1</CODE> and&nbsp;<CODE>V2</CODE>: </P><BLOCKQUOTE class="code"><CODE>{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;V1<SPAN class="keyword">#</SPAN>V2}<BR>=&nbsp;{Append<BR>&nbsp;&nbsp;&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;V1}<BR>&nbsp;&nbsp;&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;V2}}</CODE></BLOCKQUOTE><P> Thus, <CODE>VirtualString<SPAN class="keyword">.</SPAN>toString</CODE> maps <CODE><SPAN class="keyword">#</SPAN></CODE> homomorphically to <CODE>Append</CODE>. </P></DD><DT><CODE>toAtom</CODE> <A name="label465"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>toAtom&nbsp;</CODE><CODE>+<I>V</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>A</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts a virtual string&nbsp;<CODE><I>V</I></CODE> to an atom&nbsp;<CODE><I>A</I></CODE>. </P><P> This procedure can be defined as: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">VirtualString.toAtom</SPAN>&nbsp;V}<BR>&nbsp;&nbsp;&nbsp;{String<SPAN class="keyword">.</SPAN>toAtom&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;V}}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>toByteString</CODE> <A name="label467"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>toByteString&nbsp;</CODE><CODE>+<I>V</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>ByteString</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>converts a virtual string&nbsp;<CODE><I>V</I></CODE> to a byte string <CODE>ByteString</CODE>. </P><P> This procedure is a synonym of <CODE>ByteString<SPAN class="keyword">.</SPAN>make</CODE> (which see). </P></DD><DT><CODE>length</CODE> <A name="label469"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>length&nbsp;</CODE><CODE>+<I>V</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>I</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns the length of a virtual string in characters. Can be defined as: </P><BLOCKQUOTE class="code"><CODE>{Length&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString&nbsp;</CODE><CODE><I>V</I></CODE><CODE>}&nbsp;</CODE><CODE><I>I</I></CODE><CODE>}</CODE></BLOCKQUOTE><P> </P></DD><DT><CODE>changeSign</CODE> <A name="label471"></A> </DT><DD><BLOCKQUOTE class="synopsis"><P><CODE>{VirtualString<SPAN class="keyword">.</SPAN>changeSign&nbsp;</CODE><CODE>+<I>V1</I></CODE><CODE>&nbsp;</CODE><CODE><I>X</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>V2</I></CODE><CODE>}</CODE> </P></BLOCKQUOTE></DD><DD><P>returns a virtual string derived from&nbsp;<CODE><I>V1</I></CODE> where all occurrences of the unary minus sign for integers and floats are replaced by&nbsp;<CODE><I>X</I></CODE>. </P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="bytestring.html#section.text.bytestrings">&lt;&lt; Prev</A></TD><TD><A href="node9.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
