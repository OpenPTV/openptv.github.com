<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>5.2 Stream Sockets</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#section.sockets.nutshell">&lt;&lt; Prev</A></TD><TD><A href="node10.html">- Up -</A></TD><TD><A href="node13.html#section.sockets.accept">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="section.sockets.stream"><H2><A name="section.sockets.stream">5.2 Stream Sockets</A></H2><P>Instead of giving detailed explanations, we will follow an example tailored to understand how stream sockets for the Internet. For this purpose, we use the class <CODE>Open<SPAN class="keyword">.</SPAN>socket</CODE>. </P><H3><A name="label89">5.2.1 Initiating a Connection</A></H3><P>Before any data between the server and the client can be exchanged, they must initiate a connection. How to obtain a connection is shown in <A href="node12.html#opprog-fig-stream">Figure&nbsp;5.1</A>. We will perform the different steps shown in the figure as an example. </P><P></P><DIV id="opprog-fig-stream"><HR><P><A name="opprog-fig-stream"></A></P><DIV align="center"><IMG alt="" src="latex1.png"></DIV><P class="caption"><STRONG>Figure&nbsp;5.1:</STRONG> Initiating a Stream Connection.</P><HR></DIV><P> </P><P>The starting point for server and client are the topmost ovals on the two sides of the figure. We first turn our attention to the <CODE>Server</CODE> object. Basic initialization is performed by: </P><DL class="anonymous"><DD class="code"><CODE>Server&nbsp;=&nbsp;{New&nbsp;Open<SPAN class="keyword">.</SPAN>socket&nbsp;init}</CODE></DD></DL><P> <A name="label91"></A> <A name="label93"></A> </P><P>After execution of this message, <CODE>Server</CODE> has initialized the local data structures it needs. </P><P>After locally initializing the socket we have to provide it with a global name. We use this global name for connecting our client to this server. Feed: </P><DL class="anonymous"><DD class="code"><CODE>{Server&nbsp;bind(port:{Browse})}</CODE></DD></DL><P> <A name="label95"></A> </P><P>The Internet protocol services generate a so-called port number. The port number is shown in the browser window. We refer to this number as <CODE>OurPort</CODE> later on. </P><P>The combination of the host computer on which Oz is running and the generated port number gives a unique address within the Internet domain. So any other party in the Internet domain may use this pair to refer unambiguously to this socket. </P><P>As next step, we signal that our socket is willing to accept connections from another socket. To do so, we feed: </P><DL class="anonymous"><DD class="code"><CODE>{Server&nbsp;listen}</CODE></DD></DL><P> <A name="label97"></A> </P><P>Now we are ready to accept our connection. Typing: </P><DL class="anonymous"><DD class="code"><CODE>{Browse&nbsp;H<SPAN class="keyword">#</SPAN><SPAN class="string">&quot;:&nbsp;&quot;</SPAN><SPAN class="keyword">#</SPAN>P}<BR>{Server&nbsp;accept(host:H&nbsp;port:P)}</CODE></DD></DL><P> <A name="label99"></A> does nothing at the moment. But if a connection request is signaled at port <CODE>OurPort</CODE> the connection is accepted. In this case <CODE>H</CODE> is bound to a string giving the name of the computer the connection request was received from. In the same way <CODE>P</CODE> is bound to the respective port. </P><P>The next step connects the <CODE>Client</CODE> to the <CODE>Server</CODE>. </P><DL class="anonymous"><DD class="code"><CODE>Client&nbsp;=&nbsp;{New&nbsp;Open<SPAN class="keyword">.</SPAN>socket&nbsp;init}</CODE></DD></DL><P> <A name="label101"></A> initializes our client object<A name="label103"></A>. </P><P>By typing </P><DL class="anonymous"><DD class="code"><CODE>{Client&nbsp;connect(host:localhost&nbsp;port:OurPort)}</CODE></DD></DL><P> <A name="label105"></A> our client connects to the port <CODE>OurPort</CODE> on the same computer (thus the virtual string <CODE>localhost</CODE>)<A name="label106"></A>. </P><P>Since our server suspended on a connection request at port <CODE>OurPort</CODE> it now resumes, and the name of the host and the port appears in the Browser window.</P><H3><A name="label107">5.2.2 Convenient Connection Establishment</A></H3><P>This was the whole story in detail, but for convenience we provide two methods, which perform the complete connection establishment. </P><P>Instead of the various method applications, the following suffices for the server: </P><BLOCKQUOTE class="code"><CODE>{Server&nbsp;server(host:</CODE><CODE><I>H</I></CODE><CODE>&nbsp;port:</CODE><CODE><I>P</I></CODE><CODE>)}</CODE></BLOCKQUOTE><P> <A name="label109"></A> Here <CODE><I>P</I></CODE> is bound to the automatically generated port number. After a connection has been accepted on this port, <CODE><I>H</I></CODE> is bound to the string containing the name of the connecting host. </P><P>Symmetrically, for the client side, one simply can use: </P><BLOCKQUOTE class="code"><CODE>{Client&nbsp;client(host:&nbsp;</CODE><CODE><I>HostToConnectTo</I></CODE><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;port:&nbsp;</CODE><CODE><I>PortToConnectTo</I></CODE><CODE>)}</CODE></BLOCKQUOTE><P> <A name="label111"></A></P><H3><A name="label112">5.2.3 Exchanging Data</A></H3><P>Now we can await data at our server by feeding </P><DL class="anonymous"><DD class="code"><CODE>{Server&nbsp;read(list:{Browse})}</CODE></DD></DL><P> <A name="label114"></A> </P><P>Sending data from our client can be accomplished via </P><DL class="anonymous"><DD class="code"><CODE>{Client&nbsp;write(vs:<SPAN class="string">'Hello,&nbsp;good'</SPAN><SPAN class="keyword">#</SPAN><SPAN class="string">&quot;&nbsp;old&nbsp;Server!&quot;</SPAN>)}</CODE></DD></DL><P> <A name="label116"></A> and in the browser window (on the server side) the message appears. </P><P>By simply flipping <CODE>Server</CODE> and <CODE>Client</CODE> in the last two expressions fed, you can send data from the server to the client. </P><P>Notice, however, that in this example server and client are created in the same operating system process on the same host computer. Instead we could have used two different processes and two different host computers even running two different operating systems. </P><P></P><H3><A name="label117">5.2.4 Concurrency Issues</A></H3><P>Both reading and writing to a socket might not be possible immediately. Possible reasons include: </P><OL type="1"><LI><P>The data to be written is not yet bound to a virtual string.</P></LI><LI><P>There is no data to be read at the moment.</P></LI><LI><P>The socket can not transfer data over the network at the moment.</P></LI></OL><P> </P><P>In this case access to the socket has to be synchronized in some way. The following invariant is kept: all <CODE>read</CODE> messages are performed in the order they were received by the object. The same holds for all <CODE>write</CODE> messages. But there is no order between <CODE>read</CODE>s or <CODE>write</CODE>s. Both the <CODE>read</CODE> and the <CODE>write</CODE> method reduce only when the request can be served. </P><P>If you want to make sure that both all <CODE>read</CODE> and <CODE>write</CODE> requests are finished, you can use the method <CODE>flush</CODE>.</P><H3><A name="label118">5.2.5 Disconnecting</A></H3><P>If there is no further data to be exchanged between client and server, they should be disconnected. The simplest way to do so is by feeding </P><DL class="anonymous"><DD class="code"><CODE>{Server&nbsp;close}<BR>{Client&nbsp;close}</CODE></DD></DL><P> <A name="label120"></A> </P><P>Suppose that the server closes before the client, and the client is still sending data to the server. In this case the data will still arrive at the socket. And only after some time the data will be thrown away, consuming valuable memory resources. To prevent from this, you can signal that you are not interested in receiving any messages, simply by typing (before closing the object!) </P><BLOCKQUOTE class="code"><CODE>{Server&nbsp;shutDown(how:&nbsp;[receive])}</CODE></BLOCKQUOTE><P> <A name="label122"></A> </P><P>If we are not interested in sending data anymore, we can inform the operating system that we are indeed not willing to send anything more, thus </P><BLOCKQUOTE class="code"><CODE>{Server&nbsp;shutDown(how:&nbsp;[send])}</CODE></BLOCKQUOTE><P> <A name="label124"></A> </P><P>Both applications could have been combined into </P><BLOCKQUOTE class="code"><CODE>{Server&nbsp;shutDown(how:&nbsp;[receive&nbsp;send])}</CODE></BLOCKQUOTE><P> <A name="label126"></A></P><H3><A name="label127">5.2.6 Exceptions</A></H3><P>The methods of the class <CODE>Open<SPAN class="keyword">.</SPAN>socket</CODE> might raise exceptions of the same format as already described for the class <CODE>Open<SPAN class="keyword">.</SPAN>file</CODE>, see <A href="node6.html#section.files.basic">Section&nbsp;3.1</A>.</P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node11.html#section.sockets.nutshell">&lt;&lt; Prev</A></TD><TD><A href="node10.html">- Up -</A></TD><TD><A href="node13.html#section.sockets.accept">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
