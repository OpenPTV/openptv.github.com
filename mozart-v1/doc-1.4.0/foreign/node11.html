<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>7.4 Accessing arguments</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#section.cif.decl">&lt;&lt; Prev</A></TD><TD><A href="node7.html">- Up -</A></TD><TD><A href="node12.html#section.cif.tt">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="section.cif.aa"><H2><A name="section.cif.aa">7.4 Accessing arguments</A></H2><H3><A name="label29">7.4.1 Accessing input arguments</A></H3><P> </P><DL><DT><CODE>OZ_declareTerm(n,var)</CODE> <A name="label31"></A></DT><DD><P>Declares a new variable of type <CODE>OZ_Term</CODE> named <CODE>var</CODE>, which is initialized with the value of the <CODE>n</CODE>-th (counting starts from zero) input argument.</P><P>In case you plan to use unification for passing output arguments, you still have to pass the logic variable with which you want to unify as <EM>input</EM> argument. </P></DD><DT><CODE>OZ_declareDetTerm(n,var)</CODE><A name="label33"></A></DT><DD><P>Works like <CODE>OZ_declareTerm</CODE> but additionally suspends if the input argument is a free variable. </P></DD><DT><CODE>OZ_declareInt(n,var)</CODE><A name="label35"></A></DT><DD><P>The function expects in input argument number <CODE>n</CODE> an Oz integer. It then declares a variable named <CODE>var</CODE> of type <CODE><SPAN class="type">int</SPAN></CODE> and initializes <CODE>var</CODE> with the value of this argument. The macro raises an exception if the argument is ill typed and suspends if the argument is an unbound variable. </P></DD><DT><CODE>OZ_declareFloat(n,var)</CODE><A name="label37"></A></DT><DD><P>Works like <CODE>OZ_declareInt</CODE> but expectes an Oz float and declares a variable of type <CODE><SPAN class="type">double</SPAN></CODE>. </P></DD><DT><CODE>OZ_declareAtom(n,var)</CODE><A name="label39"></A></DT><DD><P>Works like <CODE>OZ_declareInt</CODE> but expectes an Oz atom and declares a variable of type <CODE><SPAN class="type">char</SPAN>&nbsp;*</CODE>. </P></DD><DT><CODE>OZ_declareVirtualString(n,var)</CODE><A name="label41"></A></DT><DD><P>Works like <CODE>OZ_declareInt</CODE> but expectes an Oz virtual string and declares a variable of type <CODE><SPAN class="type">char</SPAN>&nbsp;*</CODE>. </P></DD><DT><CODE>OZ_declareVS(n,var,len)</CODE><A name="label43"></A></DT><DD><P>Like <CODE>OZ_declareVirtualString</CODE>, but additionally sets <CODE>len</CODE> to the size of the result. </P></DD><DT><CODE>OZ_declareBool(n,var)</CODE><A name="label45"></A></DT><DD><P>Declares a variable of type <CODE><SPAN class="type">int</SPAN></CODE> named <CODE>var</CODE>, which is non-zero iff the <CODE>n</CODE>-th argument is equal to <CODE><SPAN class="reference">true</SPAN></CODE>. </P></DD></DL><P> The above macros always declare a new C variable and then do some checks. Therefore, in C (not in C++) only one of them can be used only at the start of a new block statement. For this reason there is also a second set of macros named <CODE>OZ_set*</CODE> that expect that their second argument has already been declared. Thus in C++ you can use </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;OZ_declareAtom(0,mystring);<BR>&nbsp;&nbsp;OZ_declareInt(1,myint);</CODE></BLOCKQUOTE><P> whereas in plain C you have to write </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<SPAN class="type">char</SPAN>&nbsp;*<SPAN class="variablename">mystring</SPAN>;<BR>&nbsp;&nbsp;<SPAN class="type">int</SPAN>&nbsp;<SPAN class="variablename">myint</SPAN>;<BR>&nbsp;&nbsp;OZ_setAtom(0,mystring);<BR>&nbsp;&nbsp;OZ_setInt(1,myint);</CODE></BLOCKQUOTE><P> </P><H3><A name="label46">7.4.2 Accessing output arguments</A></H3><P></P><DL><DT><CODE>OZ_out(n)</CODE><A name="label48"></A></DT><DD><P>Abstract access to output argument number <CODE>n</CODE> (counting starts with 0). Should only be used for writing an output argument and never for reading. Usage is like </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;OZ_out(3)&nbsp;=&nbsp;OZ_atom(<SPAN class="string">&quot;myResult&quot;</SPAN>);</CODE></BLOCKQUOTE><P> This macro should only be used in case a function returns more than one value. For returning values in the first output argument one of the functions below should be used. </P></DD><DT><CODE>OZ_RETURN(V)</CODE><A name="label50"></A></DT><DD><P>Returns from the C function with output value <CODE>V</CODE>. It is a macro which expands to </P><BLOCKQUOTE class="code"><CODE>&nbsp;&nbsp;<SPAN class="keyword">return</SPAN>&nbsp;(OZ_out(0)=V,OZ_ENTAILED)</CODE></BLOCKQUOTE><P></P></DD></DL><P> For convenience we also provide the following macros: </P><DL><DT><CODE>OZ_RETURN_INT(I)</CODE><A name="label52"></A></DT><DD><P>Return a C integer. Expands to <CODE>OZ_RETURN(OZ_int(I))</CODE> </P></DD><DT><CODE>OZ_RETURN_ATOM(A)</CODE><A name="label54"></A></DT><DD><P>Return a C integer. Expands to <CODE>OZ_RETURN(OZ_atom(A))</CODE> </P></DD><DT><CODE>OZ_RETURN_STRING(S)</CODE><A name="label56"></A></DT><DD><P>Return a C integer. Expands to <CODE>OZ_RETURN(OZ_string(S))</CODE> </P></DD><DT><CODE>OZ_RETURN_BOOL(X)</CODE><A name="label58"></A></DT><DD><P>Returns <CODE><SPAN class="reference">false</SPAN></CODE> if X equals to 0, <CODE><SPAN class="reference">true</SPAN></CODE> otherwise. Expands to <CODE>OZ_RETURN((X)?OZ_true():OZ_false())</CODE> </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node10.html#section.cif.decl">&lt;&lt; Prev</A></TD><TD><A href="node7.html">- Up -</A></TD><TD><A href="node12.html#section.cif.tt">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~mehl/">Michael&nbsp;Mehl</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~scheidhr/">Ralf&nbsp;Scheidhauer</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
