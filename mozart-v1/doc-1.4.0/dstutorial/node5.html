<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>5 Fault-Tolerant Examples</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.failure">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.limits">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.ft_examples"><H1><A name="chapter.ft_examples">5 Fault-Tolerant Examples</A></H1><P>This chapter shows how to use the failure model to build robust distributed applications. We first present basic fault-tolerant versions of common language operations. Then we present fault-tolerant versions of the server examples. We conclude with a bigger example: reliable objects with recovery. </P><H2><A name="label250">5.1 A fault-tolerant broadcast channel</A></H2><P>We will show how to define a simple open fault-tolerant broadcast channel. The example uses almost every concept seen in the former chapter. This is a useful abstraction; for example it can be used as the heart of a chat tool such as IRC. The service has a client/server structure and is aware of permanent crashes of clients or the server. In case of a client crash, the system continues to work. In case of a server crash, the service will no longer be available. Clients receive notification of this. </P><P>Users access the broadcast service through a local client. The user creates a client object that is initialized with a ticket provided by the server. The client object has a method <CODE>sendMessage</CODE> for broadcasting a message. When the client object receives a message or is notified of a client or server crash, it informs the user by calling a user-defined procedure with one argument. The following events are possible: </P><UL><LI><P><CODE>message(UserID&nbsp;Mess)</CODE>: receive the message <CODE>Mess</CODE> from client <CODE>UserID</CODE>.</P></LI><LI><P><CODE>registered(UserID)</CODE>: the client identified by <CODE>UserID</CODE> has registered to the channel.</P></LI><LI><P><CODE>unregistered(UserID)</CODE>: the client identified by <CODE>UserID</CODE> has unregistered from the channel.</P></LI><LI><P><CODE>permClient(UserID)</CODE>: the client identified by <CODE>UserID</CODE> has crashed.</P></LI><LI><P><CODE>permServer</CODE>: the broadcast channel server has crashed.</P></LI></UL><P></P><P>We give an example of how the broadcast channel is used, and we follow this by showing its implementation. We first show how to use and implement a <EM>non-fault-tolerant</EM> broadcast channel, and then we show the small extensions needed for it to detect client and server crashes. </P><H3><A name="label251">5.1.1 Sample use (no fault tolerance)</A></H3><P>First we create the channel server. The server is a port. To connect with clients, the server is made available via a ticket with unlimited connection ability. The ticket is available through a publicly-accessible URL. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;S={NewChannelServer}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Pickle<SPAN class="keyword">.</SPAN>save&nbsp;{Connection<SPAN class="keyword">.</SPAN>offerMany&nbsp;S}&nbsp;<SPAN class="string">&quot;/usr/staff/pvr/public_html/chat&quot;</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>A client can be created on another site. We first define on the client's site a procedure <CODE>HandleIncomingMessage</CODE> that will handle incoming messages from the broadcast channel. Then we access to the channel by its URL. Finally, we create a local client and give it our handler procedure. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">HandleIncomingMessage</SPAN>&nbsp;M}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Show&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;M&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;message(From&nbsp;Content)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;From<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;:&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>Content<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;registered(UserID)&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;UserID<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;joined&nbsp;us'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregistered(UserID)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;UserID<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;left&nbsp;us'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;S={Connection<SPAN class="keyword">.</SPAN>take&nbsp;{Pickle<SPAN class="keyword">.</SPAN>load&nbsp;<SPAN class="string">&quot;http://www.info.ucl.ac.be/~pvr/chat&quot;</SPAN>}}<BR>&nbsp;&nbsp;&nbsp;C={New&nbsp;ChannelClient&nbsp;init(S&nbsp;<SPAN class="string">'Raphael'</SPAN>&nbsp;HandleIncomingMessage)}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{For&nbsp;1&nbsp;1000&nbsp;1<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;I}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{C&nbsp;sendMessage(<SPAN class="string">'hello'</SPAN><SPAN class="keyword">#</SPAN>I)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Delay&nbsp;800}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR>&nbsp;&nbsp;&nbsp;{C&nbsp;close}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P><P>In this example we send 1000 messages of the form <CODE><SPAN class="string">'hello'</SPAN><SPAN class="keyword">#</SPAN>I</CODE>, where <CODE>I</CODE> takes successive values from 1 to 1000. Then we close the client. </P><P>Note that the client needs the code of the class <CODE>ChannelClient</CODE>. It is not difficult to avoid that requirement by making the server provide a functor, that the client applies, and which instantiates a <CODE>ChannelClient</CODE>. Please consult the <A href="../apptut/index.html">Application Programming</A> tutorial to learn more about that. </P><DIV id="channel.definition"><H3><A name="channel.definition">5.1.2 Definition (no fault tolerance)</A></H3><P>The whole client-server communication is implemented with ports. They have a well-defined behavior in the case of a permanent crash: the operation <CODE>Send</CODE> has no more effect. We will show the service's implementation in two steps. First, we show how it is written without taking fault tolerance into account. Second, we complete the example by adding fault handling code. This is easy; it amounts to add a few threads monitoring the fault state of the clients and server ports. </P><P>The client is an object with the following structure, while the server is a port created by the function <CODE>NewChannelServer</CODE>. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label252">Client class and server function</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ChannelClient</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">feat</SPAN>&nbsp;client&nbsp;userID<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;server<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node5.html#label253">Client methods</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">NewChannelServer</SPAN>}<BR>&nbsp;&nbsp;&nbsp;Stream<BR>&nbsp;&nbsp;&nbsp;Server={NewPort&nbsp;Stream}<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node5.html#label254">Server's serving procedures</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{Serve&nbsp;Stream}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Server<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> </P><DIV id="client.definition"><H4><A name="client.definition">Client definition</A></H4><P>The client has three methods. The first one, <CODE>init</CODE>, initializes a client with a server port, a user identifier, and a message handler procedure. The second one, <CODE>close</CODE>, deregisters the client from the service. The last one, <CODE>sendMessage</CODE>, sends a message for broadcast. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label253">Client methods</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(Server&nbsp;UserID&nbsp;MsgHandler)<BR>&nbsp;&nbsp;&nbsp;Ms<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">@</SPAN>server&nbsp;=&nbsp;Server<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">self.</SPAN>client={NewPort&nbsp;Ms}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">self.</SPAN>userID=UserID<BR>&nbsp;&nbsp;&nbsp;{Send&nbsp;Server&nbsp;register(<SPAN class="keyword">self.</SPAN>client&nbsp;<SPAN class="keyword">self.</SPAN>userID)}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;{ForAll&nbsp;Ms&nbsp;MsgHandler}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node5.html#label259">Client's server failure handler</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">close</SPAN>()<BR>&nbsp;&nbsp;&nbsp;{Send&nbsp;<SPAN class="keyword">@</SPAN>server&nbsp;unregister(<SPAN class="keyword">self.</SPAN>client&nbsp;<SPAN class="keyword">self.</SPAN>userID)}<BR>&nbsp;&nbsp;&nbsp;server&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<BR><SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">sendMessage</SPAN>(M)<BR>&nbsp;&nbsp;&nbsp;{Send&nbsp;<SPAN class="keyword">@</SPAN>server&nbsp;broadcast(<SPAN class="keyword">self.</SPAN>userID&nbsp;M)}<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P></P><P>The client keeps a reference to the server, to itself for unregistering, and to its user identification. The user-defined handler procedure is directly applied to the stream of incoming messages from the server. In our case, the server only sends events as described above. As we can see, the server must be able to process three kinds of messages: <CODE>register</CODE> and <CODE>unregister</CODE> for managing a client's connection to the server, and <CODE>broadcast</CODE> for sending messages to all clients. </P><P>There is one statement in method <CODE>init</CODE> that is in charge of handling server failures. Currently we assume that statement is <CODE><SPAN class="keyword">skip</SPAN></CODE>, which is the semantics of the handler in case of no failure. </P><P>A user should access the broadcast channel only through a client. </P></DIV><DIV id="server.definition"><H4><A name="server.definition">Server definition</A></H4><P>The server's procedure <CODE>Serve</CODE> must process client messages (at least). In order to avoid inter-client dependencies when forwarding messages, the server creates one thread per registered client, that processes incoming messages to the server, and sends events to that client only. That thread is created when the server observes a registration message from a client. This is possible because of the simplicity of the service. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label254">Server's serving procedures</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Serve</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>T}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;register(Client&nbsp;UserID)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{ServeClient&nbsp;Client&nbsp;UserID&nbsp;X<SPAN class="keyword">|</SPAN>T}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{Serve&nbsp;T}<BR><SPAN class="keyword">end</SPAN>&nbsp;<BR></CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node5.html#label255">Server's simple ServeClient</A><SPAN class="chunkborder">&gt;</SPAN></SPAN></DD></DL><P> </P><P>The procedure <CODE>ServeClient</CODE> creates one thread that sends appropriate event messages to a given client. Currently the thread processes the three messages sent by clients, namely <CODE>register</CODE>, <CODE>unregister</CODE>, and <CODE>broadcast</CODE>. Note how the client thread terminates automatically when its client unregisters: an exception is raised in the processing loop, and caught at the outer level. This makes the registration management implicit in the server. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label255">Server's simple ServeClient</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ServeClient</SPAN>&nbsp;Client&nbsp;UserID&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Loop</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;broadcast(U&nbsp;M)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;message(U&nbsp;M)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;register(C&nbsp;U)&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;registered(C&nbsp;U)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregister(C&nbsp;U)&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;C<SPAN class="keyword">==</SPAN>Client&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;done&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregister(C&nbsp;U)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;unregistered(C&nbsp;U)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Loop&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;{Loop&nbsp;L}&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;done&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> </P><P>Note that clients can receive server messages at different rates. The server does not wait for client acknowledgement when sending messages. However, the order of messages is preserved because the <CODE>ServeClient</CODE> threads all read from the same sequential stream. </P><P>Note that clients are identified uniquely by references to the client object <CODE>Client</CODE>, and not by the client's user ID <CODE>UserID</CODE>. This is visible in the processing of the message <CODE>unregister</CODE>. This means that the channel will work correctly even if there are clients with the same user ID. The users may get confused, but the channel will not. </P></DIV></DIV><H3><A name="label256">5.1.3 Sample use (with fault tolerance)</A></H3><P>The fault-tolerant channel can be used in exactly the same way as the non-fault-tolerant version. The only difference is that the user-defined handler procedure can receive two extra messages, <CODE>permClient</CODE> and <CODE>permServer</CODE>, to indicate client and server crashes: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">UserMessageHandler</SPAN>&nbsp;Msg}<BR>&nbsp;&nbsp;&nbsp;{Show&nbsp;{VirtualString<SPAN class="keyword">.</SPAN>toString<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Msg<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;message(From&nbsp;Content)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;From<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;:&nbsp;'</SPAN><SPAN class="keyword">#</SPAN>Content<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;registered(UserID)&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;UserID<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;joined&nbsp;us'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregistered(UserID)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;UserID<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;left&nbsp;us'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;permClient(UserID)&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;UserID<SPAN class="keyword">#</SPAN><SPAN class="string">'&nbsp;has&nbsp;crashed'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;permServer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="string">'Server&nbsp;has&nbsp;crashed'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><H3><A name="label257">5.1.4 Definition (with fault tolerance)</A></H3><P>The non-fault-tolerant version of <A href="node5.html#channel.definition">Section&nbsp;5.1.2</A> is easily extended to detect client and server crashes. </P><H4><A name="label258">Client definition</A></H4><P>This definition extends the definition given in <A href="node5.html#channel.definition">Section&nbsp;5.1.2</A>. The client creates a concurrent failure handler that monitors the server's port with its <EM>fault stream</EM>. Whenever the server's port reaches state <CODE>permFail</CODE>, the client sends the message <CODE>permServer</CODE> to its own port. This message will be seen by the user message handler. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label259">Client's server failure handler</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{List<SPAN class="keyword">.</SPAN>member&nbsp;permFail&nbsp;{DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;S}}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Send&nbsp;<SPAN class="keyword">self.</SPAN>client&nbsp;permServer}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;server&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> </P><P>Notice that the attribute <CODE>server</CODE> is set to <CODE><SPAN class="keyword">unit</SPAN></CODE>, like in method <CODE>close</CODE>. This makes every subsequent call to <CODE>sendMessage</CODE> on the client object fail with an exception. </P><H4><A name="label260">Server definition</A></H4><P>We extend the server's definition to handle permanent failures from clients. For that purpose we modify a bit the <CODE>Loop</CODE> procedure in <CODE>ServeClient</CODE>, and add a failure handler that monitors the client's port. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label261">Server's robust ServeClient</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">ServeClient</SPAN>&nbsp;Client&nbsp;UserID&nbsp;L}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Loop</SPAN>&nbsp;X<SPAN class="keyword">|</SPAN>T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;X<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;broadcast(U&nbsp;M)&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;message(U&nbsp;M)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;register(C&nbsp;U)&nbsp;&nbsp;&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;registered(C&nbsp;U)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregister(C&nbsp;U)&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;C<SPAN class="keyword">==</SPAN>Client&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;done&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;unregister(C&nbsp;U)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;unregistered(C&nbsp;U)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;permClient(C&nbsp;U)&nbsp;<SPAN class="keyword">andthen</SPAN>&nbsp;C<SPAN class="keyword">==</SPAN>Client&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">raise</SPAN>&nbsp;done&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;permClient(C&nbsp;U)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;{Send&nbsp;Client&nbsp;permClient(U)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Loop&nbsp;T}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">try</SPAN>&nbsp;{Loop&nbsp;L}&nbsp;<SPAN class="keyword">catch</SPAN>&nbsp;done&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{List<SPAN class="keyword">.</SPAN>member&nbsp;permFail&nbsp;{DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;Client}}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Send&nbsp;Server&nbsp;permClient(Client&nbsp;UserID)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> </P><P>The client thread in the server now also processes the message <CODE>permClient</CODE>. The thread that recognizes its own client port in the message raises the exception <CODE>done</CODE> to stop sending messages to that client, just like if the client was unregistered. Otherwise it simply notifies its client with the appropriate event. The failure handler created by <CODE>ServeClient</CODE> is responsible for sending the message <CODE>permClient</CODE> to the server's port. The message will be seen by all client threads on the server. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node4.html#chapter.failure">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node6.html#chapter.limits">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A>, <A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A>, <A href="http://www.sics.se/~perbrand">Per&nbsp;Brand</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~raph">Raphael&nbsp;Collet</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
