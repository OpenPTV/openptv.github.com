<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4 Failure Model</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.examples">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.ft_examples">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.failure"><H1><A name="chapter.failure">4 Failure Model</A></H1><A name="label207"></A><A name="label208"></A><P>Distributed systems have the partial failure property, that is, part of the system can fail while the rest continues to work. Partial failures are not at all rare. Properly-designed applications must take them into account. This is both good and bad for application design. The bad part is that it makes applications more complex. The good part is that applications can take advantage of the redundancy offered by distributed systems to become more robust. </P><P>The Mozart failure model defines what failures are recognized by the system and how they are reflected in the language. The system recognizes <A name="label209"></A> <A name="label210"></A> permanent site failures that are instantaneous <A name="label211"></A> <A name="label212"></A> <A name="label213"></A> <A name="label214"></A> and both temporary and permanent communication failures. The permanent site failure mode is more generally known as fail-silent with failure detection, that is, a site stops working instantaneously, does not communicate with other sites from that point onwards, and the stop can be detected from the outside. The system provides mechanisms to program with language entities that are subject to failures. <A name="label215"></A></P><P>The Mozart failure model is accessed through the module <A href="../system/node46.html#chapter.dp"><CODE>DP</CODE></A>. This chapter explains and justifies this functionality, and gives examples showing how to use it. The failure model has been both simplified and improved since version 1.4.0. The primitives offered by the former module <A href="../system/node52.html#chapter.fault"><CODE>Fault</CODE></A> are no longer available, they have been replaced by a simpler mechanism that subsumes former <EM>fault watchers</EM>. </P><P>In its current state, the Mozart system provides only the primitive operations needed to detect failure and reflect it in the language. The design and implementation of fault-tolerant abstractions within the language by using these primitives is the subject of ongoing research. This chapter and the next one give the first results of this research. All comments and suggestions for improvements are welcome. </P><H2><A name="label216">4.1 Fault states</A></H2><A name="label217"></A><P>All failure modes are defined with respect to both a language entity and a particular site. For example, one would like to read the contents of a cell from a given site. The site may or may not be able to access the cell. A language entity can be in one of four fault states on a given site: </P><UL><LI><P><A name="label218"></A> <A name="label219"></A> The entity works normally (local fault state <CODE>ok</CODE>).</P></LI><LI><P><A name="label220"></A> <A name="label221"></A> The entity is temporarily not working (local fault state <CODE>tempFail</CODE>). This is because a remote site crucial to the entity is currently unreachable due to a network problem. This fault state can go away, and the entity work normally again.</P></LI><LI><P><A name="label222"></A> <A name="label223"></A> The entity is permanently not working on the given site (local fault state <CODE>localFail</CODE>). This state is enforced by the application itself and is irreversible. It does not affect other sites.</P></LI><LI><P><A name="label224"></A> <A name="label225"></A> The entity is permanently not working on all sites (local fault state <CODE>permFail</CODE>). This is because a site crucial to the entity has crashed. This fault state is permanent.</P></LI></UL><P></P><P>If the entity is currently not working, then it is guaranteed that the fault state will be either <CODE>tempFail</CODE> or <CODE>permFail</CODE>. The system cannot always determine whether a fault is temporary or permanent. In particular, a <CODE>tempFail</CODE> may hide a site crash. However, network failures can always be considered temporary since the system actively tries to reestablish another connection. </P><P>The fault state <CODE>localFail</CODE> provides no guarantee on the actual status of the entity. It may hide a temporary or permanent fault, or no fault at all. It is permanent in the sense that the site will never be able to use the entity again. This fault state is not final, though. If the system detects that the entity is permanently not working on all sites, its fault state will become <CODE>permFail</CODE>. </P><H3><A name="label226">4.1.1 Temporary faults</A></H3><P>The fault state <CODE>tempFail</CODE> exists to allow the application to react quickly to temporary network problems. It is raised by the system as soon as a network problem is recognized. <A name="label227"></A> It is therefore fundamentally different from a connection time-out. For example, TCP gives a time-out after some minutes. This duration has been chosen to be very long, approximating infinity from the viewpoint of the network connection. After the time-out, one can be sure that the connection is no longer working. </P><P>The purpose of <CODE>tempFail</CODE> is quite different. It is to <EM>inform</EM> the application of network problems, not to mark the <EM>end</EM> of a connection. For example, an application might be connected to a given server. If there are problems with this server, the application would like to be informed quickly so that it can try connecting to another server. A <CODE>tempFail</CODE> fault state will therefore be relatively frequent, much more frequent than a time-out. In most cases, a <CODE>tempFail</CODE> fault state will eventually go away. </P><P>It is possible for a <CODE>tempFail</CODE> state to last forever. For example, if a user disconnects the network connection of a laptop machine, then only he or she knows whether the problem is permanent. The application cannot in general know this. The decision whether to continue waiting or to stop the wait can cut through all levels of abstraction to appear at the top level (i.e., the user). The application might then pop up a window to ask the user whether to continue waiting or not. The important thing is that the network layer does not make this decision; the application is completely free to decide or to let the user decide. </P><H3><A name="label228">4.1.2 Permanent faults</A></H3><P>In the new model, the application has the possibility to enforce a permanent failure locally or globally. Permanent failures are simpler to deal with, since they come with guarantees. If a thread attempts to invoke a distributed object that is known to be permanently failed, the system may infer that the thread will block forever, because the operation will never succeed. That information can be used by the garbage collector in order to safely remove that thread from memory. </P><P>Enforcing permanent failures can also simplify failure handlers themselves. A recovery mechanism based on temporary failures only, has to take into account the possibility that the failure may go away, and the normal behavior of an entity can interfere with the recovery. </P><P>Making an entity permanently unusable on a given site does not require any communication with other sites a priori. Therefore the fault state <CODE>localFail</CODE> is useful in cases where network faults are occurring. Note that the state has no impact on the network layer itself. On the other hand, making an entity permanently unusable for all sites may require to communicate with other sites. The system cannot notify the fault state <CODE>permFail</CODE> without having the guarantee that all sites are unable to use the entity. </P><H3><A name="label229">4.1.3 Remote problems</A></H3><P>The former failure model was defining extra fault states that were informing the application about other sites using a given entity. Those fault states have been discarded in the new fault model. They were more difficult to understand, and their semantics was depending on the type of entity and the design of the distribution of entities. In order to allow for different distribution strategies, we considered these extra fault states to be inadequate. We believe that the four states defined above are expressive enough for building powerful fault-tolerant abstractions. </P><H2><A name="label230">4.2 Basic model</A></H2><A name="label231"></A><A name="label232"></A><P>The model is extremely simple: <EM>operations that cannot proceed because of a failure block until the failure possibly goes away</EM>. Resumption after a temporary failure is automatic. Permanent failures cause the operation to block forever. Note how this behavior preserves the semantics of the language: an operation will never do something <EM>different</EM> because of a distribution fault. If the operation cannot complete, then it does not complete, and simply blocks. </P><P>Note that <EM>asynchronous</EM> operations do not block, even in the case of entity failure. Sending a message on a port is asynchronous: it terminates immediately, and eventually the message appears on the port's stream. Upon failure, this behavior is unchanged, except that the message may never arrive if the failure is permanent. So, sending a message on a permanently failed port is equivalent to doing nothing. </P><H3><A name="label233">4.2.1 The fault stream</A></H3><A name="label234"></A><P>This basic model guarantees that nothing <EM>wrong</EM> happens to a distributed program that does not handle failures. Failure may simply <EM>prevent</EM> things to happen. In order to handle failures, one needs to detect them. So the second aspect of the model is a primitive that allows to watch the fault state of an entity. For that purpose, every site defines a <EM>fault stream</EM> for every entity. The fault stream of an entity reflects the history of the fault states of that entity on the site. Every time the fault state of the entity changes, the new state appears on the stream. <A name="label235"></A> <A name="label236"></A></P><P>The fault stream of an entity <CODE>X</CODE> is given by the function <CODE>DP<SPAN class="keyword">.</SPAN>getFaultStream</CODE>: </P><BLOCKQUOTE class="code"><CODE>FS={DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;X}</CODE></BLOCKQUOTE><P> The stream <CODE>FS</CODE> always contains the current fault state of <CODE>X</CODE> as its first element. So, if <CODE>X</CODE> is working normally, the fault stream will look like </P><BLOCKQUOTE class="code"><CODE>FS=ok<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> Note that the tail of the stream is a read-only future. It will be bound as soon as the fault state of <CODE>X</CODE> changes. Assume that a temporary failure is detected. The stream becomes </P><BLOCKQUOTE class="code"><CODE>FS=ok<SPAN class="keyword">|</SPAN>tempFail<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> Now assume that the failure goes away. The stream is extended as </P><BLOCKQUOTE class="code"><CODE>FS=ok<SPAN class="keyword">|</SPAN>tempFail<SPAN class="keyword">|</SPAN>ok<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> Any thread reading <CODE>FS</CODE> will be able to follow the history of <CODE>X</CODE>'s local fault state. Now consider that the home site of <CODE>X</CODE> crashes, and that it makes <CODE>X</CODE> permanently unavailable. The stream becomes </P><BLOCKQUOTE class="code"><CODE>FS=ok<SPAN class="keyword">|</SPAN>tempFail<SPAN class="keyword">|</SPAN>ok<SPAN class="keyword">|</SPAN>permFail<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> At that point, another thread that executes <CODE>{DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;X}</CODE> will get the tail of the stream, prefixed by <CODE>X</CODE>'s current fault state, i.e., </P><BLOCKQUOTE class="code"><CODE>permFail<SPAN class="keyword">|</SPAN>_</CODE></BLOCKQUOTE><P> <A name="label237"></A> <A name="label238"></A></P><P>On implements a failure handler with a thread reading an entity's fault stream, and performing an action depending on the fault state it just read. With the fault stream, one can implement failure handlers in many different ways. One entity can be monitored by several handlers: they will simply happen to read the same fault stream. One can also monitor several entities with a single handler: one thread can read several streams, using <CODE>Record<SPAN class="keyword">.</SPAN>waitOr</CODE> to synchronize on fault state updates. </P><H4><A name="label239">Stream finalization</A></H4><A name="label240"></A><P>It can be useful to drop a failure handler once the entity it is monitoring is out of memory scope on the handler's site. When an entity is garbage collected, the tail of its fault stream is automatically bound to <CODE>nil</CODE>. So, in the example above, if <CODE>X</CODE> disappears from the site where <CODE>DP<SPAN class="keyword">.</SPAN>getFaultStream</CODE> was applied, the fault stream becomes </P><BLOCKQUOTE class="code"><CODE>FS=ok<SPAN class="keyword">|</SPAN>tempFail<SPAN class="keyword">|</SPAN>ok<SPAN class="keyword">|</SPAN>permFail<SPAN class="keyword">|</SPAN>nil</CODE></BLOCKQUOTE><P> </P><H4><A name="label241">Variables</A></H4><P>Beware of variables: the fault stream of a variable is not the same as the fault stream of its value! In order to monitor a variable <CODE>X</CODE>, one has to make sure that <CODE>{DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;X}</CODE> is called <EM>before</EM> <CODE>X</CODE> is determined. Once <CODE>X</CODE> is determined, its fault stream is closed with <CODE>nil</CODE>, like upon finalization above. This gives a hint to the handler watching <CODE>X</CODE> that the variable no longer exists as a variable on its site. This is important because the way a variable failure may be completely unrelated to how a failure of its value is handled. The model enforces the separation between the variable and its value. </P><P>In order to get the fault stream of a variable <CODE>X</CODE>, the safest way is to get the fault stream of a fresh variable, then bind that variable to <CODE>X</CODE>. Once two variables are bound, their fault streams are merged (see module <A href="../system/node46.html#chapter.dp"><CODE>DP</CODE></A>). In the example below, the fault stream of <CODE>Y</CODE> becomes the fault stream of <CODE>X</CODE>. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">GetVariableFaultStream</SPAN>&nbsp;X&nbsp;?FS}<BR>&nbsp;&nbsp;&nbsp;Y<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;FS={DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;Y}<BR>&nbsp;&nbsp;&nbsp;X=Y<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><DIV id="advanced.model"><H2><A name="advanced.model">4.3 Advanced features</A></H2><P>The basic model lets you predict the behavior of an application in case of faults, and write failure watchers that may react upon entity failure. The advanced model provides two extra operations <CODE>DP<SPAN class="keyword">.</SPAN>break</CODE> and <CODE>DP<SPAN class="keyword">.</SPAN>kill</CODE>, for enforcing the fault states <CODE>localFail</CODE> and <CODE>permFail</CODE>, respectively. </P><P>The statement <CODE>{DP<SPAN class="keyword">.</SPAN>break&nbsp;X}</CODE> puts the entity <CODE>X</CODE> in fault state <CODE>localFail</CODE>, unless it was already in state <CODE>permFail</CODE>. In the latter case, it does nothing. It ensures that <CODE>X</CODE> is permanently not working on the current site at least, and has no effect on other sites. It can be used to prevent an entity that is in fault state <CODE>tempFail</CODE> for a long time, from working again. </P><P>The statement <CODE>{DP<SPAN class="keyword">.</SPAN>kill&nbsp;X}</CODE> is asynchronous: it terminates immediately, and attempts to put the entity <CODE>X</CODE> in fault state <CODE>permFail</CODE>. It is not guaranteed to succeed. It can be applied even if <CODE>X</CODE> is in fault state <CODE>localFail</CODE>. </P><H3><A name="label242">4.3.1 Failure propagation</A></H3><P>Here is a small example on how to use <CODE>DP<SPAN class="keyword">.</SPAN>getFaultStream</CODE> and <CODE>DP<SPAN class="keyword">.</SPAN>kill</CODE> in order to make a set of entities fail as soon as one of them fail. Assume <CODE>Es</CODE> is a list of entities. We create as many failure watchers as entities, and every watcher that observes <CODE>permFail</CODE> on its fault stream binds a trigger variable. Concurrently, a thread waits on that trigger variable, and kill all entities once it is bound. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;Trigger&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">for</SPAN>&nbsp;E&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Es&nbsp;<SPAN class="keyword">do</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%&nbsp;<SPAN class="comment">bind&nbsp;Trigger&nbsp;once&nbsp;E&nbsp;has&nbsp;permanently&nbsp;failed<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{Member&nbsp;permFail&nbsp;{DP<SPAN class="keyword">.</SPAN>getFaultStream&nbsp;E}}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Trigger=<SPAN class="keyword">unit</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Wait&nbsp;Trigger}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%&nbsp;<SPAN class="comment">attempt&nbsp;to&nbsp;make&nbsp;all&nbsp;elements&nbsp;of&nbsp;Es&nbsp;fail<BR></SPAN>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">for</SPAN>&nbsp;E&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;Es&nbsp;<SPAN class="keyword">do</SPAN>&nbsp;{DP<SPAN class="keyword">.</SPAN>kill&nbsp;E}&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> This implements something similar to the <EM>process linking</EM> in Erlang: all those entities serve a common task, which ensures that no entity survives if some of them fail. </P></DIV><H2><A name="label243">4.4 Fault states for language entities</A></H2><P>This section explains the possible fault states of each language entity in terms of its distributed semantics. The fault state is a consequence of two things: the entity's distributed implementation and the system's failure mode. Note that a given entity may have several possible distributed implementations, depending on which state protocol is used. So the fault states will be explained in function of the protocols, and not of the entities themselves. Please refer to protocol annotations in module <A href="../system/node46.html#chapter.dp"><CODE>DP</CODE></A> for a detailed list of all protocols. </P><P>As you already know, the fault state <CODE>localFail</CODE> only depends on the site where it occurs. So we are only interested in the situations that may cause fault states <CODE>tempFail</CODE> and <CODE>permFail</CODE>, and which are not related to the usage of <CODE>DP<SPAN class="keyword">.</SPAN>kill</CODE>. </P><H3><A name="label244">4.4.1 Stationary state protocols: <CODE>stationary</CODE>, <CODE>sited</CODE></A></H3><P>This applies to ports, which are always stationary, and to dictionaries and arrays, which are stationary by default. It also applies to sited entities, or entities explicitly annotated as <CODE>sited</CODE>. The fault state of those entities depends on their home site only. The state <CODE>tempFail</CODE> reflects an unknown problem for communicating with the entity's home site, while <CODE>permFail</CODE> is a sign of a site crash. </P><H3><A name="label245">4.4.2 Migratory state protocols: <CODE>migratory</CODE>, <CODE>pilgrim</CODE></A></H3><P>This applies to cells and object states, which use protocol <CODE>migratory</CODE> by default. The fault state depends on both their home site and the sites that may contain the state. In particular, the state <CODE>permFail</CODE> occurs when the home site crashes, or the site holding the state crashes. The state is guaranteed to be lost in that state. </P><H3><A name="label246">4.4.3 Replicated state protocol: <CODE>replicated</CODE></A></H3><P>This applies to stateful entities annotated as such. Like in the stationary state protocols, the fault state depends on the home site only. The proxy sites only hold a copy of the state. Once they crash and the home site detects them, they are simply discarded when it comes to updating the state. The protocol is designed in such a way that proxy failures do not affect the entity. </P><H3><A name="label247">4.4.4 Immediate copy protocol: <CODE>immediate</CODE></A></H3><P>This applies to stateless entities that are copied upon transmission, like procedures, classes and chunks by default. Those entities are only values, and they cannot fail, since they are present on all the sites referring to them. The only possible fault state for those entities is <CODE>ok</CODE>. </P><H3><A name="label248">4.4.5 Non-immediate copy protocol: <CODE>eager</CODE>, <CODE>lazy</CODE></A></H3><P>This applies to stateless entities that are copied between sites, but not immediately, like object-records by default. Such entities can be <CODE>tempFail</CODE> if a network failure prevents the site from obtaining their full representation. However, they cannot be <CODE>permFail</CODE>, because their representation could be obtained by other means. </P><P>For example, consider a class that is copied lazily. The class representation may be obtained by another site than the one that sent the class reference. The class may also have been save on a file, and that file can be available to the site requesting it. Loading the class will simply fulfill the representation in memory. </P><H3><A name="label249">4.4.6 Variable protocols: <CODE>variable</CODE>, <CODE>reply</CODE></A></H3><P>This applies to all kinds of variables. With the protocol <CODE>variable</CODE>, the fault state of the entity only depends on its home site. If the home site fails before the variable is bound, the variable's fault state will be <CODE>permFail</CODE>. </P><P>The weakness of the protocol <CODE>variable</CODE> is that it does not consider a proxy crash as a possible cause of entity failure, even if that proxy site was the one supposed to bind the variable. For that purpose, the protocol <CODE>reply</CODE> considers also the first proxy site (the first site that was sent the variable) as critical for the entity. So, with the protocol <CODE>reply</CODE>, the fault state <CODE>permFail</CODE> may be caused by a crash of the home site or the first proxy site. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#chapter.examples">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node5.html#chapter.ft_examples">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A>, <A href="http://www.sics.se/~seif">Seif&nbsp;Haridi</A>, <A href="http://www.sics.se/~perbrand">Per&nbsp;Brand</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~raph">Raphael&nbsp;Collet</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
