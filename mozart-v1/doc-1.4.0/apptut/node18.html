<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>Part&nbsp;V: Distributed Applications</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node15.html#part.www">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node19.html#part.foreign.extensions">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="part.distributed.applications"><H1 align="center" class="part"><A name="part.distributed.applications">Part&nbsp;V: Distributed Applications</A></H1><H1><A name="label40">14 Chat Application</A></H1><P>A chat system permits participants on arbitrary machines on the internet to engage in a real-time text-based discussion. New individual can join or leave the chat forum at any time. This scenario is intended to be realistic, which means that the chat system must be reasonably robust in the face of network failures, as well as machine and process crashes.</P><P>In this tutorial application, we will not set out to solve all problems that may be associated with distributed applications; rather, we will demonstrate how simple it is to realize a fully distributed application with reasonable robustness properties.</P><H2><A name="label41">14.1 Chat Server</A></H2><P>The server creates a port <CODE>NewsPort</CODE> and makes it available through a ticket. The ticket, as usual, is saved into a file which clients normally will load through a url. When a client wants to participate in the discussion forum, it needs not only <CODE>NewsPort</CODE> in order to post messages, but also the stream of messages that results from all posts to <CODE>NewsPort</CODE>, in order to display these messages to the user. The server could hand out the stream of all messages from the creation of <CODE>NewsPort</CODE>, but it seems more desirable to only hand out a stream that has only the messages posted after the client's request to connect to the discussion.</P><P>When a client wants to connect to the chat forum, it obtains <CODE>NewsPort</CODE> by means of the ticket that the server made available at some url, and it posts a message of the form <CODE>connect(Messages)</CODE>, where <CODE>Messages</CODE> is a new variable. The server then binds the variable to the stream of messages following the <CODE>connect(<SPAN class="keyword">...</SPAN>)</CODE> message. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label42">Chat Server</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Application(getCmdArgs)&nbsp;Connection(gate)&nbsp;Pickle(save)<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Args&nbsp;=&nbsp;{Application<SPAN class="keyword">.</SPAN>getCmdArgs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record(ticketfile(single&nbsp;type:string&nbsp;optional:<SPAN class="keyword">false</SPAN>))}<BR>&nbsp;&nbsp;&nbsp;NewsPort<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;Ticket&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{New&nbsp;Connection<SPAN class="keyword">.</SPAN>gate&nbsp;init(NewsPort&nbsp;Ticket)&nbsp;_}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Pickle<SPAN class="keyword">.</SPAN>save&nbsp;Ticket&nbsp;Args<SPAN class="keyword">.</SPAN>ticketfile}<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{List<SPAN class="keyword">.</SPAN>forAllTail&nbsp;{Port<SPAN class="keyword">.</SPAN>new&nbsp;$&nbsp;NewsPort}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;H<SPAN class="keyword">|</SPAN>T}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;H&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;connect(Messages)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;Messages=T&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> The server (<A href="chat-server.oz">source in <CODE>chat-server.oz</CODE></A>) can be compiled as follows: </P><BLOCKQUOTE class="code"><CODE>ozc&nbsp;-x&nbsp;chat-server.oz</CODE></BLOCKQUOTE><P> and invoked as follows: </P><BLOCKQUOTE class="code"><CODE>chat-server&nbsp;--ticketfile&nbsp;</CODE><I>FILE</I></BLOCKQUOTE><P></P><H2><A name="label43">14.2 Chat Client</A></H2><P>The client consists of 2 agents: (1) a user interface agent and (2) a message stream processor. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label44">Chat Client</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Application(getCmdArgs)&nbsp;Pickle(load)&nbsp;Connection(take)<BR>&nbsp;&nbsp;&nbsp;Viewer(chatWindow)&nbsp;<SPAN class="keyword">at</SPAN>&nbsp;<SPAN class="string">'chat-gui.ozf'</SPAN>&nbsp;<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Args&nbsp;=&nbsp;{Application<SPAN class="keyword">.</SPAN>getCmdArgs<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;record(url(single&nbsp;type:string&nbsp;optional:<SPAN class="keyword">false</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name(single&nbsp;type:string&nbsp;optional:<SPAN class="keyword">false</SPAN>)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)}<BR>&nbsp;&nbsp;&nbsp;NewsPort={Connection<SPAN class="keyword">.</SPAN>take&nbsp;{Pickle<SPAN class="keyword">.</SPAN>load&nbsp;Args<SPAN class="keyword">.</SPAN>url}}<BR>&nbsp;&nbsp;&nbsp;SelfPort<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node18.html#label45">Chat Client: obtain and process message stream</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node18.html#label46">Chat Client: create user interface agent</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR>&nbsp;&nbsp;&nbsp;</CODE><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A href="node18.html#label47">Chat Client: process message stream</A><SPAN class="chunkborder">&gt;</SPAN></SPAN><CODE>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> The client obtains the stream of messages from the server by sending a <CODE>connect(<SPAN class="keyword">...</SPAN>)</CODE> message. It then forwards every message on that stream to its internal <CODE>SelfPort</CODE>. The user interface will also direct messages to this internal port. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label45">Chat Client: obtain and process message stream</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">thread</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;{ForAll&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;NewsPort&nbsp;connect($)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Msg}&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;SelfPort&nbsp;Msg}&nbsp;<SPAN class="keyword">end</SPAN>}<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P> When creating the user interface, we supply it with the internal <CODE>SelfPort</CODE> so that it may also post internal messages. In this simplistic implementation, the user interface simply posts messages of the form <CODE>say(</CODE><I>String</I><CODE>)</CODE> to request that this <I>String</I> be posted to the global chat message stream. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label46">Chat Client: create user interface agent</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE>Chat&nbsp;=&nbsp;{New&nbsp;Viewer<SPAN class="keyword">.</SPAN>chatWindow&nbsp;init(SelfPort)}</CODE></DD></DL><P> Finally, here is where we process all messages on the internal stream. A <CODE>msg(FROM&nbsp;TEXT)</CODE> message is formatted and shown in the chat window. A <CODE>say(TEXT)</CODE> message is transformed into <CODE>msg(NAME&nbsp;TEXT)</CODE>, where <CODE>NAME</CODE> identifies the user, and posted to the global chat stream; actually <CODE>TEXT</CODE> is additionally converted into the more compact byte string representation for more efficient transmission. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label47">Chat Client: process message stream</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE>NAME&nbsp;=&nbsp;Args<SPAN class="keyword">.</SPAN>name<BR>{ForAll&nbsp;{Port<SPAN class="keyword">.</SPAN>new&nbsp;$&nbsp;SelfPort}<BR>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;Msg}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">case</SPAN>&nbsp;Msg&nbsp;<SPAN class="keyword">of</SPAN>&nbsp;msg(FROM&nbsp;TEXT)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Chat&nbsp;show(FROM<SPAN class="keyword">#</SPAN><SPAN class="string">':\t'</SPAN><SPAN class="keyword">#</SPAN>TEXT)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">elseof</SPAN>&nbsp;say(TEXT)&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;NewsPort&nbsp;msg(NAME&nbsp;{ByteString<SPAN class="keyword">.</SPAN>make&nbsp;TEXT})}<BR>&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">else</SPAN>&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></DD></DL><P> The client (<A href="chat-client.oz">source in <CODE>chat-client.oz</CODE></A>) can be compiled as follows: </P><BLOCKQUOTE class="code"><CODE>ozc&nbsp;-x&nbsp;chat-client.oz</CODE></BLOCKQUOTE><P> and invoked as follows: </P><BLOCKQUOTE class="code"><CODE>chat-client&nbsp;--name&nbsp;</CODE><I>USER</I><CODE>&nbsp;--url&nbsp;</CODE><I>URL</I></BLOCKQUOTE><P></P><H2><A name="label48">14.3 Graphical User Interface</A></H2><P>The user interface is always what requires the most code. We won't go through the details here (but see the Window Programming Tutorial for extensive information), but merely point out that the <CODE><SPAN class="keyword">@</SPAN>entry</CODE> widget is asked to respond to a <KBD>Return</KBD> keypress, by invoking the <CODE>post</CODE> method. The latter posts a <CODE>say(</CODE><I>Text</I><CODE>)</CODE> message to the internal port, where <I>Text</I> is the text of the entry as typed by the user. This text is then deleted and the entry can be reused to compose and submit another message. </P><DL><DT><SPAN class="chunktitle"><SPAN class="chunkborder">&lt;</SPAN><A name="label49">Chat GUI</A><SPAN class="chunkborder">&gt;=</SPAN></SPAN></DT><DD class="code"><CODE><SPAN class="keyword">functor</SPAN>&nbsp;<BR><SPAN class="keyword">import</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Tk&nbsp;Application(exit:Exit)<BR><SPAN class="keyword">export</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;ChatWindow<BR><SPAN class="keyword">define</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">class</SPAN>&nbsp;<SPAN class="type">ChatWindow</SPAN>&nbsp;<SPAN class="keyword">from</SPAN><SPAN class="type">&nbsp;Tk.toplevel</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">attr</SPAN>&nbsp;canvas&nbsp;y:0&nbsp;vscroll&nbsp;hscroll&nbsp;tag:0&nbsp;selfPort&nbsp;entry&nbsp;quit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">init</SPAN>(SelfPort)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tk<SPAN class="keyword">.</SPAN>toplevel<SPAN class="keyword">,</SPAN>tkInit<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selfPort&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;SelfPort<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;canvas&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Tk<SPAN class="keyword">.</SPAN>canvas<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tkInit(parent:<SPAN class="keyword">self</SPAN>&nbsp;bg:ivory&nbsp;width:400&nbsp;height:300)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vscroll&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Tk<SPAN class="keyword">.</SPAN>scrollbar&nbsp;tkInit(parent:<SPAN class="keyword">self</SPAN>&nbsp;orient:v)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;hscroll&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Tk<SPAN class="keyword">.</SPAN>scrollbar&nbsp;tkInit(parent:<SPAN class="keyword">self</SPAN>&nbsp;orient:h)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;entry&nbsp;&nbsp;&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Tk<SPAN class="keyword">.</SPAN>entry&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tkInit(parent:<SPAN class="keyword">self</SPAN>)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quit&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">:=</SPAN>&nbsp;{New&nbsp;Tk<SPAN class="keyword">.</SPAN>button&nbsp;&nbsp;&nbsp;&nbsp;tkInit(parent:<SPAN class="keyword">self</SPAN>&nbsp;text:<SPAN class="string">'Quit'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{Exit&nbsp;0}&nbsp;<SPAN class="keyword">end</SPAN>)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Tk<SPAN class="keyword">.</SPAN>addYScrollbar&nbsp;<SPAN class="keyword">@</SPAN>canvas&nbsp;<SPAN class="keyword">@</SPAN>vscroll}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Tk<SPAN class="keyword">.</SPAN>addXScrollbar&nbsp;<SPAN class="keyword">@</SPAN>canvas&nbsp;<SPAN class="keyword">@</SPAN>hscroll}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>canvas&nbsp;tk(configure&nbsp;scrollregion:q(0&nbsp;0&nbsp;200&nbsp;0))}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>entry&nbsp;tkBind(event:<SPAN class="string">'&lt;KeyPress-Return&gt;'</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;action:<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;{<SPAN class="keyword">self</SPAN>&nbsp;post}&nbsp;<SPAN class="keyword">end</SPAN>)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Tk<SPAN class="keyword">.</SPAN>batch&nbsp;[grid(row:0&nbsp;column:0&nbsp;<SPAN class="keyword">@</SPAN>canvas&nbsp;sticky:ns)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(row:1&nbsp;column:0&nbsp;<SPAN class="keyword">@</SPAN>entry&nbsp;sticky:ew)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(row:0&nbsp;column:1&nbsp;<SPAN class="keyword">@</SPAN>vscroll&nbsp;sticky:ns)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(row:2&nbsp;column:0&nbsp;<SPAN class="keyword">@</SPAN>hscroll&nbsp;sticky:ew)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(row:3&nbsp;column:0&nbsp;<SPAN class="keyword">@</SPAN>quit&nbsp;sticky:w)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(columnconfigure&nbsp;<SPAN class="keyword">self</SPAN>&nbsp;0&nbsp;weight:1)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;grid(rowconfigure&nbsp;<SPAN class="keyword">self</SPAN>&nbsp;0&nbsp;weight:1)]}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">show</SPAN>(TEXT)<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>canvas&nbsp;tk(create&nbsp;text&nbsp;0&nbsp;<SPAN class="keyword">@</SPAN>y&nbsp;text:TEXT&nbsp;anchor:nw&nbsp;tags:<SPAN class="keyword">@</SPAN>tag)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[X1&nbsp;Y1&nbsp;X2&nbsp;Y2]&nbsp;=&nbsp;{<SPAN class="keyword">@</SPAN>canvas&nbsp;tkReturnListInt(bbox&nbsp;all&nbsp;$)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y<SPAN class="keyword">:=</SPAN>Y2<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>canvas&nbsp;tk(configure&nbsp;scrollregion:q(X1&nbsp;Y1&nbsp;X2&nbsp;Y2))}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">meth</SPAN>&nbsp;<SPAN class="functionname">post</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Port<SPAN class="keyword">.</SPAN>send&nbsp;<SPAN class="keyword">@</SPAN>selfPort&nbsp;say({<SPAN class="keyword">@</SPAN>entry&nbsp;tkReturn(get&nbsp;$)})}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<SPAN class="keyword">@</SPAN>entry&nbsp;tk(delete&nbsp;0&nbsp;<SPAN class="string">'end'</SPAN>)}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR><SPAN class="keyword">end</SPAN></CODE></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node15.html#part.www">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node19.html#part.foreign.extensions">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
