<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>The Mozart Constraint Extensions Tutorial</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><P class="margin"><A href="../index.html">Top</A><BR></P><H1 align="center" class="title">The Mozart Constraint Extensions Tutorial</H1><H2 align="center" class="authors"><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A></H2><BLOCKQUOTE><P> This tutorial provides the knowledge to go beyond the built-in constraint capabilities of Mozart Oz 3. This tutorial is complemented by <A href="../cpiref/index.html">``The Mozart Constraint Extensions Reference''</A>. </P><DIV class="apropos"><P class="margin">Motivation</P><P> A major design goal of Oz is to provide for a wide range of applications the right level of programming abstractions. Though Mozart Oz 3 features a full-fledged finite domain and finite set constraint solver providing for the functionality required to solve combinatorial problems efficiently, it is often desirable to implement constraints in C++. There may be several reasons to do so, as for example, that a given algorithm requires destructively updateable data structures or an already existing C++ library shall be used. Consequently, we opened the constraint solver of Mozart Oz 3 by adding a C/C++ interface for implementing so-called <EM>constraint propagators</EM>. Hereby, a constraint propagator is the implementation of a constraint. Further, it may be desirable to have a constraint system available that is not provided by Mozart Oz 3 and one wants to implement it from scratch. Even such cases can be handled by the C/C++ interface. Finally, the integration of linear (integer) programming solvers is explained which are standard means in Operations Research to tackle certain combinatorial problem classes. </P></DIV><DIV class="apropos"><P class="margin">Structure of the Manual</P><P> The user manual consists of three parts: </P><OL type="1"><LI><P>The first part explains how to implement various propagators. It starts with a propagator for the constraint <IMG alt="x+y=z" src="latex1.png"> over finite domains and introduces the tools and techniques needed. This propagator will be refined such that it is able to detect equal variables and reduces to a more specialised propagator. Then a functionally nestable version of the addition propagator will be derived. We go on with a propagator that can deal with vectors of variables. As example serves the so-called <EM>element</EM> constraint. The implementation of a propagator using finite set and finite domain constraints is explained next. Finally more advanced topics, like the implementation of reified constraints, are discussed. </P><P><EM>Note that it is not the intention of this manual to provide sophisticated algorithms</EM>. </P></LI><LI><P>The second part explains the implementation of constraint systems from scratch, i.&nbsp;e., not only the propagators of a certain constraint system but also the basic constraints. As example, constraints over real intervals are implemented. </P></LI><LI><P>The third part explains the integration and usage of linear programming solvers like CPLEX <A href="bib.html#cplex">[ILO97]</A> and LP_SOLVE <A href="bib.html#lp_solve">[Har]</A> from within Mozart Oz 3. To demonstrate the benefits of jointly using propagation-based and linear programming-based solvers knapsack problems are tackled. </P></LI></OL><P> </P></DIV><DIV class="apropos"><P class="margin">Prerequisites</P><P> The reader is supposed to have a working knowledge in the C/C++ programming language and to be familiar with constraint-based problem solving techniques in Oz. An excellent supplementary text book on C++ is <A href="bib.html#murray">[Mur93]</A>. Constraint-based problem solving techniques in Oz are explained in <A href="../fdt/index.html">``Finite Domain Constraint Programming in Oz. A Tutorial.''</A> resp. <A href="../fst/index.html">``Problem Solving with Finite Set Constraints in Oz. A Tutorial.''</A>. The C<SPAN class="allcaps">PI</SPAN> uses the <EM>native functor</EM> interface of Mozart Oz 3. Have a look at <A href="../apptut/node19.html#part.foreign.extensions">Part&nbsp;VI of ``Application Programming''</A> resp. <A href="../foreign/index.html">``Interfacing to C and C++''</A> for details. </P></DIV></BLOCKQUOTE><HR><UL class="toc"><LI><A href="toc.html#label1">Table of Contents</A></LI></UL><UL class="toc"><LI><A href="node1.html#chapter.ip">1 Implementing Propagators</A></LI></UL><UL class="toc"><LI><A href="ct.html#chapter.ct">2 Building Constraint Systems from Scratch</A></LI></UL><UL class="toc"><LI><A href="lp.html#chapter.lp">3 Employing Linear Programming Solvers</A></LI></UL><UL class="toc"><LI><A href="bib.html#label25">Bibliography</A></LI></UL><UL class="toc"><LI><A href="idx.html#label26">Index</A></LI></UL><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
