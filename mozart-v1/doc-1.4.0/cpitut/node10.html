<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>2.1.1 The Model of a Generic Constraint Solver</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html">- Up -</A></TD><TD><A href="node11.html#ct.intro.overview">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="ct.intro.model"><H3><A name="ct.intro.model">2.1.1 The Model of a Generic Constraint Solver</A></H3><P> This section describes how to implement constraint systems from scratch. First we will explain the underlying concepts in an informal way and try to draw a big picture of the implementation. </P><P> Constraint propagation takes place in a <EM>computation space</EM> which consists of the <EM>constraint store</EM> and propagators associated with the constraint store. The constraint store holds variables that either refer to values (i.&nbsp;e., are bound resp. determined) or are unbound. But there may already be some information about the value an unbound variable will later refer to. For example, it might be already known that a variable refers to an integer. We say the variable is <EM>constrained</EM>, here by a finite domain constraint. This information is stored right at the variable. To provide a generic scheme to associate self-defined constraints with a variable in the constraint store, such a variable has a pointer of type <CODE>(OZ_Ct&nbsp;<SPAN class="keyword">*</SPAN>)</CODE>, pointing to a constraint instance of the self-defined constraint system. That is done by defining new constraints as subclasses of <CODE>OZ_Ct</CODE>. </P><P> The main part of a propagator is its propagation routine. This routine fulfills mainly three tasks. First it retrieves the constraint from the constraint store. The class <CODE>OZ_CtVar</CODE> provides a generic interface for that task. Then the propagation algorithm generates new projections on the retrieved constraints. Finally the new constraints are written back to the constraint store. Usually a propagator parameter is shared between more than one propagator. Modifying a constraint in the constraint store may enable another propagators to generate new projections, hence when writing constraints to the store, propagators sharing parameters have to be notified. This is done by the appropriate member functions of <CODE>OZ_CtVar</CODE> but to decide what propagators to notify, the propagator has to memorize the constraints present in the constraint store before the propagation algorithm modified the store. The class <CODE>OZ_CtProfile</CODE> serves that purpose by providing a generic interface (used in <CODE>OZ_CtVar</CODE>) to store characteristic information of a constraint sufficient to derive which propagators have to be notified. </P><P> The notification of propagators is realized by wake-up lists associated with the constrained variable. Depending on the kind of constraint system there will be different events a propagator may want to be notified upon. For each event there is a wake-up list. The wake-up events of a constraint system are determined by an object of a subclass of <CODE>OZ_CtDefinition</CODE>. Hence, upon creation of a new constrained variable a reference of type <CODE>OZ_CtDefinition&nbsp;<SPAN class="keyword">*</SPAN></CODE> has to be passed to <CODE>OZ_mkCtVariable()</CODE> which takes care of creating variables with generic constraints. </P><P> The following sections explain in detail how a constraint system can be implemented using the provided abstractions briefly mentioned in this section. </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html">- Up -</A></TD><TD><A href="node11.html#ct.intro.overview">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
