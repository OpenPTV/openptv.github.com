<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>9 Limitations</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.remote">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#appendix.menus">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="chapter.limitations"><H1><A name="chapter.limitations">9 Limitations</A></H1><P> Ozcar currently suffers from a number of limitations. Most of these are not severe, since simple workarounds are available. </P><DL><DT>Non-debug code </DT><DD><P>Often, it is not be practical or possible to recompile all code of an application (including all used libraries) with debug information. Ozcar will happily attach threads executing mixed debug and non-debug code, but only if they execute a step point within code compiled with debug information <EM>or</EM> a static breakpoint. Furthermore, single-stepping and environment information will not be available within non-debug code. </P></DD><DT>Tail-calls </DT><DD><P>Long-running applications, such as server applications, depend on <EM>tail-call optimization</EM> to implement their toplevel loop. Tail-call optimization causes stack frames to be popped before the activation of another procedure if the corresponding call is the last thing to happen within a procedure body. Thus, tail-call optimization limits stack growth. Within debug code, tail-call optimization is disabled, and long-running programs as well as programs with deep recursion may abort due to excessive stack growth. </P><P> As a workaround, implement the top-level loop of server applications in a separate component compiled without debug information. </P></DD><DT>Pickling and Garbage Collection </DT><DD><P>Due to maintenance of the runtime environments, values may be referenced from closures that would not be referenced in production code. This can lead to different dynamic behaviour with respect to pickling and garbage collection: Pickling may produce larger pickles or fail due to resources or stateful data structures. Garbage collection may not be able to release as much memory. Finalizers may be called later. </P></DD><DT>Thread IDs </DT><DD><P>Thread IDs are 16-bit integers, and as such wrap around pretty quickly. As a consequence, they may often not be unique. This can cause the thread forest display and in particular navigation to become confused when debugging massively concurrent applications, because parent-child relationships cannot be correctly determined. Note however that actions performed on and events generated by threads will always be associated correctly. </P></DD><DT>Spaces </DT><DD><P>Currently, Ozcar will not attach any thread that is not executing in the toplevel space. To debug a search script, execute it on the toplevel as a workaround. </P></DD><DT>Reflection of remote values </DT><DD><P>When debugging remote threads (or distributed applications), the values displayed in stack frames and environments are only approximations of the actual values on the remote site obtained through <A name="label30"></A><EM>reflection</EM>. Currently, the Query dialog executes queries locally and thus operates on the approximations instead of executing remotely and operating on the actual values. </P></DD></DL><P> </P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node8.html#chapter.remote">&lt;&lt; Prev</A></TD><TD><A href="index.html">- Up -</A></TD><TD><A href="node10.html#appendix.menus">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~lorenz/">Benjamin&nbsp;Lorenz</A> and&nbsp;<A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
