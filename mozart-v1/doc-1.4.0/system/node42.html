<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>7.9 Distribution</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node41.html#section.fs.reflection">&lt;&lt; Prev</A></TD><TD><A href="node33.html">- Up -</A></TD></TR></TABLE><DIV id="section.fs.distribution"><H2><A name="section.fs.distribution">7.9 Distribution</A></H2><P>Given a set <I>M</I>, let <IMG alt="{\it lowerBound}({\tt M})" src="latex152.png"> and <IMG alt="{\it
upperBound}({\tt M})" src="latex153.png"> denote the greatest lower bound and the least upper bound currently known for <I>M</I>. Also define <IMG alt="{\it unknown}({\tt M}) =
{\it upperBound}({\tt M}) \backslash {\it lowerBound}({\tt M})" src="latex154.png">. </P><DL><DT><A name="label449"></A> <CODE>distribute</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{FS<SPAN class="keyword">.</SPAN>distribute&nbsp;<SPAN class="keyword">+</SPAN>Dist&nbsp;<SPAN class="keyword">*</SPAN>Ms}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>The vector <CODE>Ms</CODE> is distributed according to the specification <CODE>Dist</CODE>. The following values for <CODE>Dist</CODE> are supported: </P><UL><LI><P><CODE>naive</CODE> is equivalent to <CODE>generic</CODE>, i.&nbsp;e. the default settings apply.</P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE>generic(order:&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Order&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;order<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filter:&nbsp;&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Filter&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">true</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;select:&nbsp;&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Select&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;id<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;element:&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Element&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;element<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rrobin:&nbsp;&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>RRobin&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">false</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;weights:&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Weights&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;{FS<SPAN class="keyword">.</SPAN>makeWeights&nbsp;nil}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;procedure:<SPAN class="keyword">+</SPAN>Proc&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>}&nbsp;<SPAN class="keyword">skip</SPAN>&nbsp;<SPAN class="keyword">end</SPAN>)</CODE></BLOCKQUOTE><P> </P><UL><LI><P><CODE>Order</CODE> </P><UL><LI><P><CODE>naive</CODE> selects the left-most variable.</P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE>order(sel:&nbsp;&nbsp;<SPAN class="keyword">+</SPAN>Sel&nbsp;&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;min<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cost:&nbsp;<SPAN class="keyword">+</SPAN>Cost&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;card&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;comp:&nbsp;<SPAN class="keyword">+</SPAN>Comp&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;unknown)</CODE></BLOCKQUOTE><P> </P><UL><LI><P><CODE>Sel&nbsp;=&nbsp;min</CODE> selects the left-most variable <CODE>S</CODE> from <CODE>Ss</CODE> with the <EM>minimal</EM> cost according to <CODE>Cost</CODE>.</P></LI><LI><P><CODE>Sel&nbsp;=&nbsp;max</CODE> selects the left-most variable <CODE>S</CODE> from <CODE>Ss</CODE> with the <EM>maximal</EM> cost according to <CODE>Cost</CODE>.</P></LI><LI><P><CODE>Cost&nbsp;=&nbsp;card</CODE>: The cost is the cardinality of the set determined by <CODE>Comp</CODE>.</P></LI><LI><P><CODE>Cost&nbsp;=&nbsp;weightSum</CODE>: The cost is the <EM>sum</EM> of the weights associated with the elements of the set determined by <CODE>Comp</CODE>.</P></LI><LI><P><CODE>Cost&nbsp;=&nbsp;weightMin</CODE>: The cost is the <EM>minimal</EM> weight determined by <CODE>Comp</CODE>.</P></LI><LI><P><CODE>Cost&nbsp;=&nbsp;weightMax</CODE>: The cost is the <EM>maximal</EM> weight associated with an element of the set determined by <CODE>Comp</CODE>.</P></LI><LI><P><CODE>Comp&nbsp;=&nbsp;unknown</CODE> selects <IMG alt="{\it unknown}({\tt S})" src="latex155.png">. </P></LI><LI><P><CODE>Comp&nbsp;=&nbsp;lowerBound</CODE> selects <IMG alt="{\it lowerBound}({\tt S})" src="latex156.png">. </P></LI><LI><P><CODE>Comp&nbsp;=&nbsp;upperBound</CODE> selects <IMG alt="{\it upperBound}({\tt S})" src="latex157.png">. </P></LI></UL><P></P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Order</SPAN>&nbsp;<SPAN class="keyword">+</SPAN>Ss}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P></LI></UL><P></P></LI><LI><P><CODE>Filter</CODE> determines if an element <CODE>S</CODE> of <CODE>Ss</CODE> is choosen for distribution. That is the case if <CODE>{IsDet&nbsp;S</CODE>} <EM>and</EM> the filter yields <CODE><SPAN class="keyword">true</SPAN></CODE>. </P><UL><LI><P><CODE><SPAN class="keyword">true</SPAN></CODE> skips values in <CODE>Ss</CODE>.</P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Filter</SPAN>&nbsp;<SPAN class="keyword">+</SPAN>E}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P></LI></UL><P></P></LI><LI><P><CODE>Select</CODE> is used to access the actual finite set variable. Self-defined functions resp. procedures have to apply an appropriate selection function by themselves. </P><UL><LI><P><CODE>id</CODE> is the identity function. </P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Select</SPAN>&nbsp;<SPAN class="keyword">+</SPAN>E}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P></LI></UL><P></P></LI><LI><P><CODE>Element</CODE> </P><UL><LI><P></P><BLOCKQUOTE class="code"><CODE>element(sel:&nbsp;<SPAN class="keyword">+</SPAN>Sel&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;min<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wrt:&nbsp;<SPAN class="keyword">+</SPAN>Wrt&nbsp;<SPAN class="keyword">&lt;=</SPAN>&nbsp;unknown)&nbsp;</CODE></BLOCKQUOTE><P> </P><UL><LI><P><CODE>Sel&nbsp;=&nbsp;min</CODE> selects the <EM>minimal</EM> element with respect to <CODE>Wrt</CODE>. </P></LI><LI><P><CODE>Sel&nbsp;=&nbsp;max</CODE> selects the <EM>maximal</EM> element with respect to <CODE>Wrt</CODE>. </P></LI><LI><P><CODE>Wrt&nbsp;=&nbsp;unknown</CODE> chooses an element from <IMG alt="{\it unknown}(S)" src="latex158.png">. and interprets it as an integer.</P></LI><LI><P><CODE>Wrt&nbsp;=&nbsp;weight</CODE> chooses an element from <IMG alt="{\it unknown}(S)" src="latex158.png"> and takes its weight as selection criterion.</P></LI></UL><P></P></LI><LI><P></P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">fun</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Element</SPAN>&nbsp;<SPAN class="keyword">+</SPAN>E}&nbsp;<SPAN class="keyword">...</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P></P></LI></UL><P></P></LI><LI><P><CODE>RRobin</CODE> </P><UL><LI><P><CODE><SPAN class="keyword">true</SPAN></CODE> causes the distribution to step through the variable list in a round-robin fashion.</P></LI><LI><P><CODE><SPAN class="keyword">false</SPAN></CODE> causes the distribution to completely enumerate the head of the variable list and then proceeds with the head of the tail of the variable list.</P></LI></UL><P></P></LI><LI><P><CODE>Weights</CODE> must be a list of the form <CODE>[E<SPAN class="keyword">#</SPAN>W&nbsp;<SPAN class="keyword">...</SPAN>]</CODE>. The variable <CODE>E</CODE> denotes an element and <CODE>W</CODE> the element's weight. An list element of the form <CODE>default<SPAN class="keyword">#</SPAN>W</CODE> assigns to all not explicitely mentioned elements the weight <CODE>W</CODE>. If there is no element <CODE>default<SPAN class="keyword">#</SPAN>W</CODE> then <CODE>default<SPAN class="keyword">#</SPAN>0</CODE> is implicitely added.</P></LI><LI><P><CODE>Proc</CODE> is applied when stability is reached. Since this application may cause instability, distribution is continued when stability is reached again.</P></LI></UL><P></P></LI></UL><P></P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node41.html#section.fs.reflection">&lt;&lt; Prev</A></TD><TD><A href="node33.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
