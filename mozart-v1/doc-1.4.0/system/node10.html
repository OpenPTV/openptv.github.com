<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>4.1 Basic Search Engines</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html">- Up -</A></TD><TD><A href="node11.html#generalsearch">Next &gt;&gt;</A></TD></TR></TABLE><DIV id="vanillasearch"><H2><A name="vanillasearch">4.1 Basic Search Engines</A></H2><A name="label47"></A><P>All these engines take a script as input and return a list of its solutions.</P><P> </P><DL><DT><CODE>base<SPAN class="keyword">.</SPAN>one</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>one&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the first solution of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first search. If no solution exists, <CODE>nil</CODE> is returned.</P><P>As an example, </P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>one&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;X=ape&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X=bear&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X=cat&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> returns the list <CODE>[ape]</CODE>. </P></DD><DT><CODE>base<SPAN class="keyword">.</SPAN>all</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>all&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>returns the list of all solutions of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by depth-first serach. As an example, </P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>all&nbsp;<SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">$</SPAN>&nbsp;X}<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">choice</SPAN>&nbsp;X=ape&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X=bear&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">[]</SPAN>&nbsp;X=cat&nbsp;&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<SPAN class="keyword">end</SPAN>}</CODE></BLOCKQUOTE><P> returns the list <CODE>[ape&nbsp;bear&nbsp;cat]</CODE>. </P></DD><DT><CODE>Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>best</CODE></DT><DD><BLOCKQUOTE class="synopsis"><P></P><BLOCKQUOTE class="code"><CODE>{Search<SPAN class="keyword">.</SPAN>base<SPAN class="keyword">.</SPAN>best&nbsp;</CODE><CODE>+<I>ScriptP</I></CODE><CODE>&nbsp;</CODE><CODE>+<I>OrderP</I></CODE><CODE>&nbsp;</CODE><CODE>?<I>Xs</I></CODE><CODE>}</CODE></BLOCKQUOTE><P></P></BLOCKQUOTE></DD><DD><P>returns a singleton list containing the best solution with respect to the order <CODE>+<I>OrderP</I></CODE> (a binary procedure) of the script <CODE>+<I>ScriptP</I></CODE> (a unary procedure) obtained by branch and bound search. If no solution does exist, <CODE>nil</CODE> is returned.</P><P>The branch and bound strategy works as follows. When a solution is found, all the remaining alternatives are constrained to be <EM>better</EM> with respect to the order <CODE>+<I>OrderP</I></CODE>. The binary procedure <CODE>+<I>OrderP</I></CODE> is applied with its first argument being the previous solution, and its second argument the root variable of a space for one of the remaining alternatives. </P><P>For instance, the following script constrains its root variable to a pair of integers, such that a certain equation holds between its components. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">Script</SPAN>&nbsp;Root}<BR>&nbsp;&nbsp;&nbsp;X={FD<SPAN class="keyword">.</SPAN>int&nbsp;1<SPAN class="keyword">#</SPAN>10}&nbsp;Y={FD<SPAN class="keyword">.</SPAN>int&nbsp;1<SPAN class="keyword">#</SPAN>10}<BR><SPAN class="keyword">in</SPAN>&nbsp;<BR>&nbsp;&nbsp;&nbsp;Y&nbsp;<SPAN class="keyword">=:</SPAN>&nbsp;10&nbsp;<SPAN class="keyword">-</SPAN>&nbsp;X&nbsp;<SPAN class="keyword">-</SPAN>&nbsp;2<SPAN class="keyword">*</SPAN>Y<BR>&nbsp;&nbsp;&nbsp;Root&nbsp;=&nbsp;X<SPAN class="keyword">#</SPAN>Y<BR>&nbsp;&nbsp;&nbsp;{FD<SPAN class="keyword">.</SPAN>distribute&nbsp;split&nbsp;Root}<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> </P><P>With the order </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MaxSum</SPAN>&nbsp;Old&nbsp;New}<BR>&nbsp;&nbsp;&nbsp;Old<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;Old<SPAN class="keyword">.</SPAN>2&nbsp;<SPAN class="keyword">&lt;:</SPAN>&nbsp;New<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">+</SPAN>&nbsp;New<SPAN class="keyword">.</SPAN>2<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> we can search for a solution with maximal sum of <CODE>X</CODE> and <CODE>Y</CODE> by </P><BLOCKQUOTE class="code"><CODE>{SearchBest&nbsp;Script&nbsp;MaxSum}</CODE></BLOCKQUOTE><P> This returns the singleton list <CODE>[7<SPAN class="keyword">#</SPAN>1]</CODE>. </P><P>Similarly, we can search for the solution with the maximal product, by using the order: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">proc</SPAN><SPAN class="variablename">&nbsp;</SPAN>{<SPAN class="functionname">MaxProduct</SPAN>&nbsp;Old&nbsp;New}<BR>&nbsp;&nbsp;&nbsp;Old<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">*</SPAN>&nbsp;Old<SPAN class="keyword">.</SPAN>2&nbsp;<SPAN class="keyword">&lt;:</SPAN>&nbsp;New<SPAN class="keyword">.</SPAN>1&nbsp;<SPAN class="keyword">*</SPAN>&nbsp;New<SPAN class="keyword">.</SPAN>2<BR><SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> in: </P><BLOCKQUOTE class="code"><CODE>{SearchBest&nbsp;Script&nbsp;MaxProduct}</CODE></BLOCKQUOTE><P> This returns the singleton list <CODE>[4<SPAN class="keyword">#</SPAN>2]</CODE>.</P></DD></DL><P></P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node9.html">- Up -</A></TD><TD><A href="node11.html#generalsearch">Next &gt;&gt;</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A>, <A href="http://www.ps.uni-sb.de/~kornstae/">Leif&nbsp;Kornstaedt</A>, <A href="http://www.ps.uni-sb.de/~homik/">Martin&nbsp;Homik</A>, <A href="http://www.ps.uni-sb.de/~tmueller/">Tobias&nbsp;Müller</A>, <A href="http://www.ps.uni-sb.de/~schulte/">Christian&nbsp;Schulte</A> and&nbsp;<A href="http://www.info.ucl.ac.be/~pvr">Peter&nbsp;Van Roy</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
