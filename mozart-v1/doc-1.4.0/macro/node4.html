<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD><TITLE>1.3 Backquote Macro</TITLE><LINK href="ozdoc.css" rel="stylesheet" type="text/css"></HEAD><BODY><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#section.macro.module">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD></TR></TABLE><DIV id="section.backquote.macro"><H2><A name="section.backquote.macro">1.3 Backquote Macro</A></H2><P>Writing macros using only the <EM>Syntax Tree Format</EM> can be quite difficult. The backquote macro makes some of it a little bit easier. The Mozart backquote macro was inspired by the classical Lisp backquote macro. However, it is not quite as nice and easy as in Lisp: in Lisp all source code is represented by lists, which makes syntactic manipulation quite uniform and simple. Oz, on the other hand, is a language that makes heavy use of keywords and special notations. Its natural representation is the <EM>Syntax Tree Format</EM> described in <A href="../compiler/node7.html#appendix.syntax">Appendix&nbsp;C of ``The Mozart Compiler''</A> which is more structured and does not lend itself quite as easily to uniform processing. Nonetheless, if you ever write macros, you will find the backquote facility of great convenience, even if it only gets you part of the way.</P><P>The idea of the backquote facility is that it gives you convenient first class access to syntactic representation of code. For example: </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;U&nbsp;=&nbsp;<SPAN class="keyword">&lt;&lt;</SPAN><SPAN class="string">'`'</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{F&nbsp;X}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;X<SPAN class="keyword">+</SPAN>1&nbsp;<SPAN class="keyword">end&gt;&gt;</SPAN></CODE></BLOCKQUOTE><P> Causes <CODE>U</CODE> to be bound to the <EM>Syntax Tree Format</EM> representation of the code <CODE><SPAN class="keyword">if</SPAN>&nbsp;{F&nbsp;X}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;X<SPAN class="keyword">+</SPAN>1&nbsp;<SPAN class="keyword">end</SPAN></CODE>.</P><P>Furthermore, within the scope of a backquote macro, you can invoke the ``comma'' macro to insert a piece of syntactic representation. </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">declare</SPAN>&nbsp;V&nbsp;=&nbsp;<SPAN class="keyword">&lt;&lt;</SPAN><SPAN class="string">'`'</SPAN>&nbsp;<SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;=&nbsp;7&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">&lt;&lt;</SPAN><SPAN class="string">','</SPAN>&nbsp;U<SPAN class="keyword">&gt;&gt;</SPAN>&nbsp;<SPAN class="keyword">end&gt;&gt;</SPAN></CODE></BLOCKQUOTE><P> <CODE>V</CODE> is now bound to the syntactic representation of </P><BLOCKQUOTE class="code"><CODE><SPAN class="keyword">local</SPAN>&nbsp;X&nbsp;=&nbsp;7&nbsp;<SPAN class="keyword">in</SPAN>&nbsp;<SPAN class="keyword">if</SPAN>&nbsp;{F&nbsp;X}&nbsp;<SPAN class="keyword">then</SPAN>&nbsp;X<SPAN class="keyword">+</SPAN>1&nbsp;<SPAN class="keyword">end</SPAN>&nbsp;<SPAN class="keyword">end</SPAN></CODE></BLOCKQUOTE><P> The limits of this technique are simply the limits of the Oz syntax: each macro invocation must represent one ``phrase'' in the language.</P></DIV><TABLE align="center" border="0" cellpadding="6" cellspacing="6" class="nav"><TR bgcolor="#DDDDDD"><TD><A href="node3.html#section.macro.module">&lt;&lt; Prev</A></TD><TD><A href="node1.html">- Up -</A></TD></TR></TABLE><HR><ADDRESS><A href="http://www.ps.uni-sb.de/~duchier/">Denys&nbsp;Duchier</A><BR><SPAN class="version">Version 1.4.0 (20080702)</SPAN></ADDRESS></BODY></HTML>
